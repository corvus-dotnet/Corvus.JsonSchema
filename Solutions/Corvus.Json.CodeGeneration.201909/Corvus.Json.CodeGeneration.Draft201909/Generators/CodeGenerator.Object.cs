//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:7.0.11
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Corvus.Json.CodeGeneration.Generators.Draft201909 {
    using System.Collections.Generic;
    using Corvus.Json;
    using System;
    
    
    public partial class CodeGeneratorObject : CodeGeneratorObjectBase {
        
        
        #line 700 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"

    public bool ShouldGenerate
    {
        get
        {
            return IsImplicitObject || IsNotImplicitType;
        }
    }

        #line default
        #line hidden
        
        
        public virtual string TransformText() {
            this.GenerationEnvironment = null;
            
            #line 4 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"

    // This is only emitted if IsImplicitObject is true
    if(!ShouldGenerate)
    {
        throw new InvalidOperationException("CodeGenerator.Object should not be emitted if IsImplicitObject is false.");
    } 
            
            #line default
            #line hidden
            
            #line 10 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Text.Json;
using Corvus.Json;
using Corvus.Json.Internal;

namespace ");
            
            #line default
            #line hidden
            
            #line 27 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( Namespace ));
            
            #line default
            #line hidden
            
            #line 27 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(";\r\n\r\n");
            
            #line default
            #line hidden
            
            #line 29 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
 BeginNesting(); 
            
            #line default
            #line hidden
            
            #line 30 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write("/// <summary>\r\n/// A type generated from a JsonSchema specification.\r\n/// </summa" +
                    "ry>\r\npublic readonly partial struct ");
            
            #line default
            #line hidden
            
            #line 33 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 33 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" : IJsonObject<");
            
            #line default
            #line hidden
            
            #line 33 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 33 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(">\r\n{\r\n    /// <summary>\r\n    /// Initializes a new instance of the <see cref=\"");
            
            #line default
            #line hidden
            
            #line 36 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 36 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write("\"/> struct.\r\n    /// </summary>\r\n    /// <param name=\"value\">The value from which" +
                    " to construct the instance.</param>\r\n    public ");
            
            #line default
            #line hidden
            
            #line 39 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 39 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write("(ImmutableDictionary<JsonPropertyName, JsonAny> value)\r\n    {\r\n        this.jsonE" +
                    "lementBacking = default;\r\n        this.backing = Backing.Object;\r\n");
            
            #line default
            #line hidden
            
            #line 43 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
  if(IsImplicitString || IsNotImplicitType)
    { 
            
            #line default
            #line hidden
            
            #line 45 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write("        this.stringBacking = string.Empty;\r\n");
            
            #line default
            #line hidden
            
            #line 46 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
  }
    if(IsImplicitBoolean || IsNotImplicitType)
    { 
            
            #line default
            #line hidden
            
            #line 49 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write("        this.boolBacking = default;\r\n");
            
            #line default
            #line hidden
            
            #line 50 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
  }
    if(IsImplicitNumber || IsNotImplicitType)
    { 
            
            #line default
            #line hidden
            
            #line 53 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write("        this.numberBacking = default;\r\n");
            
            #line default
            #line hidden
            
            #line 54 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
  }
    if(IsImplicitArray || IsNotImplicitType)
    { 
            
            #line default
            #line hidden
            
            #line 57 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write("        this.arrayBacking = ImmutableList<JsonAny>.Empty;\r\n");
            
            #line default
            #line hidden
            
            #line 58 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
  } 
            
            #line default
            #line hidden
            
            #line 59 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(@"        this.objectBacking = value;
    }

    /// <inheritdoc/>
    public ImmutableDictionary<JsonPropertyName, JsonAny> AsImmutableDictionary()
    {
        return this.GetImmutableDictionary();
    }

    /// <inheritdoc/>
    public ImmutableDictionary<JsonPropertyName, JsonAny>.Builder AsImmutableDictionaryBuilder()
    {
        return this.GetImmutableDictionaryBuilder();
    }

    /// <inheritdoc/>
    public JsonAny this[in JsonPropertyName name]
    {
        get
        {
            if (this.TryGetProperty(name, out JsonAny result))
            {
                return result;
            }

            throw new IndexOutOfRangeException();
        }
    }

    /// <summary>
    /// Conversion from JsonObject.
    /// </summary>
    /// <param name=""value"">The value from which to convert.</param>
    public static implicit operator JsonObject(");
            
            #line default
            #line hidden
            
            #line 92 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 92 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" value)\r\n    {\r\n        return JsonObject.FromObject(value);\r\n    }\r\n\r\n    /// <s" +
                    "ummary>\r\n    /// Conversion to JsonObject.\r\n    /// </summary>\r\n    /// <param n" +
                    "ame=\"value\">The value from which to convert.</param>\r\n    public static implicit" +
                    " operator ");
            
            #line default
            #line hidden
            
            #line 101 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 101 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(@"(JsonObject value)
    {
        if (value.HasJsonElementBacking)
        {
            return new(value.AsJsonElement);
        }

        return new(value.AsImmutableDictionary());
    }

    /// <summary>
    /// Conversion from immutable dictionary.
    /// </summary>
    /// <param name=""value"">The value from which to convert.</param>
    public static implicit operator ");
            
            #line default
            #line hidden
            
            #line 115 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 115 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(@"(ImmutableDictionary<JsonPropertyName, JsonAny> value)
    {
        return new(value);
    }

    /// <summary>
    /// Conversion to immutable dictionary.
    /// </summary>
    /// <param name=""value"">The value from which to convert.</param>
    public static implicit operator ImmutableDictionary<JsonPropertyName, JsonAny>(");
            
            #line default
            #line hidden
            
            #line 124 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 124 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(@" value)
    {
        return value.GetImmutableDictionary();
    }

    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name=""source"">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    public static ");
            
            #line default
            #line hidden
            
            #line 134 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 134 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(@" FromProperties(IDictionary<JsonPropertyName, JsonAny> source)
    {
        return new(source.ToImmutableDictionary());
    }

    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name=""source"">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    public static ");
            
            #line default
            #line hidden
            
            #line 144 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 144 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(@" FromProperties(ImmutableDictionary<JsonPropertyName, JsonAny> source)
    {
        return new(source);
    }

    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name=""source"">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    public static ");
            
            #line default
            #line hidden
            
            #line 154 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 154 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" FromProperties(params (JsonPropertyName Name, JsonAny Value)[] source)\r\n    {\r\n " +
                    "       return new(source.ToImmutableDictionary(k => k.Name, v => v.Value));\r\n   " +
                    " }\r\n\r\n    /// <inheritdoc/>\r\n    public JsonObjectEnumerator EnumerateObject()\r\n" +
                    "    {\r\n        if ((this.backing & Backing.JsonElement) != 0)\r\n        {\r\n      " +
                    "      return new(this.jsonElementBacking);\r\n        }\r\n\r\n        if ((this.backi" +
                    "ng & Backing.Object) != 0)\r\n        {\r\n            return new(this.objectBacking" +
                    ");\r\n        }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n    //" +
                    "/ <inheritdoc/>\r\n    public bool HasProperties()\r\n    {\r\n        if ((this.backi" +
                    "ng & Backing.Object) != 0)\r\n        {\r\n            return this.objectBacking.Cou" +
                    "nt > 0;\r\n        }\r\n\r\n        if ((this.backing & Backing.JsonElement) != 0)\r\n  " +
                    "      {\r\n            using JsonElement.ObjectEnumerator enumerator = this.jsonEl" +
                    "ementBacking.EnumerateObject();\r\n            return enumerator.MoveNext();\r\n    " +
                    "    }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n    /// <inher" +
                    "itdoc/>\r\n    public bool HasProperty(in JsonPropertyName name)\r\n    {\r\n        i" +
                    "f ((this.backing & Backing.JsonElement) != 0)\r\n        {\r\n            // String " +
                    "is the fastest approach right now. If JsonPropertyName changes\r\n            // i" +
                    "ts internal implementation, we should switch this out.\r\n            return this." +
                    "jsonElementBacking.TryGetProperty((string)name, out _);\r\n        }\r\n\r\n        if" +
                    " ((this.backing & Backing.Object) != 0)\r\n        {\r\n            return this.obje" +
                    "ctBacking.ContainsKey(name);\r\n        }\r\n\r\n        throw new InvalidOperationExc" +
                    "eption();\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public bool HasProperty(string na" +
                    "me)\r\n    {\r\n        if ((this.backing & Backing.JsonElement) != 0)\r\n        {\r\n " +
                    "           return this.jsonElementBacking.TryGetProperty(name, out _);\r\n        " +
                    "}\r\n\r\n        if ((this.backing & Backing.Object) != 0)\r\n        {\r\n            r" +
                    "eturn this.objectBacking.ContainsKey(name);\r\n        }\r\n\r\n        throw new Inva" +
                    "lidOperationException();\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public bool HasPro" +
                    "perty(ReadOnlySpan<char> name)\r\n    {\r\n        if ((this.backing & Backing.JsonE" +
                    "lement) != 0)\r\n        {\r\n            return this.jsonElementBacking.TryGetPrope" +
                    "rty(name, out _);\r\n        }\r\n\r\n        if ((this.backing & Backing.Object) != 0" +
                    ")\r\n        {\r\n            return this.objectBacking.ContainsKey(name);\r\n        " +
                    "}\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n    /// <inheritdo" +
                    "c/>\r\n    public bool HasProperty(ReadOnlySpan<byte> utf8Name)\r\n    {\r\n        if" +
                    " ((this.backing & Backing.JsonElement) != 0)\r\n        {\r\n            return this" +
                    ".jsonElementBacking.TryGetProperty(utf8Name, out _);\r\n        }\r\n\r\n        if ((" +
                    "this.backing & Backing.Object) != 0)\r\n        {\r\n            return this.objectB" +
                    "acking.ContainsKey(utf8Name);\r\n        }\r\n\r\n        throw new InvalidOperationEx" +
                    "ception();\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public bool TryGetProperty(in Js" +
                    "onPropertyName name, out JsonAny value)\r\n    {\r\n        if ((this.backing & Back" +
                    "ing.JsonElement) != 0)\r\n        {\r\n            // String is the fastest approach" +
                    " right now. If JsonPropertyName changes\r\n            // its internal implementat" +
                    "ion, we should switch this out.\r\n            if (this.jsonElementBacking.TryGetP" +
                    "roperty((string)name, out JsonElement result))\r\n            {\r\n                v" +
                    "alue = new(result);\r\n                return true;\r\n            }\r\n\r\n            " +
                    "value = default;\r\n            return false;\r\n        }\r\n\r\n        if ((this.back" +
                    "ing & Backing.Object) != 0)\r\n        {\r\n            return this.objectBacking.Tr" +
                    "yGetValue(name, out value);\r\n        }\r\n\r\n        throw new InvalidOperationExce" +
                    "ption();\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public bool TryGetProperty(string " +
                    "name, out JsonAny value)\r\n    {\r\n        if ((this.backing & Backing.JsonElement" +
                    ") != 0)\r\n        {\r\n            if (this.jsonElementBacking.TryGetProperty(name," +
                    " out JsonElement result))\r\n            {\r\n                value = new(result);\r\n" +
                    "                return true;\r\n            }\r\n\r\n            value = default;\r\n   " +
                    "         return false;\r\n        }\r\n\r\n        if ((this.backing & Backing.Object)" +
                    " != 0)\r\n        {\r\n            return this.objectBacking.TryGetValue(name, out v" +
                    "alue);\r\n        }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n  " +
                    "  /// <inheritdoc/>\r\n    public bool TryGetProperty(ReadOnlySpan<char> name, out" +
                    " JsonAny value)\r\n    {\r\n        if ((this.backing & Backing.JsonElement) != 0)\r\n" +
                    "        {\r\n            if (this.jsonElementBacking.TryGetProperty(name, out Json" +
                    "Element result))\r\n            {\r\n                value = new(result);\r\n         " +
                    "       return true;\r\n            }\r\n\r\n            value = default;\r\n            " +
                    "return false;\r\n        }\r\n\r\n        if ((this.backing & Backing.Object) != 0)\r\n " +
                    "       {\r\n            return this.objectBacking.TryGetValue(name, out value);\r\n " +
                    "       }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n    /// <in" +
                    "heritdoc/>\r\n    public bool TryGetProperty(ReadOnlySpan<byte> utf8Name, out Json" +
                    "Any value)\r\n    {\r\n        if ((this.backing & Backing.JsonElement) != 0)\r\n     " +
                    "   {\r\n            if (this.jsonElementBacking.TryGetProperty(utf8Name, out JsonE" +
                    "lement result))\r\n            {\r\n                value = new(result);\r\n          " +
                    "      return true;\r\n            }\r\n\r\n            value = default;\r\n            r" +
                    "eturn false;\r\n        }\r\n\r\n        if ((this.backing & Backing.Object) != 0)\r\n  " +
                    "      {\r\n            return this.objectBacking.TryGetValue(utf8Name, out value);" +
                    "\r\n        }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n    /// " +
                    "<inheritdoc/>\r\n    public bool TryGetProperty<TValue>(in JsonPropertyName name, " +
                    "out TValue value)\r\n        where TValue : struct, IJsonValue<TValue>\r\n    {\r\n   " +
                    "     if ((this.backing & Backing.JsonElement) != 0)\r\n        {\r\n            // S" +
                    "tring is the fastest approach right now. If JsonPropertyName changes\r\n          " +
                    "  // its internal implementation, we should switch this out.\r\n            if (th" +
                    "is.jsonElementBacking.TryGetProperty((string)name, out JsonElement result))\r\n   " +
                    "         {\r\n                value = TValue.FromJson(result);\r\n                re" +
                    "turn true;\r\n            }\r\n\r\n            value = default;\r\n            return fa" +
                    "lse;\r\n        }\r\n\r\n        if ((this.backing & Backing.Object) != 0)\r\n        {\r" +
                    "\n            if (this.objectBacking.TryGetValue(name, out JsonAny result))\r\n    " +
                    "        {\r\n                value = TValue.FromAny(result);\r\n                retu" +
                    "rn true;\r\n            }\r\n\r\n            value = default;\r\n            return fals" +
                    "e;\r\n        }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n    //" +
                    "/ <inheritdoc/>\r\n    public bool TryGetProperty<TValue>(string name, out TValue " +
                    "value)\r\n        where TValue : struct, IJsonValue<TValue>\r\n    {\r\n        if ((t" +
                    "his.backing & Backing.JsonElement) != 0)\r\n        {\r\n            // String is th" +
                    "e fastest approach right now. If JsonPropertyName changes\r\n            // its in" +
                    "ternal implementation, we should switch this out.\r\n            if (this.jsonElem" +
                    "entBacking.TryGetProperty(name, out JsonElement result))\r\n            {\r\n       " +
                    "         value = TValue.FromJson(result);\r\n                return true;\r\n       " +
                    "     }\r\n\r\n            value = default;\r\n            return false;\r\n        }\r\n\r\n" +
                    "        if ((this.backing & Backing.Object) != 0)\r\n        {\r\n            if (th" +
                    "is.objectBacking.TryGetValue(name, out JsonAny result))\r\n            {\r\n        " +
                    "        value = TValue.FromAny(result);\r\n                return true;\r\n         " +
                    "   }\r\n\r\n            value = default;\r\n            return false;\r\n        }\r\n\r\n  " +
                    "      throw new InvalidOperationException();\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n  " +
                    "  public bool TryGetProperty<TValue>(ReadOnlySpan<char> name, out TValue value)\r" +
                    "\n        where TValue : struct, IJsonValue<TValue>\r\n    {\r\n        if ((this.bac" +
                    "king & Backing.JsonElement) != 0)\r\n        {\r\n            if (this.jsonElementBa" +
                    "cking.TryGetProperty(name, out JsonElement result))\r\n            {\r\n            " +
                    "    value = TValue.FromJson(result);\r\n                return true;\r\n            " +
                    "}\r\n\r\n            value = default;\r\n            return false;\r\n        }\r\n\r\n     " +
                    "   if ((this.backing & Backing.Object) != 0)\r\n        {\r\n            if (this.ob" +
                    "jectBacking.TryGetValue(name, out JsonAny result))\r\n            {\r\n             " +
                    "   value = TValue.FromAny(result);\r\n                return true;\r\n            }\r" +
                    "\n\r\n            value = default;\r\n            return false;\r\n        }\r\n\r\n       " +
                    " throw new InvalidOperationException();\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    pub" +
                    "lic bool TryGetProperty<TValue>(ReadOnlySpan<byte> utf8Name, out TValue value)\r\n" +
                    "        where TValue : struct, IJsonValue<TValue>\r\n    {\r\n        if ((this.back" +
                    "ing & Backing.JsonElement) != 0)\r\n        {\r\n            if (this.jsonElementBac" +
                    "king.TryGetProperty(utf8Name, out JsonElement result))\r\n            {\r\n         " +
                    "       value = TValue.FromJson(result);\r\n                return true;\r\n         " +
                    "   }\r\n\r\n            value = default;\r\n            return false;\r\n        }\r\n\r\n  " +
                    "      if ((this.backing & Backing.Object) != 0)\r\n        {\r\n            if (this" +
                    ".objectBacking.TryGetValue(utf8Name, out JsonAny result))\r\n            {\r\n      " +
                    "          value = TValue.FromAny(result);\r\n                return true;\r\n       " +
                    "     }\r\n\r\n            value = default;\r\n            return false;\r\n        }\r\n\r\n" +
                    "        throw new InvalidOperationException();\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n" +
                    "    public ");
            
            #line default
            #line hidden
            
            #line 481 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 481 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" SetProperty<TValue>(in JsonPropertyName name, TValue value)\r\n        where TValu" +
                    "e : struct, IJsonValue\r\n    {\r\n        return new(this.GetImmutableDictionaryWit" +
                    "h(name, value.AsAny));\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public ");
            
            #line default
            #line hidden
            
            #line 488 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 488 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" SetProperty<TValue>(string name, TValue value)\r\n        where TValue : struct, I" +
                    "JsonValue\r\n    {\r\n        return new(this.GetImmutableDictionaryWith(name, value" +
                    ".AsAny));\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public ");
            
            #line default
            #line hidden
            
            #line 495 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 495 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)\r\n        where TValue" +
                    " : struct, IJsonValue\r\n    {\r\n        return new(this.GetImmutableDictionaryWith" +
                    "(name, value.AsAny));\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public ");
            
            #line default
            #line hidden
            
            #line 502 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 502 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" SetProperty<TValue>(ReadOnlySpan<byte> utf8Name, TValue value)\r\n        where TV" +
                    "alue : struct, IJsonValue\r\n    {\r\n        return new(this.GetImmutableDictionary" +
                    "With(utf8Name, value.AsAny));\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public ");
            
            #line default
            #line hidden
            
            #line 509 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 509 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" RemoveProperty(in JsonPropertyName name)\r\n    {\r\n        return new(this.GetImmu" +
                    "tableDictionaryWithout(name));\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public ");
            
            #line default
            #line hidden
            
            #line 515 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 515 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" RemoveProperty(string name)\r\n    {\r\n        return new(this.GetImmutableDictiona" +
                    "ryWithout(name));\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public ");
            
            #line default
            #line hidden
            
            #line 521 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 521 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" RemoveProperty(ReadOnlySpan<char> name)\r\n    {\r\n        return new(this.GetImmut" +
                    "ableDictionaryWithout(name));\r\n    }\r\n\r\n    /// <inheritdoc/>\r\n    public ");
            
            #line default
            #line hidden
            
            #line 527 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture( TypeDeclaration.DotnetTypeName ));
            
            #line default
            #line hidden
            
            #line 527 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
            this.Write(" RemoveProperty(ReadOnlySpan<byte> utf8Name)\r\n    {\r\n        return new(this.GetI" +
                    "mmutableDictionaryWithout(utf8Name));\r\n    }\r\n\r\n    /// <summary>\r\n    /// Build" +
                    "s an <see cref=\"ImmutableDictionary{JsonPropertyName, JsonAny}\"/> from the objec" +
                    "t.\r\n    /// </summary>\r\n    /// <returns>An immutable list of <see cref=\"JsonAny" +
                    "\"/> built from the array.</returns>\r\n    /// <exception cref=\"InvalidOperationEx" +
                    "ception\">The value is not an array.</exception>\r\n    private ImmutableDictionary" +
                    "<JsonPropertyName, JsonAny> GetImmutableDictionary()\r\n    {\r\n        if ((this.b" +
                    "acking & Backing.Object) != 0)\r\n        {\r\n            return this.objectBacking" +
                    ";\r\n        }\r\n\r\n        return this.GetImmutableDictionaryBuilder().ToImmutable(" +
                    ");\r\n    }\r\n\r\n    /// <summary>\r\n    /// Builds an <see cref=\"ImmutableDictionary" +
                    "{JsonPropertyName, JsonAny}\"/> from the object, without a specific property.\r\n  " +
                    "  /// </summary>\r\n    /// <returns>An immutable dictionary builder of <see cref=" +
                    "\"JsonPropertyName\"/> to <see cref=\"JsonAny\"/>, built from the existing object, w" +
                    "ithout the given property.</returns>\r\n    /// <exception cref=\"InvalidOperationE" +
                    "xception\">The value is not an object.</exception>\r\n    private ImmutableDictiona" +
                    "ry<JsonPropertyName, JsonAny> GetImmutableDictionaryWithout(in JsonPropertyName " +
                    "name)\r\n    {\r\n        if ((this.backing & Backing.Object) != 0)\r\n        {\r\n    " +
                    "        return this.objectBacking.Remove(name);\r\n        }\r\n\r\n        return thi" +
                    "s.GetImmutableDictionaryBuilderWithout(name).ToImmutable();\r\n    }\r\n\r\n    /// <s" +
                    "ummary>\r\n    /// Builds an <see cref=\"ImmutableDictionary{JsonPropertyName, Json" +
                    "Any}\"/> from the object, without a specific property.\r\n    /// </summary>\r\n    /" +
                    "// <returns>An immutable dictionary builder of <see cref=\"JsonPropertyName\"/> to" +
                    " <see cref=\"JsonAny\"/>, built from the existing object, without the given proper" +
                    "ty.</returns>\r\n    /// <exception cref=\"InvalidOperationException\">The value is " +
                    "not an object.</exception>\r\n    private ImmutableDictionary<JsonPropertyName, Js" +
                    "onAny> GetImmutableDictionaryWithout(ReadOnlySpan<char> name)\r\n    {\r\n        if" +
                    " ((this.backing & Backing.Object) != 0)\r\n        {\r\n            return this.obje" +
                    "ctBacking.Remove(name);\r\n        }\r\n\r\n        return this.GetImmutableDictionary" +
                    "BuilderWithout(name).ToImmutable();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Builds " +
                    "an <see cref=\"ImmutableDictionary{JsonPropertyName, JsonAny}\"/> from the object," +
                    " without a specific property.\r\n    /// </summary>\r\n    /// <returns>An immutable" +
                    " dictionary builder of <see cref=\"JsonPropertyName\"/> to <see cref=\"JsonAny\"/>, " +
                    "built from the existing object, without the given property.</returns>\r\n    /// <" +
                    "exception cref=\"InvalidOperationException\">The value is not an object.</exceptio" +
                    "n>\r\n    private ImmutableDictionary<JsonPropertyName, JsonAny> GetImmutableDicti" +
                    "onaryWith(in JsonPropertyName name, in JsonAny value)\r\n    {\r\n        if ((this." +
                    "backing & Backing.Object) != 0)\r\n        {\r\n            return this.objectBackin" +
                    "g.SetItem(name, value);\r\n        }\r\n\r\n        ImmutableDictionary<JsonPropertyNa" +
                    "me, JsonAny>.Builder result = this.GetImmutableDictionaryBuilder();\r\n        if " +
                    "(result.ContainsKey(name))\r\n        {\r\n            result.Remove(name);\r\n       " +
                    " }\r\n\r\n        result.Add(name, value);\r\n        return result.ToImmutable();\r\n  " +
                    "  }\r\n\r\n    /// <summary>\r\n    /// Builds an <see cref=\"ImmutableDictionary{JsonP" +
                    "ropertyName, JsonAny}.Builder\"/> from the object.\r\n    /// </summary>\r\n    /// <" +
                    "returns>An immutable dictionary builder of <see cref=\"JsonPropertyName\"/> to <se" +
                    "e cref=\"JsonAny\"/>, built from the existing object.</returns>\r\n    /// <exceptio" +
                    "n cref=\"InvalidOperationException\">The value is not an object.</exception>\r\n    " +
                    "private ImmutableDictionary<JsonPropertyName, JsonAny>.Builder GetImmutableDicti" +
                    "onaryBuilder()\r\n    {\r\n        if ((this.backing & Backing.JsonElement) != 0 && " +
                    "this.jsonElementBacking.ValueKind == JsonValueKind.Object)\r\n        {\r\n         " +
                    "   ImmutableDictionary<JsonPropertyName, JsonAny>.Builder builder = ImmutableDic" +
                    "tionary.CreateBuilder<JsonPropertyName, JsonAny>();\r\n            foreach (JsonPr" +
                    "operty property in this.jsonElementBacking.EnumerateObject())\r\n            {\r\n  " +
                    "              builder.Add(property.Name, new(property.Value));\r\n            }\r\n\r" +
                    "\n            return builder;\r\n        }\r\n\r\n        if ((this.backing & Backing.O" +
                    "bject) != 0)\r\n        {\r\n            return this.objectBacking.ToBuilder();\r\n   " +
                    "     }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n    /// <summ" +
                    "ary>\r\n    /// Builds an <see cref=\"ImmutableDictionary{JsonPropertyName, JsonAny" +
                    "}.Builder\"/> from the object, without a specific property.\r\n    /// </summary>\r\n" +
                    "    /// <returns>An immutable dictionary builder of <see cref=\"JsonPropertyName\"" +
                    "/> to <see cref=\"JsonAny\"/>, built from the existing object.</returns>\r\n    /// " +
                    "<exception cref=\"InvalidOperationException\">The value is not an object.</excepti" +
                    "on>\r\n    private ImmutableDictionary<JsonPropertyName, JsonAny>.Builder GetImmut" +
                    "ableDictionaryBuilderWithout(in JsonPropertyName name)\r\n    {\r\n        if ((this" +
                    ".backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == Jso" +
                    "nValueKind.Object)\r\n        {\r\n            ImmutableDictionary<JsonPropertyName," +
                    " JsonAny>.Builder builder = ImmutableDictionary.CreateBuilder<JsonPropertyName, " +
                    "JsonAny>();\r\n\r\n            JsonElement.ObjectEnumerator enumerator = this.jsonEl" +
                    "ementBacking.EnumerateObject();\r\n\r\n            while (enumerator.MoveNext())\r\n  " +
                    "          {\r\n                // Use string for the current implementation of Jso" +
                    "nPropertyName\r\n                if (enumerator.Current.NameEquals((string)name))\r" +
                    "\n                {\r\n                    // Skip this one.\r\n                    b" +
                    "reak;\r\n                }\r\n\r\n                builder.Add(enumerator.Current.Name," +
                    " new(enumerator.Current.Value));\r\n            }\r\n\r\n            // We\'ve found th" +
                    "e property to eliminate, so we can work through the rest without checking names." +
                    "\r\n            while (enumerator.MoveNext())\r\n            {\r\n                buil" +
                    "der.Add(enumerator.Current.Name, new(enumerator.Current.Value));\r\n            }\r" +
                    "\n\r\n            return builder;\r\n        }\r\n\r\n        if ((this.backing & Backing" +
                    ".Object) != 0)\r\n        {\r\n            return this.objectBacking.ToBuilder();\r\n " +
                    "       }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n\r\n    /// <su" +
                    "mmary>\r\n    /// Builds an <see cref=\"ImmutableDictionary{JsonPropertyName, JsonA" +
                    "ny}.Builder\"/> from the object, without a specific property.\r\n    /// </summary>" +
                    "\r\n    /// <returns>An immutable dictionary builder of <see cref=\"JsonPropertyNam" +
                    "e\"/> to <see cref=\"JsonAny\"/>, built from the existing object.</returns>\r\n    //" +
                    "/ <exception cref=\"InvalidOperationException\">The value is not an object.</excep" +
                    "tion>\r\n    private ImmutableDictionary<JsonPropertyName, JsonAny>.Builder GetImm" +
                    "utableDictionaryBuilderWithout(ReadOnlySpan<char> name)\r\n    {\r\n        if ((thi" +
                    "s.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == Js" +
                    "onValueKind.Object)\r\n        {\r\n            ImmutableDictionary<JsonPropertyName" +
                    ", JsonAny>.Builder builder = ImmutableDictionary.CreateBuilder<JsonPropertyName," +
                    " JsonAny>();\r\n\r\n            JsonElement.ObjectEnumerator enumerator = this.jsonE" +
                    "lementBacking.EnumerateObject();\r\n\r\n            while (enumerator.MoveNext())\r\n " +
                    "           {\r\n                builder.Add(enumerator.Current.Name, new(enumerato" +
                    "r.Current.Value));\r\n            }\r\n\r\n            // It is (currently) benchmarke" +
                    "d to be faster to add them all, then remove the\r\n            // one from the has" +
                    "htable, than it is to check them all on the way through.\r\n            builder.Re" +
                    "move(name);\r\n            return builder;\r\n        }\r\n\r\n        if ((this.backing" +
                    " & Backing.Object) != 0)\r\n        {\r\n            return this.objectBacking.ToBui" +
                    "lder();\r\n        }\r\n\r\n        throw new InvalidOperationException();\r\n    }\r\n}\r\n" +
                    "");
            
            #line default
            #line hidden
            
            #line 699 "../../Corvus.Json.CodeGeneration.Abstractions/SharedTemplates/CodeGenerator.Object.tt"
 EndNesting(); 
            
            #line default
            #line hidden
            return this.GenerationEnvironment.ToString();
        }
        
        public virtual void Initialize() {
        }
    }
    
    public class CodeGeneratorObjectBase {
        
        private global::System.Text.StringBuilder builder;
        
        private global::System.Collections.Generic.IDictionary<string, object> session;
        
        private global::System.CodeDom.Compiler.CompilerErrorCollection errors;
        
        private string currentIndent = string.Empty;
        
        private global::System.Collections.Generic.Stack<int> indents;
        
        private ToStringInstanceHelper _toStringHelper = new ToStringInstanceHelper();
        
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session {
            get {
                return this.session;
            }
            set {
                this.session = value;
            }
        }
        
        public global::System.Text.StringBuilder GenerationEnvironment {
            get {
                if ((this.builder == null)) {
                    this.builder = new global::System.Text.StringBuilder();
                }
                return this.builder;
            }
            set {
                this.builder = value;
            }
        }
        
        protected global::System.CodeDom.Compiler.CompilerErrorCollection Errors {
            get {
                if ((this.errors == null)) {
                    this.errors = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errors;
            }
        }
        
        public string CurrentIndent {
            get {
                return this.currentIndent;
            }
        }
        
        private global::System.Collections.Generic.Stack<int> Indents {
            get {
                if ((this.indents == null)) {
                    this.indents = new global::System.Collections.Generic.Stack<int>();
                }
                return this.indents;
            }
        }
        
        public ToStringInstanceHelper ToStringHelper {
            get {
                return this._toStringHelper;
            }
        }
        
        public void Error(string message) {
            this.Errors.Add(new global::System.CodeDom.Compiler.CompilerError(null, -1, -1, null, message));
        }
        
        public void Warning(string message) {
            global::System.CodeDom.Compiler.CompilerError val = new global::System.CodeDom.Compiler.CompilerError(null, -1, -1, null, message);
            val.IsWarning = true;
            this.Errors.Add(val);
        }
        
        public string PopIndent() {
            if ((this.Indents.Count == 0)) {
                return string.Empty;
            }
            int lastPos = (this.currentIndent.Length - this.Indents.Pop());
            string last = this.currentIndent.Substring(lastPos);
            this.currentIndent = this.currentIndent.Substring(0, lastPos);
            return last;
        }
        
        public void PushIndent(string indent) {
            this.Indents.Push(indent.Length);
            this.currentIndent = (this.currentIndent + indent);
        }
        
        public void ClearIndent() {
            this.currentIndent = string.Empty;
            this.Indents.Clear();
        }
        
        public void Write(string textToAppend) {
            this.GenerationEnvironment.Append(textToAppend);
        }
        
        public void Write(string format, params object[] args) {
            this.GenerationEnvironment.AppendFormat(format, args);
        }
        
        public void WriteLine(string textToAppend) {
            this.GenerationEnvironment.Append(this.currentIndent);
            this.GenerationEnvironment.AppendLine(textToAppend);
        }
        
        public void WriteLine(string format, params object[] args) {
            this.GenerationEnvironment.Append(this.currentIndent);
            this.GenerationEnvironment.AppendFormat(format, args);
            this.GenerationEnvironment.AppendLine();
        }
        
        public class ToStringInstanceHelper {
            
            private global::System.IFormatProvider formatProvider = global::System.Globalization.CultureInfo.InvariantCulture;
            
            public global::System.IFormatProvider FormatProvider {
                get {
                    return this.formatProvider;
                }
                set {
                    if ((value != null)) {
                        this.formatProvider = value;
                    }
                }
            }
            
            public string ToStringWithCulture(object objectToConvert) {
                if ((objectToConvert == null)) {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                global::System.Type type = objectToConvert.GetType();
                global::System.Type iConvertibleType = typeof(global::System.IConvertible);
                if (iConvertibleType.IsAssignableFrom(type)) {
                    return ((global::System.IConvertible)(objectToConvert)).ToString(this.formatProvider);
                }
                global::System.Reflection.MethodInfo methInfo = type.GetMethod("ToString", new global::System.Type[] {
                            iConvertibleType});
                if ((methInfo != null)) {
                    return ((string)(methInfo.Invoke(objectToConvert, new object[] {
                                this.formatProvider})));
                }
                return objectToConvert.ToString();
            }
        }
    }
}
