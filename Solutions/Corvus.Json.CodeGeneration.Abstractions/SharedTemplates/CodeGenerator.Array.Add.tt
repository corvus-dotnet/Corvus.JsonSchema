<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Corvus.Json" #>
<#
    // This is only emitted if IsImplicitArray is true
    if(!ShouldGenerate)
    {
        throw new InvalidOperationException("CodeGenerator.Array.Add should not be emitted if IsImplicitArray is false.");
    } #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using Corvus.Json;

namespace <#= Namespace #>;

<# BeginNesting(); #>
<#= FormattedTypeDocumentation #>
public readonly partial struct <#= TypeDeclaration.DotnetTypeName #>
{
    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> Add(in JsonAny item1)
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        builder.Add(item1);
        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> Add(params JsonAny[] items)
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        builder.AddRange(items);
        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> AddRange<TArray>(in TArray items)
        where TArray : struct, IJsonArray<TArray>
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        foreach (JsonAny item in items.EnumerateArray())
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> AddRange<TItem>(IEnumerable<TItem> items)
        where TItem : struct, IJsonValue<TItem>
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        foreach (TItem item in items)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> AddRange(IEnumerable<JsonAny> items)
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        builder.AddRange(items);
        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> Insert(int index, in JsonAny item1)
    {
        return new(this.GetImmutableListWith(index, item1));
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> InsertRange<TArray>(int index, in TArray items)
        where TArray : struct, IJsonArray<TArray>
    {
        return new(this.GetImmutableListWith(index, items.EnumerateArray()));
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> InsertRange<TItem>(int index, IEnumerable<TItem> items)
        where TItem : struct, IJsonValue<TItem>
    {
        return new(this.GetImmutableListWith(index, items.Select(item => item.AsAny)));
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> InsertRange(int index, IEnumerable<JsonAny> items)
    {
        return new(this.GetImmutableListWith(index, items));
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> Replace(in JsonAny oldValue, in JsonAny newValue)
    {
        return new(this.GetImmutableListReplacing(oldValue.AsAny, newValue.AsAny));
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> SetItem(int index, in JsonAny value)
    {
        return new(this.GetImmutableListSetting(index, value.AsAny));
    }
}
<# EndNesting(); #>

<#+
    public bool ShouldGenerate
    {
        get
        {
            return IsImplicitArray || IsNotImplicitType;
        }
    }
#>
