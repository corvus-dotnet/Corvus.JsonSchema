<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Corvus.Json" #>
<#
    // This is only emitted if IsImplicitArray is true
    if(!ShouldGenerate)
    {
        throw new InvalidOperationException("CodeGenerator.Array.Add should not be emitted if IsImplicitArray is false.");
    } #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using Corvus.Json;

namespace <#= Namespace #>;

<# BeginNesting(); #>
<#= FormattedTypeDocumentation #>
public readonly partial struct <#= TypeDeclaration.DotnetTypeName #>
{
    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.Add(in JsonAny item1)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> Add(in JsonAny item1)
<#  } #>
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        builder.Add(item1);
        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.Add(params JsonAny[] items)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> Add(params JsonAny[] items)
<#  } #>
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        builder.AddRange(items);
        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
<#  if (IsTuple)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.AddRange<TArray>(in TArray items)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> AddRange<TArray>(in TArray items)
        where TArray : struct, IJsonArray<TArray>
<#  } #>
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        foreach (JsonAny item in items.EnumerateArray())
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.AddRange<TItem>(IEnumerable<TItem> items)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> AddRange<TItem>(IEnumerable<TItem> items)
        where TItem : struct, IJsonValue<TItem>
<#  } #>
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        foreach (TItem item in items)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.AddRange(IEnumerable<JsonAny> items)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> AddRange(IEnumerable<JsonAny> items)
<#  } #>
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        builder.AddRange(items);
        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.Insert(int index, in JsonAny item1)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> Insert(int index, in JsonAny item1)
<#  } #>
    {
        return new(this.GetImmutableListWith(index, item1));
    }

    /// <inheritdoc/>
<#  if (IsTuple)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.InsertRange<TArray>(int index, in TArray items)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> InsertRange<TArray>(int index, in TArray items)
        where TArray : struct, IJsonArray<TArray>
<#  } #>
    {
        return new(this.GetImmutableListWith(index, items.EnumerateArray()));
    }

    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.InsertRange<TItem>(int index, IEnumerable<TItem> items)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> InsertRange<TItem>(int index, IEnumerable<TItem> items)
        where TItem : struct, IJsonValue<TItem>
<#  } #>
    {
        return new(this.GetImmutableListWith(index, items.Select(item => item.AsAny)));
    }

    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.InsertRange(int index, IEnumerable<JsonAny> items)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> InsertRange(int index, IEnumerable<JsonAny> items)
<#  } #>
    {
        return new(this.GetImmutableListWith(index, items));
    }

    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.Replace(in JsonAny oldValue, in JsonAny newValue)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> Replace(in JsonAny oldValue, in JsonAny newValue)
<#  } #>
    {
        return new(this.GetImmutableListReplacing(oldValue.AsAny, newValue.AsAny));
    }

    /// <inheritdoc/>
<#  if (IsTuple || CanEnumerateAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.SetItem(int index, in JsonAny value)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> SetItem(int index, in JsonAny value)
<#  } #>
    {
        return new(this.GetImmutableListSetting(index, value.AsAny));
    }

<#  if (ArrayRank > 1)
    {#>
    /// <summary>
    /// Set the item at the given location in an array of dimension <#= ArrayRank #>.
    /// </summary>
<#      for(int arrayDim = 1; arrayDim <= ArrayRank; ++arrayDim)
        { #>
    /// <param name="index<#= arrayDim #>">The index for dimension <#= arrayDim #>.</param>
<#      } #>
    /// <returns>The array with the item at the given index set.</returns>
    public <#= TypeDeclaration.DotnetTypeName #> SetItem(<# for(int arrayDim = 1; arrayDim <= ArrayRank; ++arrayDim) {#><#=arrayDim > 1 ? ", " : ""#>int index<#=arrayDim#><# } #>, in <#= LeafArrayItemType #> value)
    {
        return this.SetItem(index1, this[index1].SetItem(<# for(int arrayDim = 2; arrayDim <= ArrayRank; ++arrayDim) {#><#=arrayDim > 2 ? ", " : ""#>index<#=arrayDim#><# } #>, value));
    }

<#  } #>
<#  if (CanEnumerateAsSpecificType && !IsTuple)
    { #>
    /// <summary>
    /// Add an item to the array.
    /// </summary>
    /// <param name="item1">The item to add.</param>
    /// <returns>An instance of the array with the item added.</returns>
    /// <exception cref="InvalidOperationException">The value was not an array.</exception>
    public <#= TypeDeclaration.DotnetTypeName #> Add(in <#= SingleItemsDotnetTypeName #> item1)
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        builder.Add(item1);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Add a set of items to the array.
    /// </summary>
    /// <param name="items">The items to add.</param>
    /// <returns>An instance of the array with the items added.</returns>
    /// <exception cref="InvalidOperationException">The value was not an array.</exception>
    public <#= TypeDeclaration.DotnetTypeName #> Add(params <#= SingleItemsDotnetTypeName #>[] items)
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();

        foreach (<#= SingleItemsDotnetTypeName #> item in items)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Add a set of items to the array.
    /// </summary>
    /// <param name="items">The items to add.</param>
    /// <returns>An instance of the array with the items added.</returns>
    /// <exception cref="InvalidOperationException">The value was not an array.</exception>
    public <#= TypeDeclaration.DotnetTypeName #> AddRange(IEnumerable<<#= SingleItemsDotnetTypeName #>> items)
    {
        ImmutableList<JsonAny>.Builder builder = this.GetImmutableListBuilder();
        foreach (<#= SingleItemsDotnetTypeName #> item in items)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Insert an item into the array at the given index.
    /// </summary>
    /// <param name="index">The index at which to add the item.</param>
    /// <param name="item1">The item to add.</param>
    /// <returns>An instance of the array with the item added.</returns>
    /// <exception cref="InvalidOperationException">The value was not an array.</exception>
    public <#= TypeDeclaration.DotnetTypeName #> Insert(int index, in <#= SingleItemsDotnetTypeName #> item1)
    {
        return new(this.GetImmutableListWith(index, item1));
    }

    /// <summary>
    /// Insert items into the array at the given index.
    /// </summary>
    /// <param name="index">The index at which to add the items.</param>
    /// <param name="items">The items to add.</param>
    /// <returns>An instance of the array with the items added.</returns>
    /// <exception cref="InvalidOperationException">The value was not an array.</exception>
    /// <exception cref="IndexOutOfRangeException">The index was outside the bounds of the array.</exception>
    public <#= TypeDeclaration.DotnetTypeName #> InsertRange(int index, IEnumerable<<#= SingleItemsDotnetTypeName #>> items)
    {
        return new(this.GetImmutableListWith(index, items.Select(item => item.AsAny)));
    }

    /// <summary>
    /// Replace the first instance of the given value with the new value, even if the items are identical.
    /// </summary>
    /// <param name="oldValue">The item to remove.</param>
    /// <param name="newValue">The item to insert.</param>
    /// <returns>An instance of the array with the item replaced.</returns>
    /// <exception cref="InvalidOperationException">The value was not an array.</exception>
    public <#= TypeDeclaration.DotnetTypeName #> Replace(in <#= SingleItemsDotnetTypeName #> oldValue, in <#= SingleItemsDotnetTypeName #> newValue)
    {
        return new(this.GetImmutableListReplacing(oldValue.AsAny, newValue.AsAny));
    }

    /// <summary>
    /// Set the item at the given index.
    /// </summary>
    /// <param name="index">The index at which to set the item.</param>
    /// <param name="value">The value to set.</param>
    /// <returns>An instance of the array with the item set to the given value.</returns>
    public <#= TypeDeclaration.DotnetTypeName #> SetItem(int index, in <#= SingleItemsDotnetTypeName #> value)
    {
        return new(this.GetImmutableListSetting(index, value.AsAny));
    }
<#  } #>
}
<# EndNesting(); #>

<#+
    public bool ShouldGenerate
    {
        get
        {
            return IsImplicitArray || IsNotImplicitType;
        }
    }
#>
