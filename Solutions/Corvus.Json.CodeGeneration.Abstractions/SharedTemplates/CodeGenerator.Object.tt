<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Corvus.Json" #>
<#
    // This is only emitted if IsImplicitObject is true
    if(!ShouldGenerate)
    {
        throw new InvalidOperationException("CodeGenerator.Object should not be emitted if IsImplicitObject is false.");
    } #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

<#  if (CanEnumerateObjectAsSpecificType)
    { #>
using System.Collections;
using System.Collections.Generic;
<#  } #>
using System.Collections.Immutable;
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
using System.Diagnostics.CodeAnalysis;
<#  } #>
using System.Runtime.CompilerServices;
using System.Text.Json;
using Corvus.Json;
using Corvus.Json.Internal;

namespace <#= Namespace #>;

<# BeginNesting(); #>
<#= FormattedTypeDocumentation #>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
public readonly partial struct <#= TypeDeclaration.DotnetTypeName #> : IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>, IReadOnlyDictionary<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>
<#  }
    else
    { #>
public readonly partial struct <#= TypeDeclaration.DotnetTypeName #> : IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>
<#  } #>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value">The value from which to construct the instance.</param>
    public <#= TypeDeclaration.DotnetTypeName #>(ImmutableList<JsonObjectProperty> value)
    {
        this.jsonElementBacking = default;
        this.backing = Backing.Object;
<#  if(IsImplicitString || IsNotImplicitType)
    { #>
        this.stringBacking = string.Empty;
<#  }
    if (IsImplicitBoolean && !(IsImplicitNumber || IsNotImplicitType))
    { #>
        this.boolBacking = default;
<#  }
    if(IsImplicitNumber || IsNotImplicitType)
    { #>
        this.numberBacking = default;
<#  }
    if(IsImplicitArray || IsNotImplicitType)
    { #>
        this.arrayBacking = ImmutableList<JsonAny>.Empty;
<#  } #>
        this.objectBacking = value;
    }

    /// <summary>
    /// Conversion from JsonObject.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(JsonObject value)
    {
        if (value.HasDotnetBacking && value.ValueKind == JsonValueKind.Object)
        {
            return new(value.AsPropertyBacking());
        }

        return new(value.AsJsonElement);
    }


    /// <inheritdoc/>
    public ImmutableList<JsonObjectProperty> AsPropertyBacking()
    {
        return this.GetPropertyBacking();
    }

<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    /// <inheritdoc/>
    JsonAny IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.this[in JsonPropertyName name]
<#  }
    else
    { #>
    /// <inheritdoc/>
    public JsonAny this[in JsonPropertyName name]
<#  } #>
    {
        get
        {
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
            if (this.TryGetProperty(name, out <#= SinglePropertyDotnetTypeName #> result))
            {
                return result.AsAny;
            }
<#  }
    else
    { #>
            if (this.TryGetProperty(name, out JsonAny result))
            {
                return result;
            }
<#  } #>

            throw new IndexOutOfRangeException();
        }
    }

    <#  if (CanEnumerateObjectAsSpecificType)
    { #>
    /// <summary>
    /// Get the property with the given name.
    /// </summary>
    public <#= SinglePropertyDotnetTypeName #> this[in JsonPropertyName name]
    {
        get
        {
            if (this.TryGetProperty(name, out <#= SinglePropertyDotnetTypeName #> result))
            {
                return result;
            }

            throw new IndexOutOfRangeException();
        }
    }

    /// <inheritdoc/>
    <#= SinglePropertyDotnetTypeName #> IReadOnlyDictionary<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>.this[JsonPropertyName key] => this[key];


    /// <inheritdoc/>
    IEnumerable<JsonPropertyName> IReadOnlyDictionary<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>.Keys
    {
        get
        {
            foreach(var property in this.EnumerateObject())
            {
                yield return property.Name;
            }
        }
    }

    /// <inheritdoc/>
    IEnumerable<<#= SinglePropertyDotnetTypeName #>> IReadOnlyDictionary<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>.Values 
    { 
        get
        {
            foreach (var property in this.EnumerateObject())
            {
                yield return property.Value;
            }
        }
    }

    /// <inheritdoc/>
    int IReadOnlyCollection<KeyValuePair<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>>.Count
    {
        get
        {
            if (this.HasJsonElementBacking)
            {
                int count = 0;
                foreach (var _ in this.jsonElementBacking.EnumerateObject())
                {
                    count++;
                }

                return count;
            }

            if (this.HasDotnetBacking)
            {
                return this.objectBacking.Count;
            }

            throw new InvalidOperationException();
        }
    }
<# } #>

<#  if (CanEnumerateObjectAsSpecificType)
    { #>
#if NET8_0_OR_GREATER
    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name="source">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    static <#= TypeDeclaration.DotnetTypeName #> IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.FromProperties(IDictionary<JsonPropertyName, JsonAny> source)
    {
        return new(source.Select(kvp => new JsonObjectProperty(kvp.Key, kvp.Value)).ToImmutableList());
    }
#endif
<#  }
    else
    { #>
    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name="source">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromProperties(IDictionary<JsonPropertyName, JsonAny> source)
    {
        return new(source.Select(kvp => new JsonObjectProperty(kvp.Key, kvp.Value)).ToImmutableList());
    }
<#  } #>

    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name="source">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromProperties(ImmutableList<JsonObjectProperty> source)
    {
        return new(source);
    }

<#  if (CanEnumerateObjectAsSpecificType)
    { #>
#if NET8_0_OR_GREATER
    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name="source">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    static <#= TypeDeclaration.DotnetTypeName #> IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.FromProperties(params (JsonPropertyName Name, JsonAny Value)[] source)
    {
        return new(source.Select(s => new JsonObjectProperty(s.Name, s.Value)).ToImmutableList());
    }
#endif
<#  }
    else
    { #>
    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name="source">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromProperties(params (JsonPropertyName Name, JsonAny Value)[] source)
    {
        return new(source.Select(s => new JsonObjectProperty(s.Name, s.Value)).ToImmutableList());
    }
<#  } #>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>

    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name="source">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromProperties(IDictionary<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>> source)
    {
        return new(source.Select(kvp => new JsonObjectProperty(kvp.Key, kvp.Value)).ToImmutableList());
    }

    /// <summary>
    /// Creates an instance of the type from the given dictionary of properties.
    /// </summary>
    /// <param name="source">The dictionary of properties.</param>
    /// <returns>An instance of the type initialized from the dictionary of properties.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromProperties(params (JsonPropertyName Name, <#= SinglePropertyDotnetTypeName #> Value)[] source)
    {
        return new(source.Select(s => new JsonObjectProperty(s.Name, s.Value.AsAny)).ToImmutableList());
    }
<#  } #>

<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    /// <inheritdoc/>
    JsonObjectEnumerator IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.EnumerateObject()
<#  }
    else
    { #>
    /// <inheritdoc/>
    public JsonObjectEnumerator EnumerateObject()
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return new(this.jsonElementBacking);
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return new(this.objectBacking);
        }

        throw new InvalidOperationException();
    }
<#  if (CanEnumerateObjectAsSpecificType)
    { #>

    /// <summary>
    /// Enumerate the object.
    /// </summary>
    /// <returns>An enumerator for the object.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public JsonObjectEnumerator<<#= SinglePropertyDotnetTypeName #>> EnumerateObject()
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return new(this.jsonElementBacking);
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return new(this.objectBacking);
        }

        throw new InvalidOperationException();
    }
<#  } #>

    /// <inheritdoc/>
    public bool HasProperties()
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.Count > 0;
        }

        if ((this.backing & Backing.JsonElement) != 0)
        {
            using JsonElement.ObjectEnumerator enumerator = this.jsonElementBacking.EnumerateObject();
            return enumerator.MoveNext();
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
    public bool HasProperty(in JsonPropertyName name)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return name.TryGetProperty(this.jsonElementBacking, out JsonElement _);
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.ContainsKey(name);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
    public bool HasProperty(string name)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return this.jsonElementBacking.TryGetProperty(name, out _);
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.ContainsKey(name);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
    public bool HasProperty(ReadOnlySpan<char> name)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return this.jsonElementBacking.TryGetProperty(name, out _);
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.ContainsKey(name);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
    public bool HasProperty(ReadOnlySpan<byte> utf8Name)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return this.jsonElementBacking.TryGetProperty(utf8Name, out _);
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.ContainsKey(utf8Name);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    bool IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.TryGetProperty(in JsonPropertyName name, out JsonAny value)
<#  }
    else
    { #>
    public bool TryGetProperty(in JsonPropertyName name, out JsonAny value)
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (name.TryGetProperty(this.jsonElementBacking, out JsonElement result))
            {
                value = new(result);
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.TryGetValue(name, out value);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    bool IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.TryGetProperty(string name, out JsonAny value)
<#  }
    else
    { #>
    public bool TryGetProperty(string name, out JsonAny value)
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement result))
            {
                value = new(result);
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.TryGetValue(name, out value);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    bool IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
<#  }
    else
    { #>
    public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement result))
            {
                value = new(result);
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.TryGetValue(name, out value);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    bool IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.TryGetProperty(ReadOnlySpan<byte> utf8Name, out JsonAny value)
<#  }
    else
    { #>
    public bool TryGetProperty(ReadOnlySpan<byte> utf8Name, out JsonAny value)
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(utf8Name, out JsonElement result))
            {
                value = new(result);
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.TryGetValue(utf8Name, out value);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    bool IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.TryGetProperty<TValue>(in JsonPropertyName name, out TValue value)
<#  }
    else
    { #>
    public bool TryGetProperty<TValue>(in JsonPropertyName name, out TValue value)
        where TValue : struct, IJsonValue<TValue>
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (name.TryGetProperty(this.jsonElementBacking, out JsonElement result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromJson(result);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<TValue>(result);
#endif
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromAny(result);
#else
                value = result.As<TValue>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    bool IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.TryGetProperty<TValue>(string name, out TValue value)
<#  }
    else
    { #>
    public bool TryGetProperty<TValue>(string name, out TValue value)
        where TValue : struct, IJsonValue<TValue>
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromJson(result);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<TValue>(result);
#endif
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromAny(result);
#else
                value = result.As<TValue>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    bool IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.TryGetProperty<TValue>(ReadOnlySpan<char> name, out TValue value)
<#  }
    else
    { #>
    public bool TryGetProperty<TValue>(ReadOnlySpan<char> name, out TValue value)
        where TValue : struct, IJsonValue<TValue>
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromJson(result);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<TValue>(result);
#endif
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromAny(result);
#else
                value = result.As<TValue>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    bool IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.TryGetProperty<TValue>(ReadOnlySpan<byte> utf8Name, out TValue value)
<#  }
    else
    { #>
    public bool TryGetProperty<TValue>(ReadOnlySpan<byte> utf8Name, out TValue value)
        where TValue : struct, IJsonValue<TValue>
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(utf8Name, out JsonElement result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromJson(result);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<TValue>(result);
#endif
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(utf8Name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromAny(result);
#else
                value = result.As<TValue>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    <#= TypeDeclaration.DotnetTypeName #> IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>.SetProperty<TValue>(in JsonPropertyName name, TValue value)
<#  }
    else
    { #>
    public <#= TypeDeclaration.DotnetTypeName #> SetProperty<TValue>(in JsonPropertyName name, TValue value)
        where TValue : struct, IJsonValue
<#  } #>
    {
        return new(this.GetPropertyBackingWith(name, value.AsAny));
    }
<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    
    /// <summary>
    /// Get a property.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns><c>True</c> if the property was present.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public bool TryGetProperty(in JsonPropertyName name, out <#= SinglePropertyDotnetTypeName #> value)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (name.TryGetProperty(this.jsonElementBacking, out JsonElement result))
            {
#if NET8_0_OR_GREATER
                value = <#= SinglePropertyDotnetTypeName #>.FromJson(result);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<<#= SinglePropertyDotnetTypeName #>>(result);
#endif
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = <#= SinglePropertyDotnetTypeName #>.FromAny(result);
#else
                value = result.As<<#= SinglePropertyDotnetTypeName #>>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Get a property.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns><c>True</c> if the property was present.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public bool TryGetProperty(string name, out <#= SinglePropertyDotnetTypeName #> value)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement result))
            {
#if NET8_0_OR_GREATER
                value = <#= SinglePropertyDotnetTypeName #>.FromJson(result);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<<#= SinglePropertyDotnetTypeName #>>(result);
#endif
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = <#= SinglePropertyDotnetTypeName #>.FromAny(result);
#else
                value = result.As<<#= SinglePropertyDotnetTypeName #>>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Get a property.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns><c>True</c> if the property was present.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public bool TryGetProperty(ReadOnlySpan<char> name, out <#= SinglePropertyDotnetTypeName #> value)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement result))
            {
#if NET8_0_OR_GREATER
                value = <#= SinglePropertyDotnetTypeName #>.FromJson(result);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<<#= SinglePropertyDotnetTypeName #>>(result);
#endif
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = <#= SinglePropertyDotnetTypeName #>.FromAny(result);
#else
                value = result.As<<#= SinglePropertyDotnetTypeName #>>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Get a property.
    /// </summary>
    /// <param name="utf8Name">The name of the property as a UTF8 string.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns><c>True</c> if the property was present.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public bool TryGetProperty(ReadOnlySpan<byte> utf8Name, out <#= SinglePropertyDotnetTypeName #> value)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.TryGetProperty(utf8Name, out JsonElement result))
            {
#if NET8_0_OR_GREATER
                value = <#= SinglePropertyDotnetTypeName #>.FromJson(result);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<<#= SinglePropertyDotnetTypeName #>>(result);
#endif
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(utf8Name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = <#= SinglePropertyDotnetTypeName #>.FromAny(result);
#else
                value = result.As<<#= SinglePropertyDotnetTypeName #>>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Sets the given property value.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns>The instance with the property set.</returns>
    public <#= TypeDeclaration.DotnetTypeName #> SetProperty(in JsonPropertyName name, in <#= SinglePropertyDotnetTypeName #> value)
    {
        return new(this.GetPropertyBackingWith(name, value.AsAny));
    }
<#  } #>

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> RemoveProperty(in JsonPropertyName name)
    {
        return new(this.GetPropertyBackingWithout(name));
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> RemoveProperty(string name)
    {
        return new(this.GetPropertyBackingWithout(name));
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> RemoveProperty(ReadOnlySpan<char> name)
    {
        return new(this.GetPropertyBackingWithout(name));
    }

    /// <inheritdoc/>
    public <#= TypeDeclaration.DotnetTypeName #> RemoveProperty(ReadOnlySpan<byte> utf8Name)
    {
        return new(this.GetPropertyBackingWithout(utf8Name));
    }

<#  if (CanEnumerateObjectAsSpecificType)
    { #>
    /// <inheritdoc/>
    bool IReadOnlyDictionary<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>.ContainsKey(JsonPropertyName key)
    {
        return this.HasProperty(key);
    }

    /// <inheritdoc/>
    bool IReadOnlyDictionary<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>.TryGetValue(JsonPropertyName key, [MaybeNullWhen(false)] out <#= SinglePropertyDotnetTypeName #> value)
    {
        return this.TryGetProperty(key, out value);
    }

    /// <inheritdoc/>
    IEnumerator<KeyValuePair<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>> IEnumerable<KeyValuePair<JsonPropertyName, <#= SinglePropertyDotnetTypeName #>>>.GetEnumerator()
    {
        if (this.HasJsonElementBacking)
        {
            return new ReadOnlyDictionaryJsonObjectEnumerator<<#= SinglePropertyDotnetTypeName #>>(this.jsonElementBacking);
        }

        if (this.HasDotnetBacking)
        {
            return new ReadOnlyDictionaryJsonObjectEnumerator<<#= SinglePropertyDotnetTypeName #>>(this.objectBacking);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
    IEnumerator IEnumerable.GetEnumerator()
    {
        return this.EnumerateObject();
    }

<#  } #>
    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object.
    /// </summary>
    /// <returns>An immutable list of <see cref="JsonAny"/> built from the array.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    private ImmutableList<JsonObjectProperty> GetPropertyBacking()
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking;
        }

        return PropertyBackingBuilders.GetPropertyBackingBuilder(this.jsonElementBacking).ToImmutable();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
    /// </summary>
    /// <returns>An immutable dictionary builder of <see cref="JsonPropertyName"/> to <see cref="JsonAny"/>, built from the existing object, without the given property.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    private ImmutableList<JsonObjectProperty> GetPropertyBackingWithout(in JsonPropertyName name)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.Remove(name);
        }

        return PropertyBackingBuilders.GetPropertyBackingBuilderWithout(this.jsonElementBacking, name).ToImmutable();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
    /// </summary>
    /// <returns>An immutable dictionary builder of <see cref="JsonPropertyName"/> to <see cref="JsonAny"/>, built from the existing object, without the given property.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    private ImmutableList<JsonObjectProperty> GetPropertyBackingWithout(ReadOnlySpan<char> name)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.Remove(name);
        }

        return PropertyBackingBuilders.GetPropertyBackingBuilderWithout(this.jsonElementBacking, name).ToImmutable();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
    /// </summary>
    /// <returns>An immutable dictionary builder of <see cref="JsonPropertyName"/> to <see cref="JsonAny"/>, built from the existing object, without the given property.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    private ImmutableList<JsonObjectProperty> GetPropertyBackingWithout(ReadOnlySpan<byte> name)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.Remove(name);
        }

        return PropertyBackingBuilders.GetPropertyBackingBuilderWithout(this.jsonElementBacking, name).ToImmutable();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
    /// </summary>
    /// <returns>An immutable dictionary builder of <see cref="JsonPropertyName"/> to <see cref="JsonAny"/>, built from the existing object, without the given property.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    private ImmutableList<JsonObjectProperty> GetPropertyBackingWithout(string name)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.Remove(name);
        }

        return PropertyBackingBuilders.GetPropertyBackingBuilderWithout(this.jsonElementBacking, name).ToImmutable();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
    /// </summary>
    /// <returns>An immutable dictionary builder of <see cref="JsonPropertyName"/> to <see cref="JsonAny"/>, built from the existing object, without the given property.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    private ImmutableList<JsonObjectProperty> GetPropertyBackingWith(in JsonPropertyName name, in JsonAny value)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.SetItem(name, value);
        }

        ImmutableList<JsonObjectProperty>.Builder result = PropertyBackingBuilders.GetPropertyBackingBuilderReplacing(this.jsonElementBacking, name, value);
        return result.ToImmutable();
    }
}
<# EndNesting(); #>
<#+
    public bool ShouldGenerate
    {
        get
        {
            return IsImplicitObject || IsNotImplicitType;
        }
    }
#>