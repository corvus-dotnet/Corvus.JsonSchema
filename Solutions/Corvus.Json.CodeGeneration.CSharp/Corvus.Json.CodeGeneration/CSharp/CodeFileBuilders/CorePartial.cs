// <copyright file="CorePartial.cs" company="Endjin Limited">
// Copyright (c) Endjin Limited. All rights reserved.
// </copyright>

namespace Corvus.Json.CodeGeneration.CSharp;

/// <summary>
/// Provides the core file for a type declaration.
/// </summary>
public sealed class CorePartial : ICodeFileBuilder
{
    private CorePartial()
    {
    }

    /// <summary>
    /// Gets a singleton instance of the <see cref="CorePartial"/> builder.
    /// </summary>
    public static CorePartial Instance { get; } = new();

    /// <inheritdoc/>
    public CodeGenerator EmitFile(CodeGenerator generator, TypeDeclaration typeDeclaration)
    {
        FrameworkType addExplicitUsings = typeDeclaration.AddExplicitUsings() ? FrameworkType.All : FrameworkType.NotEmitted;

        return generator
            .BeginFile(typeDeclaration, string.Empty)
                .AppendAutoGeneratedHeader()
                .AppendLine()
                .AppendLine("#nullable enable")
                .AppendLine()
                .AppendUsings(
                    new("global::System", addExplicitUsings),
                    new("global::System.Collections.Generic", addExplicitUsings),
                    new("global::System.IO", addExplicitUsings),
                    new("global::System.Linq", addExplicitUsings),
                    new("global::System.Net.Http", addExplicitUsings),
                    new("global::System.Threading", addExplicitUsings),
                    new("global::System.Threading.Tasks", addExplicitUsings),
                    "gobal::System.Buffers",
                    RequiresImmutableCollections(typeDeclaration) ? "gobal::System.Collections.Immutable" : ConditionalCodeSpecification.DoNotEmit,
                    "gobal::System.Runtime.CompilerServices",
                    "gobal::System.Text.Json",
                    new("Corvus.Json", EmitIfNotCorvusJsonExtendedType(typeDeclaration)),
                    "Corvus.Json.Internal")
                .AppendLine()
                .BeginTypeDeclarationNesting(typeDeclaration)
                    .AppendDocumentation(typeDeclaration)
                    .AppendJsonConverterAttribute(typeDeclaration)
                    .BeginReadonlyPartialStructDeclaration(
                        typeDeclaration.DotnetAccessibility(),
                        typeDeclaration.DotnetTypeName(),
                        interfaces: [
                            JsonAnyType(typeDeclaration)
                            ])
                        .PushValidationClassNameAndScope()
                        .AppendBackingFields(typeDeclaration.ImpliedCoreTypesOrAny())
                        .AppendPublicDefaultConstructor(typeDeclaration)
                        .AppendPublicJsonElementConstructor(typeDeclaration)
                        .AppendPublicValueConstructor(typeDeclaration, "ImmutableList<JsonAny>", CoreTypes.Array)
                        .AppendPublicValueConstructor(typeDeclaration, "bool", CoreTypes.Boolean)
                        .AppendPublicValueConstructor(typeDeclaration, "BinaryJsonNumber", CoreTypes.Number | CoreTypes.Integer)
                        .AppendPublicValueConstructor(typeDeclaration, "ImmutableList<JsonObjectProperty>", CoreTypes.Object)
                        .AppendPublicValueConstructor(typeDeclaration, "string", CoreTypes.String)
                        .AppendSchemaLocationStaticProperty(typeDeclaration)
                        .AppendNullInstanceStaticProperty(typeDeclaration)
                        .AppendUndefinedInstanceStaticProperty(typeDeclaration)
                        .AppendDefaultInstanceStaticProperty(typeDeclaration)
                        .AppendAsAnyProperty(typeDeclaration)
                        .AppendAsJsonElementProperty(typeDeclaration)
                        .AppendAsStringProperty(typeDeclaration)
                        .AppendAsBooleanProperty(typeDeclaration)
                        .AppendAsNumberProperty(typeDeclaration)
                        .AppendAsObjectProperty(typeDeclaration)
                        .AppendAsArrayProperty(typeDeclaration)
                        .AppendAsProperties(typeDeclaration)
                        .AppendHasJsonElementBackingProperty()
                        .AppendHasDotnetBackingProperty()
                        .AppendValueKindProperty(typeDeclaration)
                        .AppendImplicitConversionFromJsonValueTypeUsingAs(typeDeclaration, "JsonAny")
                        .AppendImplicitConversionToJsonAny(typeDeclaration)
                        .AppendConversionToCompositionTypes(typeDeclaration)
                        .AppendBinaryOperator(typeDeclaration, "bool", "==", "return left.Equals(right);", "<c>True</c> if the values are equal.")
                        .AppendBinaryOperator(typeDeclaration, "bool", "!=", "return !left.Equals(right);", "<c>True</c> if the values are not equal.")
                        .AppendFromJsonFactoryMethod(typeDeclaration)
                        .AppendCreateFromSerializedInstanceFactoryMethod(typeDeclaration)
                        .AppendFromAnyFactoryMethod(typeDeclaration)
                        .AppendFromTValueFactoryMethod(typeDeclaration, CoreTypes.Boolean, "Boolean")
                        .AppendFromTValueFactoryMethod(typeDeclaration, CoreTypes.String, "String")
                        .AppendFromTValueFactoryMethod(typeDeclaration, CoreTypes.Number | CoreTypes.Integer, "Number")
                        .AppendFromTValueFactoryMethod(typeDeclaration, CoreTypes.Object, "Object")
                        .AppendFromTValueFactoryMethod(typeDeclaration, CoreTypes.Array, "Array")
                        .AppendParseMethod(typeDeclaration, "string")
                        .AppendParseMethod(typeDeclaration, "Stream")
                        .AppendParseMethod(typeDeclaration, "ReadOnlyMemory<byte>")
                        .AppendParseMethod(typeDeclaration, "ReadOnlyMemory<char>")
                        .AppendParseMethod(typeDeclaration, "ReadOnlySequence<byte>")
                        .AppendParseValueMethod(typeDeclaration, "string")
                        .AppendParseValueMethod(typeDeclaration, "ReadOnlySpan<char>")
                        .AppendParseValueMethod(typeDeclaration, "ReadOnlySpan<byte>")
                        .AppendParseValueMethod(typeDeclaration, "Utf8JsonReader", byRef: true)
                        .AppendAsTMethod(typeDeclaration)
                        .AppendEqualsOverloads(typeDeclaration)
                        .AppendWriteToMethod(typeDeclaration)
                        .AppendGetHashCodeAndToStringMethods(typeDeclaration)
                        .AppendValidateMethodForNoValidation(typeDeclaration)
                        .AppendMatchMethods(typeDeclaration)
                        .AppendTryGetMethods(typeDeclaration)
                        .PopValidationClassNameAndScope()
                    .EndClassOrStructDeclaration()
                .EndTypeDeclarationNesting(typeDeclaration)
                .EndNamespace()
            .EndFile(typeDeclaration, string.Empty);

        static FrameworkType EmitIfNotCorvusJsonExtendedType(TypeDeclaration typeDeclaration)
        {
            return typeDeclaration.IsCorvusJsonExtendedType()
                 ? FrameworkType.NotEmitted
                 : FrameworkType.All;
        }

        static bool RequiresImmutableCollections(TypeDeclaration typeDeclaration)
        {
            return (typeDeclaration.ImpliedCoreTypesOrAny() & (CoreTypes.Array | CoreTypes.Object)) != 0;
        }

        static ConditionalCodeSpecification JsonAnyType(TypeDeclaration typeDeclaration)
        {
            bool isNull = (typeDeclaration.ImpliedCoreTypes() & CoreTypes.Null) != 0 && typeDeclaration.ImpliedCoreTypes().CountTypes() == 1;
            bool isAny = typeDeclaration.LocallyImpliedCoreTypes().CountTypes() == 0;
            return new(
                g => g.GenericTypeOf("IJsonValue", typeDeclaration),
                isNull || isAny ? FrameworkType.All : FrameworkType.NotEmitted);
        }
    }
}