// <copyright file="NumberPartial.cs" company="Endjin Limited">
// Copyright (c) Endjin Limited. All rights reserved.
// </copyright>

using System.Text.Json;

namespace Corvus.Json.CodeGeneration.CSharp;

/// <summary>
/// Provides the Number file for a type declaration.
/// </summary>
public sealed class NumberPartial : ICodeFileBuilder
{
    private NumberPartial()
    {
    }

    /// <summary>
    /// Gets a singleton instance of the <see cref="NumberPartial"/> builder.
    /// </summary>
    public static NumberPartial Instance { get; } = new();

    /// <inheritdoc/>
    public CodeGenerator EmitFile(CodeGenerator generator, TypeDeclaration typeDeclaration)
    {
        if ((typeDeclaration.ImpliedCoreTypes() & (CoreTypes.Number | CoreTypes.Integer)) != 0)
        {
            generator
                .BeginFile(typeDeclaration, "Number")
                    .AppendAutoGeneratedHeader()
                    .AppendLine()
                    .AppendLine("#nullable enable")
                    .AppendLine()
                    .AppendUsings(
                        "System.Diagnostics.CodeAnalysis",
                        "System.Text.Json",
                        "Corvus.Json",
                        "Corvus.Json.Internal")
                    .AppendLine()
                    .BeginNamespace(typeDeclaration.DotnetNamespace())
                    .AppendLine()
                    .BeginTypeDeclarationNesting(typeDeclaration)
                        .AppendDocumentation(typeDeclaration)
                        .BeginPublicReadonlyPartialStructDeclaration(
                            typeDeclaration.DotnetTypeName(),
                            interfaces:
                                [
                                    new(g => g.GenericTypeOf("IJsonNumber", typeDeclaration)),
                                    new(g => g.GenericTypeOf("IAdditionOperators", typeDeclaration, typeDeclaration, typeDeclaration), FrameworkType.Net80OrGreater),
                                    new(g => g.GenericTypeOf("ISubtractionOperators", typeDeclaration, typeDeclaration, typeDeclaration), FrameworkType.Net80OrGreater),
                                    new(g => g.GenericTypeOf("IMultiplyOperators", typeDeclaration, typeDeclaration, typeDeclaration), FrameworkType.Net80OrGreater),
                                    new(g => g.GenericTypeOf("IDivisionOperators", typeDeclaration, typeDeclaration, typeDeclaration), FrameworkType.Net80OrGreater),
                                    new(g => g.GenericTypeOf("IIncrementOperators", typeDeclaration), FrameworkType.Net80OrGreater),
                                    new(g => g.GenericTypeOf("IDecrementOperators", typeDeclaration), FrameworkType.Net80OrGreater),
                                ])
                            //// We do not need to speciy CoreTypes.Integer as this simply determines the backing field to set.
                            .AppendPublicValueConstructor(typeDeclaration, "BinaryJsonNumber", CoreTypes.Number)
                            .AppendPublicNumericConstructor(typeDeclaration)
                            .AppendImplicitConversionFromJsonValueTypeUsingConstructor(typeDeclaration, "JsonNumber", JsonValueKind.Number, "(BinaryJsonNumber)value")
                            .AppendImplicitConversionToJsonValueType(typeDeclaration, "JsonNumber", CoreTypes.Number, "value.AsNumber")
                            .AppendImplicitConversionToJsonValueType(typeDeclaration, "JsonInteger", CoreTypes.Integer, "value.As<JsonInteger>()")
                            .AppendConversionsForNumber(typeDeclaration, "byte", "SafeGetByte")
                            .AppendConversionsForNumber(typeDeclaration, "decimal", "SafeGetDecimal")
                            .AppendConversionsForNumber(typeDeclaration, "double", "SafeGetDouble")
                            .AppendConversionsForNumber(typeDeclaration, "short", "SafeGetInt16")
                            .AppendConversionsForNumber(typeDeclaration, "int", "SafeGetInt32")
                            .AppendConversionsForNumber(typeDeclaration, "long", "SafeGetInt64")
                            .AppendConversionsForNumber(typeDeclaration, "Int128", "SafeGetInt128", FrameworkType.Net80OrGreater)
                            .AppendConversionsForNumber(typeDeclaration, "sbyte", "SafeGetSByte")
                            .AppendConversionsForNumber(typeDeclaration, "Half", "SafeGetHalf", FrameworkType.Net80OrGreater)
                            .AppendConversionsForNumber(typeDeclaration, "float", "SafeGetSingle")
                            .AppendConversionsForNumber(typeDeclaration, "ushort", "SafeGetUInt16")
                            .AppendConversionsForNumber(typeDeclaration, "uint", "SafeGetUInt32")
                            .AppendConversionsForNumber(typeDeclaration, "ulong", "SafeGetUInt64")
                            .AppendConversionsForNumber(typeDeclaration, "UInt128", "SafeGetUInt128", FrameworkType.Net80OrGreater)
                        .EndClassOrStructDeclaration()
                    .EndTypeDeclarationNesting(typeDeclaration)
                    .EndNamespace()
                .EndFile(typeDeclaration, "Number");
        }

        return generator;
    }
}