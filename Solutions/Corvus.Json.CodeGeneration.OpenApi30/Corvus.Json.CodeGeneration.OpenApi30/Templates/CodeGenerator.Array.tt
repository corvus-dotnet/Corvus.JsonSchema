<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Corvus.Json" #>
<#
    // This is only emitted if IsImplicitArray is true
    if(!ShouldGenerate)
    {
        throw new InvalidOperationException("CodeGenerator.Array should not be emitted if IsImplicitArray is false.");
    } #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System.Buffers;
using System.Collections;
using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Text.Json;
using Corvus.Json;
using Corvus.Json.Internal;

namespace <#= Namespace #>;

<# BeginNesting(); #>
<#= FormattedTypeDocumentation #>
<#  if(CanEnumerateAsSpecificType)
    { #>
#if NET8_0_OR_GREATER
[CollectionBuilder(typeof(<#= TypeDeclaration.DotnetTypeName #>), "Create")]
public readonly partial struct <#= TypeDeclaration.DotnetTypeName #> : IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>, IReadOnlyCollection<<#= SingleItemsDotnetTypeName #>>
#else
public readonly partial struct <#= TypeDeclaration.DotnetTypeName #> : IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>, IReadOnlyCollection<<#= SingleItemsDotnetTypeName #>>
#endif
<#  }
    else
    { #>
#if NET8_0_OR_GREATER
[CollectionBuilder(typeof(<#= TypeDeclaration.DotnetTypeName #>), "Create")]
public readonly partial struct <#= TypeDeclaration.DotnetTypeName #> : IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>, IReadOnlyCollection<JsonAny>
#else
public readonly partial struct <#= TypeDeclaration.DotnetTypeName #> : IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>, IReadOnlyCollection<JsonAny>
#endif
<#  } #>
{
    /// <summary>
    /// Gets an empty array.
    /// </summary>
    public static readonly <#= TypeDeclaration.DotnetTypeName #> EmptyArray = From(ImmutableList<JsonAny>.Empty);

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value">The value from which to construct the instance.</param>
    public <#= TypeDeclaration.DotnetTypeName #>(ImmutableList<JsonAny> value)
    {
        this.jsonElementBacking = default;
        this.backing = Backing.Array;
<#  if(IsImplicitString || IsNotImplicitType)
    { #>
        this.stringBacking = string.Empty;
<#  }
    if (IsImplicitBoolean && !(IsImplicitNumber || IsNotImplicitType))
    { #>
        this.boolBacking = default;
<#  }
    if(IsImplicitNumber || IsNotImplicitType)
    { #>
        this.numberBacking = default;
<#  } #>
        this.arrayBacking = value;
<#  if(IsImplicitObject || IsNotImplicitType)
    { #>
        this.objectBacking = ImmutableList<JsonObjectProperty>.Empty;
<#  } #>
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value">The value from which to construct the instance.</param>
    public <#= TypeDeclaration.DotnetTypeName #>(IEnumerable<JsonAny> value)
    {
        this.jsonElementBacking = default;
        this.backing = Backing.Array;
<#  if(IsImplicitString || IsNotImplicitType)
    { #>
        this.stringBacking = string.Empty;
<#  }
    if(IsImplicitBoolean && !(IsImplicitNumber || IsNotImplicitType))
    { #>
        this.boolBacking = default;
<#  }
    if(IsImplicitNumber || IsNotImplicitType)
    { #>
        this.numberBacking = default;
<#  } #>
        this.arrayBacking = value.ToImmutableList();
<#  if(IsImplicitObject || IsNotImplicitType)
    { #>
        this.objectBacking = ImmutableList<JsonObjectProperty>.Empty;
<#  } #>
    }

<#  if (CanEnumerateAsSpecificType && IsFixedSizeArray && IsNumericArray)
    { #>
    /// <summary>
    /// Gets the rank of the array.
    /// </summary>
    public static int Rank => <#= ArrayRank #>;

    /// <summary>
    /// Gets the dimension of the array in this rank.
    /// </summary>
    public static int Dimension => <#= ArrayDimension #>;

    /// <summary>
    /// Gets the total size of a buffer required to represent the array.
    /// </summary>
    /// <remarks>
    /// This calculates the array based on the dimension of each rank. It is generally
    /// used to determine the size of the buffer required by
    /// <see cref="TryGetNumericValues(Span{double}, out int)"/>.
    /// </remarks>
    public static int ValueBufferSize => <#= ArrayValueBufferSize #>;
<#  } #>

<#  if (!CanEnumerateAsSpecificType)
    { #>
    /// <inheritdoc/>
    public JsonAny this[int index]
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new JsonAny(this.jsonElementBacking[index]);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking[index];
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }
    }
<#  }
    else
    { #>
    /// <inheritdoc/>
    JsonAny IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.this[int index]
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new JsonAny(this.jsonElementBacking[index]);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking[index];
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }
    }

    /// <summary>
    /// Gets the item at the given index.
    /// </summary>
    /// <param name="index">The index at which to retrieve the item.</param>
    /// <returns>The item at the given index.</returns>
    /// <exception cref="IndexOutOfRangeException">The index was outside the bounds of the array.</exception>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    public <#= SingleItemsDotnetTypeName #> this[int index]
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new <#= SingleItemsDotnetTypeName #>(this.jsonElementBacking[index]);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking[index].As<<#= SingleItemsDotnetTypeName #>>();
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }
    }
<#  } #>

    /// <summary>
    /// Conversion from immutable list.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator ImmutableList<JsonAny>(<#= TypeDeclaration.DotnetTypeName #> value)
    {
        return value.GetImmutableList();
    }

    /// <summary>s
    /// Conversion to immutable list.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(ImmutableList<JsonAny> value)
    {
        return new(value);
    }

    /// <summary>
    /// Conversion from JsonArray.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(JsonArray value)
    {
        if (value.HasDotnetBacking && value.ValueKind == JsonValueKind.Array)
        {
            return new(value.AsImmutableList());
        }

        return new(value.AsJsonElement);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="items">The list of items from which to construct the array.</param>
    /// <returns>An instance of the array constructed from the list.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= TypeDeclaration.DotnetTypeName #> From(ImmutableList<JsonAny> items)
    {
        return new(items);
    }

<#  if (!CanEnumerateAsSpecificType)
    { #>
    /// <summary>
    /// Create an array from the span of items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The array containing the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> Create(ReadOnlySpan<JsonAny> items)
    {
        return new([..items]);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value">The value from which to construct the instance.</param>
    /// <returns>A JsonAny instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems(params JsonAny[] value)
    {
        return new(value.ToImmutableList());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <typeparam name="TItem">The type of the items in the list.</typeparam>
    /// <param name="value">The value from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems<TItem>(params TItem[] value)
        where TItem : struct, IJsonValue<TItem>
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (TItem item in value)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <typeparam name="TItem1">The type of the items in the list.</typeparam>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems<TItem1>(in TItem1 value1)
        where TItem1 : struct, IJsonValue<TItem1>
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1.AsAny);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <typeparam name="TItem1">The type of the first item in the list.</typeparam>
    /// <typeparam name="TItem2">The type of the second item in the list.</typeparam>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <param name="value2">The second value from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems<TItem1, TItem2>(in TItem1 value1, in TItem2 value2)
        where TItem1 : struct, IJsonValue<TItem1>
        where TItem2 : struct, IJsonValue<TItem2>
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1.AsAny);
        builder.Add(value2.AsAny);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <typeparam name="TItem1">The type of the first item in the list.</typeparam>
    /// <typeparam name="TItem2">The type of the second item in the list.</typeparam>
    /// <typeparam name="TItem3">The type of the third item in the list.</typeparam>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <param name="value2">The second value from which to construct the instance.</param>
    /// <param name="value3">The thirdvalue from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems<TItem1, TItem2, TItem3>(in TItem1 value1, in TItem2 value2, in TItem3 value3)
        where TItem1 : struct, IJsonValue<TItem1>
        where TItem2 : struct, IJsonValue<TItem2>
        where TItem3 : struct, IJsonValue<TItem3>
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1.AsAny);
        builder.Add(value2.AsAny);
        builder.Add(value3.AsAny);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <typeparam name="T">The type of the <paramref name="items"/> from which to create the array.</typeparam>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    /// <remarks>
    /// This will serialize the items to create the underlying JsonArray. Note the
    /// other overloads which avoid this serialization step.
    /// </remarks>
    public static <#= TypeDeclaration.DotnetTypeName #> From<T>(IEnumerable<T> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (T item in items)
        {
            var abw = new ArrayBufferWriter<byte>();
            using var writer = new Utf8JsonWriter(abw);
            JsonSerializer.Serialize(writer, item);
            writer.Flush();
            builder.Add(JsonAny.Parse(abw.WrittenMemory));
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name = "items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    /// <remarks>
    /// This will serialize the items to create the underlying JsonArray. Note the
    /// other overloads which avoid this serialization step.
    /// </remarks>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<JsonAny> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (JsonAny item in items)
        {
            builder.Add(item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name = "items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    /// <remarks>
    /// This will serialize the items to create the underlying JsonArray. Note the
    /// other overloads which avoid this serialization step.
    /// </remarks>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange<T>(IEnumerable<T> items)
        where T : struct, IJsonValue<T>
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (T item in items)
        {
            builder.Add(item.AsAny);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<string> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (string item in items)
        {
            builder.Add((JsonAny)item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<double> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (double item in items)
        {
            builder.Add((JsonAny)item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<float> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (float item in items)
        {
            builder.Add((JsonAny)item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<int> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (int item in items)
        {
            builder.Add((JsonAny)item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<long> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (long item in items)
        {
            builder.Add((JsonAny)item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<bool> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (bool item in items)
        {
            builder.Add((JsonAny)item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems(in JsonAny value1)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <param name="value2">The second value from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems(in JsonAny value1, in JsonAny value2)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1);
        builder.Add(value2);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <param name="value2">The second value from which to construct the instance.</param>
    /// <param name="value3">The thirdvalue from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems(in JsonAny value1, in JsonAny value2, in JsonAny value3)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1);
        builder.Add(value2);
        builder.Add(value3);
        return new(builder.ToImmutable());
    }
<#  }
    else if (!(IsFixedSizeArray && IsNumericArray))
    {#>
    /// <summary>
    /// Create an array from the span of items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The array containing the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> Create(ReadOnlySpan<<#= SingleItemsDotnetTypeName #>> items)
    {
        return new([..items]);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems(in <#= SingleItemsDotnetTypeName #> value1)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1.AsAny);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <param name="value2">The second value from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems(in <#= SingleItemsDotnetTypeName #> value1, in <#= SingleItemsDotnetTypeName #> value2)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1.AsAny);
        builder.Add(value2.AsAny);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value1">The first value from which to construct the instance.</param>
    /// <param name="value2">The second value from which to construct the instance.</param>
    /// <param name="value3">The thirdvalue from which to construct the instance.</param>
    /// <returns>A <#= TypeDeclaration.DotnetTypeName #> instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems(in <#= SingleItemsDotnetTypeName #> value1, in <#= SingleItemsDotnetTypeName #> value2, in <#= SingleItemsDotnetTypeName #> value3)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        builder.Add(value1.AsAny);
        builder.Add(value2.AsAny);
        builder.Add(value3.AsAny);
        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value">The value from which to construct the instance.</param>
    /// <returns>A JsonAny instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromItems(params <#= SingleItemsDotnetTypeName #>[] value)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (<#= SingleItemsDotnetTypeName #> item in value)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
    /// </summary>
    /// <param name="value">The value from which to construct the instance.</param>
    /// <returns>A JsonAny instantiated from the given items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<<#= SingleItemsDotnetTypeName #>> value)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (<#= SingleItemsDotnetTypeName #> item in value)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <typeparam name="T">The type of the <paramref name="items"/> from which to create the array.</typeparam>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    /// <remarks>
    /// This will serialize the items to create the underlying JsonArray. Note the
    /// other overloads which avoid this serialization step.
    /// </remarks>
    public static <#= TypeDeclaration.DotnetTypeName #> From<T>(IEnumerable<T> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (T item in items)
        {
            var abw = new ArrayBufferWriter<byte>();
            using var writer = new Utf8JsonWriter(abw);
            JsonSerializer.Serialize(writer, item);
            writer.Flush();
            builder.Add(JsonAny.Parse(abw.WrittenMemory));
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name = "items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange(IEnumerable<JsonAny> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (JsonAny item in items)
        {
            builder.Add(item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name = "items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> FromRange<T>(IEnumerable<T> items)
        where T : struct, IJsonValue<T>
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (T item in items)
        {
            builder.Add(item.AsAny);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }
<#  }
    else
    { 
        if (IsFixedSizeArray && IsNumericArray)
        {#>
    /// <summary>
    /// Create an array from the span of items.
    /// </summary>
    /// <param name="items">The items from which to create the array.</param>
    /// <returns>The array containing the items.</returns>
    public static <#= TypeDeclaration.DotnetTypeName #> Create(ReadOnlySpan<<#= SingleItemsDotnetTypeName #>> items)
    {
        return new([..items]);
    }

<#      } #>
#if NET8_0_OR_GREATER
    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name = "items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    /// <remarks>
    /// This will serialize the items to create the underlying JsonArray. Note the
    /// other overloads which avoid this serialization step.
    /// </remarks>
    static <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.FromRange(IEnumerable<JsonAny> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (JsonAny item in items)
        {
            builder.Add(item);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name = "items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    /// <remarks>
    /// This will serialize the items to create the underlying JsonArray. Note the
    /// other overloads which avoid this serialization step.
    /// </remarks>
    static <#= TypeDeclaration.DotnetTypeName #> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.FromRange<T>(IEnumerable<T> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (T item in items)
        {
            builder.Add(item.AsAny);
        }

        return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
    }
#endif
<#  }

    if (CanEnumerateAsSpecificType && IsFixedSizeArray && IsNumericArray)
    { 
        if (ArrayRank > 1)
        {#>

    /// <summary>
    /// Creates an instance of the array of rank <#= ArrayRank #>, dimension <#= ArrayDimension #>, from the given values.
    /// </summary>
    /// <param name="values">The numeric values from which to create the array.</param>
    /// <returns>An instance of the array populated from the given values.</returns>
    /// <remarks>
    /// The values should be of length <#= ArrayValueBufferSize #>.
    /// </remarks>
    public static <#= TypeDeclaration.DotnetTypeName #> FromValues(ReadOnlySpan<<#= PreferredNumericType #>> values)
    {
        if (values.Length != <#= ArrayValueBufferSize #>)
        {
            throw new ArgumentException(nameof(values));
        }

        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();

        int index = 0;
        while (index < values.Length)
        {
            <#= SingleItemsDotnetTypeName #> child = <#= SingleItemsDotnetTypeName #>.FromValues(values.Slice(index, <#= ChildArrayValueBufferSize #>));
            builder.Add(child);
            index += <#= ChildArrayValueBufferSize #>;
        }

        return new(builder.ToImmutable());
    }
<#      }
        else
        { #>

    /// <summary>
    /// Creates an instance of the array of rank 1, dimension 2 from the given values.
    /// </summary>
    /// <param name="values">The numeric values from which to create the array.</param>
    /// <returns>An instance of the array populated from the given values.</returns>
    /// <remarks>
    /// The values should be of length <#= ArrayValueBufferSize #>.
    /// </remarks>
    public static <#= TypeDeclaration.DotnetTypeName #> FromValues(ReadOnlySpan<<#= PreferredNumericType #>> values)
    {
        if (values.Length != <#= ArrayValueBufferSize #>)
        {
            throw new ArgumentException(nameof(values));
        }
        
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();

        int index = 0;
        while (index < Dimension)
        {
            builder.Add((JsonAny)values[index++]);
        }

        return new(builder.ToImmutable());
    }
<#      }
    }

    if (CanEnumerateAsSpecificType)
    { #>
    /// <inheritdoc />
    IEnumerator<<#= SingleItemsDotnetTypeName #>> IEnumerable<<#= SingleItemsDotnetTypeName #>>.GetEnumerator()
    {
        return EnumerateArray();
    }

    /// <inheritdoc />
    IEnumerator IEnumerable.GetEnumerator()
    {
        return EnumerateArray();
    }

    /// <inheritdoc />
    int IReadOnlyCollection<<#= SingleItemsDotnetTypeName #>>.Count => this.GetArrayLength();

<#  }
    else
    { #>
    /// <inheritdoc />
    IEnumerator<JsonAny> IEnumerable<JsonAny>.GetEnumerator()
    {
        return EnumerateArray();
    }

    /// <inheritdoc />
    IEnumerator IEnumerable.GetEnumerator()
    {
        return EnumerateArray();
    }

    /// <inheritdoc />
    int IReadOnlyCollection<JsonAny>.Count => this.GetArrayLength();

<#  }#>
    /// <inheritdoc/>
    public ImmutableList<JsonAny> AsImmutableList()
    {
        return this.GetImmutableList();
    }

    /// <inheritdoc/>
    public ImmutableList<JsonAny>.Builder AsImmutableListBuilder()
    {
        return this.GetImmutableListBuilder();
    }

    /// <inheritdoc/>
    public int GetArrayLength()
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return this.jsonElementBacking.GetArrayLength();
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return this.arrayBacking.Count;
        }

        return 0;
    }

<#  if (CanEnumerateAsSpecificType)
    { #>
    /// <inheritdoc/>
    public JsonArrayEnumerator<<#= SingleItemsDotnetTypeName #>> EnumerateArray()
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return new JsonArrayEnumerator<<#= SingleItemsDotnetTypeName #>>(this.jsonElementBacking);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return new JsonArrayEnumerator<<#= SingleItemsDotnetTypeName #>>(this.arrayBacking);
        }

        throw new InvalidOperationException();
    }
<#  } #>

    /// <inheritdoc/>
<#  if (CanEnumerateAsSpecificType)
    { #>
    JsonArrayEnumerator IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.EnumerateArray()
<#  }
    else
    { #>
    public JsonArrayEnumerator EnumerateArray()
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return new JsonArrayEnumerator(this.jsonElementBacking);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return new JsonArrayEnumerator(this.arrayBacking);
        }

        throw new InvalidOperationException();
    }

<#  if (CanEnumerateAsSpecificType && IsFixedSizeArray && IsNumericArray)
    { #>
    /// <summary>
    /// Fills the span with the numeric values in the array.
    /// </summary>
    /// <param name="items">The <see cref="Span{<#= PreferredNumericType #>}"/> to fill with the values in the array.</param>
    /// <param name="written">The number of values written.</param>
    /// <returns><see langword="true"/> if the array was written successfully, otherwise <see langword="false" />.</returns>
    /// <remarks>
    /// You can determine the size of the array to fill by interrogating
    /// <see cref="TotalSize"/>
    /// </remarks>
    public bool TryGetNumericValues(Span<<#= PreferredNumericType #>> items, out int written)
    {
        int index = 0;

        if ((this.backing & Backing.Array) != 0)
        {
            if (items.Length < <#= TypeDeclaration.DotnetTypeName #>.ValueBufferSize)
            {
                written = 0;
                return false;
            }

            foreach (var item in this.arrayBacking)
            {
<#      if (ArrayRank == 1)
        { #>
                if (item.ValueKind != JsonValueKind.Number)
                {
                    written = 0;
                    return false;
                }

                items[index++] = (<#= PreferredNumericType #>)item.AsNumber;
<#      }
        else
        { #>
                <#= SingleItemsDotnetTypeName #> child = item.As<<#= SingleItemsDotnetTypeName #>>();

                if (!child.TryGetNumericValues(items[index..], out int writtenChildren))
                {
                    written = 0;
                    return false;
                }

                index += writtenChildren;

<#      } #>
            }

            written = index;
            return true;
        }

        if (this.jsonElementBacking.ValueKind != JsonValueKind.Array)
        {
            written = 0;
            return false;
        }

        if (items.Length < <#= TypeDeclaration.DotnetTypeName #>.ValueBufferSize)
        {
            written = 0;
            return false;
        }

        foreach (JsonElement jsonElement in this.jsonElementBacking.EnumerateArray())
        {
<#      if (ArrayRank == 1)
        { 
            string preferredNumericType = PreferredNumericType; 
#>
            if (jsonElement.ValueKind != JsonValueKind.Number ||
<#          if (preferredNumericType == "double")
            { #>
                !jsonElement.TryGetDouble(out double value))
<#          }
            else if (preferredNumericType == "float")
            { #>
                !jsonElement.TryGetSingle(out float value))
<#          }
            else if (preferredNumericType == "decimal")
            { #>
                !jsonElement.TryGetDecimal(out decimal value))
<#          }
            else if (preferredNumericType == "Half")
            { #>
                !jsonElement.TryGetHalf(out Half value))
<#          }
            else if (preferredNumericType == "sbyte")
            { #>
                !jsonElement.TryGetSByte(out sbyte value))
<#          }
            else if (preferredNumericType == "short")
            { #>
                !jsonElement.TryGetInt16(out short value))
<#          }
            else if (preferredNumericType == "int")
            { #>
                !jsonElement.TryGetInt32(out int value))
<#          }
            else if (preferredNumericType == "long")
            { #>
                !jsonElement.TryGetInt64(out long value))
<#          }
            else if (preferredNumericType == "Int128")
            { #>
                !jsonElement.TryGetInt128(out Int128 value))
<#          }
            else if (preferredNumericType == "byte")
            { #>
                !jsonElement.TryGetByte(out byte value))
<#          }
            else if (preferredNumericType == "ushort")
            { #>
                !jsonElement.TryGetUInt16(out ushort value))
<#          }
            else if (preferredNumericType == "uint")
            { #>
                !jsonElement.TryGetUInt32(out uint value))
<#          }
            else if (preferredNumericType == "ulong")
            { #>
                !jsonElement.TryGetUInt64(out ulong value))
<#          }
            else if (preferredNumericType == "UInt128")
            { #>
                !jsonElement.TryGetUInt128(out UInt128 value))
<#          } #>
            {
                written = 0;
                return false;
            }

            items[index++] = value;
<#      }
        else
        { #>
            <#= SingleItemsDotnetTypeName #> child = <#= SingleItemsDotnetTypeName #>.FromJson(jsonElement);

            if (!child.TryGetNumericValues(items[index..], out int writtenChildren))
            {
                written = 0;
                return false;
            }

            index += writtenChildren;
<#      } #>
        }

        written = index;
        return true;
    }
<#  } #>

    /// <inheritdoc/>
<#  if (CanEnumerateAsSpecificType)
    { #>
    JsonArrayEnumerator<TItem> IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>.EnumerateArray<TItem>()
<#  }
    else
    { #>
    public JsonArrayEnumerator<TItem> EnumerateArray<TItem>()
        where TItem : struct, IJsonValue<TItem>
<#  } #>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return new JsonArrayEnumerator<TItem>(this.jsonElementBacking);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return new JsonArrayEnumerator<TItem>(this.arrayBacking);
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonAny}"/> from the array.
    /// </summary>
    /// <returns>An immutable list of <see cref="JsonAny"/> built from the array.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    private ImmutableList<JsonAny> GetImmutableList()
    {
        if ((this.backing & Backing.Array) != 0)
        {
            return this.arrayBacking;
        }

        return this.GetImmutableListBuilder().ToImmutable();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonAny}.Builder"/> from the array.
    /// </summary>
    /// <returns>An immutable list builder of <see cref="JsonAny"/>, built from the existing array.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    private ImmutableList<JsonAny>.Builder GetImmutableListBuilder()
    {
        if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
        {
            ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
            foreach (JsonElement item in this.jsonElementBacking.EnumerateArray())
            {
                builder.Add(new(item));
            }

            return builder;
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return this.arrayBacking.ToBuilder();
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonAny}"/> from the array, replacing the item at the specified index with the given item.
    /// </summary>
    /// <param name="index">The index at which to add the element.</param>
    /// <param name="value">The value to add.</param>
    /// <returns>An immutable list containing the contents of the list, with the specified item at the index.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    /// <exception cref="IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
    private ImmutableList<JsonAny> GetImmutableListSetting(int index, in JsonAny value)
    {
        if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
        {
            return JsonValueHelpers.GetImmutableListFromJsonElementSetting(this.jsonElementBacking, index, value);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            try
            {
                return this.arrayBacking.SetItem(index, value);
            }
            catch (ArgumentOutOfRangeException ex)
            {
                throw new IndexOutOfRangeException(ex.Message, ex);
            }
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonAny}"/> from the array, removing the first item that equals the given value, and replacing it with the specified item.
    /// </summary>
    /// <param name="oldItem">The item to remove.</param>
    /// <param name="newItem">The item to insert.</param>
    /// <returns>An immutable list containing the contents of the list, without the first instance that matches the old item, replacing it with the new item.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    private ImmutableList<JsonAny> GetImmutableListReplacing(in JsonAny oldItem, in JsonAny newItem)
    {
        if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
        {
            return JsonValueHelpers.GetImmutableListFromJsonElementReplacing(this.jsonElementBacking, oldItem, newItem);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return this.arrayBacking.Replace(oldItem, newItem);
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonAny}"/> from the array, removing the first item that equals the given value.
    /// </summary>
    /// <param name="item">The item to remove.</param>
    /// <returns>An immutable list containing the contents of the list, without the first instance that matches the given item.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    private ImmutableList<JsonAny> GetImmutableListWithout(in JsonAny item)
    {
        if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
        {
            return JsonValueHelpers.GetImmutableListFromJsonElementWithout(this.jsonElementBacking, item);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return this.arrayBacking.Remove(item);
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonAny}"/> from the array, removing the given range.
    /// </summary>
    /// <param name="index">The start index of the range to remove.</param>
    /// <param name="count">The length of the range to remove.</param>
    /// <returns>An immutable list containing the contents of the list, without the given range of items.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    /// <exception cref="IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
    private ImmutableList<JsonAny> GetImmutableListWithoutRange(int index, int count)
    {
        if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
        {
            return JsonValueHelpers.GetImmutableListFromJsonElementWithoutRange(this.jsonElementBacking, index, count);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            try
            {
                return this.arrayBacking.RemoveRange(index, count);
            }
            catch (ArgumentOutOfRangeException ex)
            {
                throw new IndexOutOfRangeException(ex.Message, ex);
            }
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonAny}"/> from the array, adding the given item.
    /// </summary>
    /// <param name="index">The index at which to add the element.</param>
    /// <param name="value">The value to add.</param>
    /// <returns>An immutable list containing the contents of the list, without the array.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    /// <exception cref="IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
    private ImmutableList<JsonAny> GetImmutableListWith(int index, in JsonAny value)
    {
        if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
        {
            return JsonValueHelpers.GetImmutableListFromJsonElementWith(this.jsonElementBacking, index, value);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            try
            {
                return this.arrayBacking.Insert(index, value);
            }
            catch (ArgumentOutOfRangeException ex)
            {
                throw new IndexOutOfRangeException(ex.Message, ex);
            }
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Builds an <see cref="ImmutableList{JsonAny}"/> from the array, adding the given item.
    /// </summary>
    /// <param name="index">The index at which to add the element.</param>
    /// <param name="values">The values to add.</param>
    /// <returns>An immutable list containing the contents of the list, without the array.</returns>
    /// <exception cref="InvalidOperationException">The value is not an array.</exception>
    /// <exception cref="IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
    private ImmutableList<JsonAny> GetImmutableListWith<TEnumerable>(int index, TEnumerable values)
        where TEnumerable : IEnumerable<JsonAny>
    {
        if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
        {
            return JsonValueHelpers.GetImmutableListFromJsonElementWith(this.jsonElementBacking, index, values);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            try
            {
                return this.arrayBacking.InsertRange(index, values);
            }
            catch (ArgumentOutOfRangeException ex)
            {
                throw new IndexOutOfRangeException(ex.Message, ex);
            }
        }

        throw new InvalidOperationException();
    }
}
<# EndNesting(); #>
<#+
    public bool ShouldGenerate
    {
        get
        {
            return IsImplicitArray || IsNotImplicitType;
        }
    }
#>