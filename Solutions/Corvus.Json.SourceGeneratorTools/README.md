# Corvus.Json.SourceGeneratorTools

This provides a set of self-contained libraries for use in Source Generators that wish to generate code from JSON Schema.

It is only ever intended to be used as a _private asset_ in such generators, and is not intended to be referenced by end-user libraries.

It minimizes external dependencies by compiling in the source from the following libraries:

`Corvus.Json.CodeGeneration.*`
`Corvus.UriTemplates`
`Corvus.Json.JsonReference`
`Corvus.Json.ExtendedTypes`
`Corvus.Json.JsonSchema`

It also references `8.x` and prior versions of the System libraries which simplifies referencing in your custom Source Generator or Analyzer.

## Implementation Helpers

We provide a helper class to simplify some of the most common code-generation requirements.

For example, `SourceGeneratorHelpers.GenerateCode()` takes a `SourceProductionContext` and an instance of a type called `TypesToGenerate` which
describes the set of root types to generate (whose dependencies will be inferred and automatically generated if not explicitly specified).

It also takes an instance of a `VocabularyRegistry`. This is a `Corvus.Json.CodeGeneration` type; a default instance can be retrieved by calling `SourceGeneratorHelpers.CreateVocabularyRegistry()` and passing it an `IDocumentResolver` that has been preloaded with the standard vocabulary metaschema.

A suitable `IDocumentResolver` for this purpose can be retrieved by calling `SourceGeneratorHelpers.CreateMetaSchemaResolver()`.

For code generation, you will also need a `PrepoulatedDocumentResolver` containing the relevant additional analyzer files. A method
called `SourceGeneratorHelpers.BuildDocumentResolver()` will create such a document resolver for you, if provided with an `ImmutableArray<AdditionalText>`.

Exactly when you construct these entities and types depends on your approach to source generation, and its caching strategy.

Your generator code may look something like:

```csharp
    private static readonly IDocumentResolver MetaSchemaResolver = CreateMetaSchemaResolver();
    private static readonly VocabularyRegistry VocabularyRegistry = CreateVocabularyRegistry(MetaSchemaResolver);

    public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
    {
        // Get global options
        IncrementalValueProvider<SourceGeneratorHelpers.GlobalOptions> globalOptions = initializationContext.AnalyzerConfigOptionsProvider.Select(GetGlobalOptions);

        IncrementalValuesProvider<AdditionalText> jsonSourceFiles = initializationContext.AdditionalTextsProvider.Where(p => p.Path.EndsWith(".json"));

        IncrementalValueProvider<IDocumentResolver> documentResolver = jsonSourceFiles.Collect().Select(SourceGeneratorHelpers.BuildDocumentResolver);

        IncrementalValueProvider<SourceGeneratorHelpers.GenerationContext> generationContext = documentResolver.Combine(globalOptions).Select((r, c) => new SourceGeneratorHelpers.GenerationContext(r.Left, r.Right));

        // Typically built from e.g. attributes or other syntax on partial classes.
        IncrementalValuesProvider<SourceGeneratorHelpers.GenerationSpecification> generationSpecifications = BuildGenerationSpecifications();
            
        IncrementalValueProvider<SourceGeneratorHelpers.TypesToGenerate> typesToGenerate = generationSpecifications.Collect().Combine(generationContext).Select((c, t) => new SourceGeneratorHelpers.TypesToGenerate(c.Left, c.Right));

        initializationContext.RegisterSourceOutput(typesToGenerate, GenerateCode);
    }

    private static void GenerateCode(SourceProductionContext context, SourceGeneratorHelpers.TypesToGenerate generationSource)
    {
        SourceGeneratorHelpers.GenerateCode(context, generationSource, VocabularyRegistry);
    }

```

## Compatibility and Interoperability

The code *generated by your Source Generator* should be compiled into assemblies that reference `Corvus.Json.ExtendedTypes` at runtime in the usual way.

Should you wish to use schema *in the implementation of your Source Generator itself*, you will need to compile that generated code into `netstandard2.0` libraries that reference the `Corvus.Json.SourceGeneratorTools` assembly. Typically, this will be your Source Generator assembly itself.

We recommend using the command line tool to generate these types to avoid analyzer inception! (It works, but it is confusing!)

For example, we provide generated code for the standard JSON Schema meta-schema, and OpenAPI 3.0 and 3.1, compiled into this library. You cannot reference the `Corvus.Json.JsonSchema.*` packages directly in your Source Generator.

## Breaking Changes

### V4.1.3

In V4.1.3 we have changed the signature of the `GenerationSpecification` struct so the type name becomes optional, and allows you to infer it from the schema.