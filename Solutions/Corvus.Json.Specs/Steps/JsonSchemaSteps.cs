// <copyright file="JsonSchemaSteps.cs" company="Endjin Limited">
// Copyright (c) Endjin Limited. All rights reserved.
// </copyright>

using System.Text.Json;
using Corvus.Json;
using Corvus.Json.CodeGeneration;
using Corvus.Json.CodeGeneration.CSharp;
using Drivers;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.Configuration;

using NUnit.Framework;
using TechTalk.SpecFlow;

namespace Steps;

/// <summary>
/// Steps for the JsonSchema specs generated by Corvus.JsonSchema.SpecGenerator.
/// </summary>
[Binding]
public class JsonSchemaSteps
{
    private const string InputJsonFileName = "InputJsonFileName";
    private const string SchemaPath = "SchemaPath";
    private const string InputData = "InputData";
    private const string InputDataPath = "InputDataPath";
    private const string SchemaType = "SchemaType";
    private const string SchemaCode = "SchemaCode";
    private const string SchemaInstance = "SchemaInstance";
    private const string SchemaValidationResult = "SchemaValidationResult";
    private const string ValidateFormatKey = "ValidateFormat";
    private const string CreateException = "CreateException";
    private const string NullablePropertiesKey = "NullableProperties";
    private const string UseImplicitOperatorStringKey = "UseImplicitOperatorString";
    private readonly FeatureContext featureContext;
    private readonly ScenarioContext scenarioContext;
    private readonly JsonSchemaBuilderDriver driver;
    private readonly IConfiguration configuration;

    /// <summary>
    /// Initializes a new instance of the <see cref="JsonSchemaSteps"/> class.
    /// </summary>
    /// <param name="featureContext">The current feature context.</param>
    /// <param name="scenarioContext">The current scenario context.</param>
    /// <param name="driver">The json schema builder driver.</param>
    /// <param name="configuration">Configuration settings.</param>
    public JsonSchemaSteps(FeatureContext featureContext, ScenarioContext scenarioContext, JsonSchemaBuilderDriver driver, IConfiguration configuration)
    {
        this.featureContext = featureContext;
        this.scenarioContext = scenarioContext;
        this.driver = driver;
        this.configuration = configuration;
    }

    [Given("I construct an instance of the V3 generated type as a JsonElement backed object")]
    public void GivenAnInstanceOfTheV3GeneratedTypeJsonElement()
    {
        var value = Model.V3.Basictypes.FromJson(this.scenarioContext.Get<JsonElement>(InputData));
        this.scenarioContext.Set(value, SchemaInstance);
    }

    [Given("I construct an instance of the V3 generated type as a dotnet backed object")]
    public void GivenAnInstanceOfTheV3GeneratedTypeDotnet()
    {
        var value = Model.V3.Basictypes.FromJson(this.scenarioContext.Get<JsonElement>(InputData));
        this.scenarioContext.Set(value.AsDotnetBackedValue(), SchemaInstance);
    }

    /// <summary>
    /// Provides the input JSON test file name as a scenario property called <see cref="InputJsonFileName"/>.
    /// </summary>
    /// <param name="inputFileName">The JSON test file name.</param>
    [Given(@"the input JSON file ""(.*)""")]
    public void GivenTheInputJSONFile(string inputFileName)
    {
        this.scenarioContext.Set(inputFileName, InputJsonFileName);
    }

    /// <summary>
    /// Uses the reference fragment to provide the schema JsonElement as a scenario property <see cref="SchemaPath"/>.
    /// </summary>
    /// <param name="referenceFragment">The reference fragment pointing to the relevant schema element in the <see cref="InputJsonFileName"/>.</param>
    [Given(@"the schema at ""(.*)""")]
    public void GivenTheSchemaAt(string referenceFragment)
    {
        this.scenarioContext.Set(referenceFragment, SchemaPath);
    }

    /// <summary>
    /// Uses the reference fragment to provide the schema JsonElement as a scenario property <see cref="SchemaPath"/>.
    /// </summary>
    /// <param name="schema">The actual schema to generate.</param>
    [Given("the schema content (.*)")]
    public void GivenTheSchema(string schema)
    {
        this.scenarioContext.Set(schema, SchemaInstance);
    }

    /// <summary>
    /// Determines whether we will assert formatting or not.
    /// </summary>
    [Given("I assert format")]
    public void GivenIAssertFormat()
    {
        this.scenarioContext.Set(true, ValidateFormatKey);
    }

    /// <summary>
    /// Uses the reference fragment to provide the data <see cref="JsonElement"/> as a scenario property called <see cref="InputData"/>.
    /// </summary>
    /// <param name="referenceFragment">The reference fragment pointing to the relevant data element in the <see cref="InputJsonFileName"/>.</param>
    /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
    [Given(@"the input data at ""(.*)""")]
    public async Task GivenTheInputDataAt(string referenceFragment)
    {
        JsonElement? element = await this.driver.GetElementFromLocalFile(this.scenarioContext.Get<string>(InputJsonFileName), referenceFragment);
        Assert.NotNull(
            element,
            $"Failed to load input data at {this.scenarioContext.Get<string>(InputJsonFileName)}, ref {referenceFragment}, jsonSchemaBuilder201909DriverSettings:testBaseDirectory: '{this.configuration["jsonSchemaBuilder201909DriverSettings:testBaseDirectory"]}', jsonSchemaBuilder202012DriverSettings: '{this.configuration["jsonSchemaBuilder202012DriverSettings:testBaseDirectory"]}' CWD: '{Environment.CurrentDirectory}'");
        this.scenarioContext.Set(referenceFragment, InputDataPath);
        this.scenarioContext.Set(element!.Value, InputData);
    }

    [Given("a schema file")]
    public void GivenASchemaFileWithContent(string schema)
    {
        this.scenarioContext.Set(schema, SchemaInstance);
        string featureName = ToPascalCaseWithReservedWords(this.featureContext.FeatureInfo.Title);

        string scenarioName = BuildScenarioOutlineNameFromScenarioName(this.scenarioContext);

        this.scenarioContext.Set($"{featureName}.{scenarioName}.json", InputJsonFileName);
        this.scenarioContext.Set("#/", SchemaPath);

        static string BuildScenarioOutlineNameFromScenarioName(ScenarioContext scenarioContext)
        {
            string scenarioName = scenarioContext.ScenarioInfo.Title;
            int index = scenarioContext.ScenarioInfo.Title.IndexOf('(');
            if (index >= 0)
            {
                // Slice back to the scenario outline name
                scenarioName = scenarioName[..index];
            }

            return ToPascalCaseWithReservedWords(scenarioName);
        }
    }

    [Given("a schema file with format (.*)")]
    public void GivenASchemaFileWithFormat(string format, string schema)
    {
        this.scenarioContext.Set(schema.Replace("{{format}}", format), SchemaInstance);
        string featureName = ToPascalCaseWithReservedWords(this.featureContext.FeatureInfo.Title);

        string scenarioName = BuildScenarioOutlineNameFromScenarioName(this.scenarioContext);

        this.scenarioContext.Set($"{featureName}.{scenarioName}.{format}.json", InputJsonFileName);
        this.scenarioContext.Set("#/", SchemaPath);

        static string BuildScenarioOutlineNameFromScenarioName(ScenarioContext scenarioContext)
        {
            string scenarioName = scenarioContext.ScenarioInfo.Title;
            int index = scenarioContext.ScenarioInfo.Title.IndexOf('(');
            if (index >= 0)
            {
                // Slice back to the scenario outline name
                scenarioName = scenarioName[..index];
            }

            return ToPascalCaseWithReservedWords(scenarioName);
        }
    }

    /// <summary>
    ///  <see cref="JsonElement"/> as a scenario property called <see cref="InputData"/>.
    /// </summary>
    /// <param name="inputData">The input data in serialized JSON form.</param>
    [Given("the input data value (.*)")]
    public void GivenTheInputData(string inputData)
    {
        using var doc = JsonDocument.Parse(inputData);
        this.scenarioContext.Set(doc.RootElement.Clone(), InputData);
    }

    [Given(@"I create the instance by casting the ([^\s]*) (.*)")]
    public void GivenICreateTheInstanceByCastingTheSbyte(string numericType, string numericValue)
    {
        IJsonValue value = JsonSchemaBuilderDriver.CastToInstance(this.scenarioContext.Get<Type>(SchemaType), numericType, numericValue);
        this.scenarioContext.Set(value, SchemaInstance);
    }

    [When("I create the instance using FromValues with format '([^']*)' and input data '([^']*)'")]
    public void WhenICreateTheInstanceUsingFromValuesWithFormatAndInputData(string format, string inputDataString)
    {
        try
        {
            IJsonValue instance = format switch
            {
                "single" => CreateSingleInstance(inputDataString),
                "double" => CreateDoubleInstance(inputDataString),
                "decimal" => CreateDecimalInstance(inputDataString),
                "sbyte" => CreateSByteInstance(inputDataString),
                "int16" => CreateInt16Instance(inputDataString),
                "int32" => CreateInt32Instance(inputDataString),
                "int64" => CreateInt64Instance(inputDataString),
                "byte" => CreateByteInstance(inputDataString),
                "uint16" => CreateUInt16Instance(inputDataString),
                "uint32" => CreateUInt32Instance(inputDataString),
                "uint64" => CreateUInt64Instance(inputDataString),
#if NET8_0_OR_GREATER
                "half" => CreateHalfInstance(inputDataString),
                "int128" => CreateInt128Instance(inputDataString),
                "uint128" => CreateUInt128Instance(inputDataString),
#endif
                _ => throw new InvalidOperationException($"Unsupported format: {format}"),
            };

            this.scenarioContext.Set(instance, SchemaInstance);
        }
        catch (Exception ex)
        {
            this.scenarioContext.Set(ex, CreateException);
        }

#if NET8_0_OR_GREATER
        IJsonValue CreateUInt128Instance(string inputDataString)
        {
            UInt128[] itemArray = BuildUInt128Array(inputDataString);

            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }
#endif

        IJsonValue CreateUInt64Instance(string inputDataString)
        {
            ulong[] itemArray = BuildUInt64Array(inputDataString);

            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateUInt32Instance(string inputDataString)
        {
            uint[] itemArray = BuildUInt32Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            After:
                        return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            */
            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateUInt16Instance(string inputDataString)
        {
            ushort[] itemArray = BuildUInt16Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            After:
                        return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            */
            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateByteInstance(string inputDataString)
        {
            byte[] itemArray = BuildByteArray(inputDataString);

            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

#if NET8_0_OR_GREATER
        IJsonValue CreateInt128Instance(string inputDataString)
        {
            Int128[] itemArray = BuildInt128Array(inputDataString);

            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }
#endif

        IJsonValue CreateInt64Instance(string inputDataString)
        {
            long[] itemArray = BuildInt64Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            After:
                        return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            */
            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateInt32Instance(string inputDataString)
        {
            int[] itemArray = BuildInt32Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            After:
                        return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            */
            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateInt16Instance(string inputDataString)
        {
            short[] itemArray = BuildInt16Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            After:
                        return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            */
            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateSByteInstance(string inputDataString)
        {
            sbyte[] itemArray = BuildSByteArray(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            After:
                        return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
            */
            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateDecimalInstance(string inputDataString)
        {
            decimal[] itemArray = BuildDecimalArray(inputDataString);

            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateDoubleInstance(string inputDataString)
        {
            double[] itemArray = BuildDoubleArray(inputDataString);

            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

        IJsonValue CreateSingleInstance(string inputDataString)
        {
            float[] itemArray = BuildSingleArray(inputDataString);

            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }

#if NET8_0_OR_GREATER
        IJsonValue CreateHalfInstance(string inputDataString)
        {
            Half[] itemArray = BuildHalfArray(inputDataString);

            return JsonSchemaBuilderDriver.CreateInstanceOfNumericArrayFromValues(this.scenarioContext.Get<Type>(SchemaType), itemArray);
        }
#endif
    }

    [Then("the result will not throw an exception")]
    public void ThenTheResultWillNotThrowAnException()
    {
        Assert.IsFalse(this.scenarioContext.ContainsKey(CreateException));
    }

    [Then("the result will throw an exception")]
    public void ThenTheResultWillThrowAnException()
    {
        Assert.IsTrue(this.scenarioContext.ContainsKey(CreateException));
    }

    [Then("if an exception was not thrown then TryGetValues with format '([^']*)' will equal the input data '([^']*)'")]
    public void ThenIfAnExceptionWasNotThrownThenTryGetValuesWithFormatWillEqualTheInputData(string format, string inputDataString)
    {
        if (this.scenarioContext.ContainsKey(CreateException))
        {
            Assert.Pass();
        }

        bool isTrue = format switch
        {
            "single" => CompareSingleValues(inputDataString),
            "double" => CompareDoubleValues(inputDataString),
            "decimal" => CompareDecimalValues(inputDataString),
            "sbyte" => CompareSByteValues(inputDataString),
            "int16" => CompareInt16Values(inputDataString),
            "int32" => CompareInt32Values(inputDataString),
            "int64" => CompareInt64Values(inputDataString),
            "byte" => CompareByteValues(inputDataString),
            "uint16" => CompareUInt16Values(inputDataString),
            "uint32" => CompareUInt32Values(inputDataString),
            "uint64" => CompareUInt64Values(inputDataString),
#if NET8_0_OR_GREATER
            "half" => CompareHalfValues(inputDataString),
            "int128" => CompareInt128Values(inputDataString),
            "uint128" => CompareUInt128Values(inputDataString),
#endif
            _ => throw new InvalidOperationException($"Unsupported format: {format}"),
        };

        Assert.IsTrue(isTrue);

#if NET8_0_OR_GREATER
        bool CompareUInt128Values(string inputDataString)
        {
            UInt128[] itemArray = BuildUInt128Array(inputDataString);

            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }
#endif

        bool CompareUInt64Values(string inputDataString)
        {
            ulong[] itemArray = BuildUInt64Array(inputDataString);

            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareUInt32Values(string inputDataString)
        {
            uint[] itemArray = BuildUInt32Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CompareInstanceOfNumericArrayWithValues(
            After:
                        return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
            */
            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareUInt16Values(string inputDataString)
        {
            ushort[] itemArray = BuildUInt16Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CompareInstanceOfNumericArrayWithValues(
            After:
                        return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
            */
            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareByteValues(string inputDataString)
        {
            byte[] itemArray = BuildByteArray(inputDataString);

            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

#if NET8_0_OR_GREATER
        bool CompareInt128Values(string inputDataString)
        {
            Int128[] itemArray = BuildInt128Array(inputDataString);

            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }
#endif

        bool CompareInt64Values(string inputDataString)
        {
            long[] itemArray = BuildInt64Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CompareInstanceOfNumericArrayWithValues(
            After:
                        return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
            */
            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareInt32Values(string inputDataString)
        {
            int[] itemArray = BuildInt32Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CompareInstanceOfNumericArrayWithValues(
            After:
                        return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
            */
            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareInt16Values(string inputDataString)
        {
            short[] itemArray = BuildInt16Array(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CompareInstanceOfNumericArrayWithValues(
            After:
                        return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
            */
            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareSByteValues(string inputDataString)
        {
            sbyte[] itemArray = BuildSByteArray(inputDataString);

            /* Unmerged change from project 'Corvus.Json.Specs (net481)'
            Before:
                        return this.driver.CompareInstanceOfNumericArrayWithValues(
            After:
                        return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
            */
            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareDecimalValues(string inputDataString)
        {
            decimal[] itemArray = BuildDecimalArray(inputDataString);

            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareDoubleValues(string inputDataString)
        {
            double[] itemArray = BuildDoubleArray(inputDataString);

            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

        bool CompareSingleValues(string inputDataString)
        {
            float[] itemArray = BuildSingleArray(inputDataString);

            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }

#if NET8_0_OR_GREATER
        bool CompareHalfValues(string inputDataString)
        {
            Half[] itemArray = BuildHalfArray(inputDataString);

            return JsonSchemaBuilderDriver.CompareInstanceOfNumericArrayWithValues(
                this.scenarioContext.Get<Type>(SchemaType),
                this.scenarioContext.Get<IJsonValue>(SchemaInstance),
                itemArray);
        }
#endif
    }

    [Given("I generate a type for the schema with optional properties nullable")]
    public Task GivenIGenerateATypeForTheSchemaWithOptionalPropertiesNullable()
    {
        this.scenarioContext.Set(true, NullablePropertiesKey);
        return this.GivenIGenerateATypeForTheSchema();
    }

    [Given("I generate a type for the schema with implicit conversion to string enabled")]
    public Task GivenIGenerateATypeForTheSchemaWithImplicitConversionToStringEnabled()
    {
        this.scenarioContext.Set(true, UseImplicitOperatorStringKey);
        return this.GivenIGenerateATypeForTheSchema();
    }

    [Given("I generate a type for the schema with optional properties not nullable")]
    public Task GivenIGenerateATypeForTheSchemaWithOptionalPropertiesNotNullable()
    {
        this.scenarioContext.Set(false, NullablePropertiesKey);
        return this.GivenIGenerateATypeForTheSchema();
    }

    [Given("I generate the code for the schema")]
    [When("I generate the code for the schema")]
    public async Task GivenIGenerateTheCodeForTheSchema()
    {
        string featureName = ToPascalCaseWithReservedWords(this.featureContext.FeatureInfo.Title);
        string scenarioName = ToPascalCaseWithReservedWords(this.scenarioContext.ScenarioInfo.Title);
        string filename = this.scenarioContext.Get<string>(InputJsonFileName);
        string schemaPath = this.scenarioContext.Get<string>(SchemaPath);

        IReadOnlyCollection<GeneratedCodeFile> code;

        this.scenarioContext.TryGetValue(ValidateFormatKey, out bool validateFormat);

        if (this.scenarioContext.ContainsKey(InputDataPath))
        {
            code = await this.driver.GenerateCodeForJsonSchemaTestSuite(
                filename,
                schemaPath,
                featureName,
                scenarioName,
                validateFormat,
                this.scenarioContext.TryGetValue(NullablePropertiesKey, out bool optionalAsNullable) && optionalAsNullable,
                this.scenarioContext.TryGetValue(UseImplicitOperatorStringKey, out bool useImplicitOperatorString) && useImplicitOperatorString);
        }
        else
        {
            string schema = this.scenarioContext.Get<string>(SchemaInstance);
            code = await this.driver.GenerateCodeForVirtualFile(
                schema,
                filename,
                featureName,
                scenarioName,
                validateFormat,
                this.scenarioContext.TryGetValue(NullablePropertiesKey, out bool optionalAsNullable) && optionalAsNullable,
                this.scenarioContext.TryGetValue(UseImplicitOperatorStringKey, out bool useImplicitOperatorString) && useImplicitOperatorString);
        }

        this.scenarioContext.Set(code, SchemaCode);
    }

    [Then(@"the remarks for the file '([^']*)' parent struct '([^']*)' child struct '([^']*)' property '([^']*)' will be")]
    public void ThenTheRemarksForTheFileStructPropertyWillBe(string fileName, string parentStructName, string structName, string propertyName, string remarksText)
    {
        IReadOnlyCollection<GeneratedCodeFile> code = this.scenarioContext.Get<IReadOnlyCollection<GeneratedCodeFile>>(SchemaCode);
        GeneratedCodeFile? file = code.SingleOrDefault(f => f.FileName == fileName);
        Assert.NotNull(file);
        Microsoft.CodeAnalysis.SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(file!.FileContent);
        CompilationUnitSyntax root = syntaxTree.GetCompilationUnitRoot();
        PropertyDeclarationSyntax? property = root.Members
            .OfType<FileScopedNamespaceDeclarationSyntax>()
            .SingleOrDefault()
            ?.Members
            .OfType<StructDeclarationSyntax>()
            .SingleOrDefault(s => s.Identifier.Text == parentStructName)
            ?.Members
            .OfType<StructDeclarationSyntax>()
            .SingleOrDefault(s => s.Identifier.Text == structName)
            ?.Members
            .OfType<PropertyDeclarationSyntax>()
            .SingleOrDefault(s => s.Identifier.Text == propertyName);
        Assert.NotNull(property);
        string trivia = property!.GetLeadingTrivia().ToString();
        int remarksStart = trivia.IndexOf("<remarks>");
        Assert.GreaterOrEqual(remarksStart, 0);
        remarksStart += "<remarks>".Length;
        int remarksEnd = trivia.IndexOf("/// </remarks>");
        Assert.GreaterOrEqual(remarksEnd, remarksStart);

        // Normalize the line endings
        string actual = trivia[remarksStart..remarksEnd].Replace("\r\n", "\n").Trim();
        string expected = remarksText.Replace("\r\n", "\n").Trim();
        Assert.AreEqual(expected, actual);
    }

    /// <summary>
    /// Generates the code for the schema in the scenario property <see cref="SchemaPath"/>, compiles it, and loads the assembly. The fully qualified type name is stored in a scenario property called <see cref="SchemaType"/>.
    /// </summary>
    /// <returns>A <see cref="Task"/> representing the asynchronous operation.</returns>
    [Given("I generate a type for the schema")]
    public async Task GivenIGenerateATypeForTheSchema()
    {
        string featureName = ToPascalCaseWithReservedWords(this.featureContext.FeatureInfo.Title);
        string scenarioName = ToPascalCaseWithReservedWords(this.scenarioContext.ScenarioInfo.Title);
        string filename = this.scenarioContext.Get<string>(InputJsonFileName);
        string schemaPath = this.scenarioContext.Get<string>(SchemaPath);
        string key = filename + schemaPath;

        Type type;

        if (this.featureContext.ContainsKey(key))
        {
            type = this.featureContext.Get<Type>(key);
        }
        else
        {
            this.scenarioContext.TryGetValue(ValidateFormatKey, out bool validateFormat);

            if (this.scenarioContext.ContainsKey(InputDataPath))
            {
                type = await this.driver.GenerateTypeForJsonSchemaTestSuite(
                    filename,
                    schemaPath,
                    featureName,
                    scenarioName,
                    validateFormat,
                    this.scenarioContext.TryGetValue(NullablePropertiesKey, out bool optionalAsNullable) && optionalAsNullable,
                    this.scenarioContext.TryGetValue(UseImplicitOperatorStringKey, out bool useImplicitOperatorString) && useImplicitOperatorString);
            }
            else
            {
                string schema = this.scenarioContext.Get<string>(SchemaInstance);
                type = await this.driver.GenerateTypeForVirtualFile(
                    schema,
                    filename,
                    featureName,
                    scenarioName,
                    validateFormat,
                    this.scenarioContext.TryGetValue(NullablePropertiesKey, out bool optionalAsNullable) && optionalAsNullable,
                    this.scenarioContext.TryGetValue(UseImplicitOperatorStringKey, out bool useImplicitOperatorString) && useImplicitOperatorString);
            }

            this.featureContext.Set(type, key);
        }

        this.scenarioContext.Set(type, SchemaType);
    }

    /// <summary>
    /// Synchronously generates the code for the schema in the scenario property <see cref="SchemaPath"/>, compiles it, and loads the assembly. The fully qualified type name is stored in a scenario property called <see cref="SchemaType"/>.
    /// </summary>
    [Given("I synchronously generate a type for the schema")]
    public void GivenISynchronouslyGenerateATypeForTheSchema()
    {
        string featureName = ToPascalCaseWithReservedWords(this.featureContext.FeatureInfo.Title);
        string scenarioName = ToPascalCaseWithReservedWords(this.scenarioContext.ScenarioInfo.Title);
        string filename = this.scenarioContext.Get<string>(InputJsonFileName);
        string schemaPath = this.scenarioContext.Get<string>(SchemaPath);
        string key = filename + schemaPath;

        Type type;

        if (this.featureContext.ContainsKey(key))
        {
            type = this.featureContext.Get<Type>(key);
        }
        else
        {
            this.scenarioContext.TryGetValue(ValidateFormatKey, out bool validateFormat);

            if (this.scenarioContext.ContainsKey(InputDataPath))
            {
                type = this.driver.SynchronouslyGenerateTypeForJsonSchemaTestSuite(
                    filename,
                    schemaPath,
                    featureName,
                    scenarioName,
                    validateFormat,
                    optionalAsNullable: false);
            }
            else
            {
                string schema = this.scenarioContext.Get<string>(SchemaInstance);
                type = this.driver.SynchronouslyGenerateTypeForVirtualFile(
                    schema,
                    filename,
                    featureName,
                    scenarioName,
                    validateFormat,
                    optionalAsNullable: false);
            }

            this.featureContext.Set(type, key);
        }

        this.scenarioContext.Set(type, SchemaType);
    }

    /// <summary>
    /// Constructs an instance of the type whose name is stored in the scenario property <see cref="SchemaType"/>, using the <see cref="JsonElement"/> stored in the scenario property called <see cref="InputData"/>, and stores it in the scenario property <see cref="SchemaInstance"/>.
    /// </summary>
    [Given("I construct an instance of the schema type from the data")]
    [When("I construct an instance of the schema type from the data")]
    public void GivenIConstructAnInstanceOfTheSchemaTypeFromTheData()
    {
        IJsonValue value = JsonSchemaBuilderDriver.CreateInstance(this.scenarioContext.Get<Type>(SchemaType), this.scenarioContext.Get<JsonElement>(InputData));
        this.scenarioContext.Set(value, SchemaInstance);
    }

    /// <summary>
    /// Calls the validation method on the instance in the scenario property <see cref="SchemaInstance"/> and stores the validation result in <see cref="SchemaValidationResult"/>.
    /// </summary>
    /// <param name="level">The validation level.</param>
    [When("I validate the instance with level (.*)")]
    public void WhenIValidateTheInstanceWithLevel(ValidationLevel level)
    {
        IJsonValue jsonValue = this.scenarioContext.Get<IJsonValue>(SchemaInstance);
        ValidationContext validationContext = jsonValue.Validate(ValidationContext.ValidContext, level);
        this.scenarioContext.Set(validationContext, SchemaValidationResult);
    }

    /// <summary>
    /// Calls the validation method on the instance in the scenario property <see cref="SchemaInstance"/> and stores the validation result in <see cref="SchemaValidationResult"/>.
    /// </summary>
    [When("I validate the instance")]
    public void WhenIValidateTheInstance()
    {
        IJsonValue jsonValue = this.scenarioContext.Get<IJsonValue>(SchemaInstance);
        ValidationContext validationContext = jsonValue.Validate(ValidationContext.ValidContext);
        this.scenarioContext.Set(validationContext, SchemaValidationResult);
    }

    /// <summary>
    /// Gets a non-nullable property frrom the instance in the scenario property <see cref="SchemaInstance"/> and checks its value.
    /// </summary>
    /// <param name="propertyName">The .NET name of the property.</param>
    /// <param name="value">The value to test against.</param>
    [Then("the property '([^']*)' from the instance has the value '([^']*)'")]
    public void WhenIGetThePropertyFromTheInstanceIsValueWillBe(string propertyName, string value)
    {
        bool result = JsonSchemaBuilderDriver.CompareStringValue(
            this.scenarioContext.Get<Type>(SchemaType),
            this.scenarioContext.Get<IJsonValue>(SchemaInstance),
            propertyName,
            value);

        Assert.IsTrue(result);
    }

    /// <summary>
    /// Gets a non-nullable property frrom the instance in the scenario property <see cref="SchemaInstance"/> and checks its value.
    /// </summary>
    /// <param name="propertyName">The .NET name of the property.</param>
    [Then("the property '([^']*)' from the instance is undefined")]
    public void WhenIGetThePropertyFromTheInstanceItsValueIsUndefined(string propertyName)
    {
        bool result = JsonSchemaBuilderDriver.IsValueUndefined(
            this.scenarioContext.Get<Type>(SchemaType),
            this.scenarioContext.Get<IJsonValue>(SchemaInstance),
            propertyName);

        Assert.IsTrue(result);
    }

    /// <summary>
    /// Gets a nullable property frrom the instance in the scenario property <see cref="SchemaInstance"/> and checks its value.
    /// </summary>
    /// <param name="propertyName">The .NET name of the property.</param>
    /// <param name="value">The value to test against.</param>
    [Then("the nullable property '([^']*)' from the instance has the value '([^']*)'")]
    public void WhenIGetTheNullablePropertyFromTheInstanceIsValueWillBe(string propertyName, string value)
    {
        bool result = JsonSchemaBuilderDriver.CompareNullableStringValue(
            this.scenarioContext.Get<Type>(SchemaType),
            this.scenarioContext.Get<IJsonValue>(SchemaInstance),
            propertyName,
            value);

        Assert.IsTrue(result);
    }

    /// <summary>
    /// Uses the <see cref="ValidationResult"/> stored in the scenario property <see cref="SchemaValidationResult"/> and checks its <see cref="ValidationResult.Valid"/> property.
    /// </summary>
    /// <param name="expectedValidity"><c>True</c> if the result is expected to be valid, otherwise false.</param>
    [Then("the result will be (.*)")]
    public void ThenTheResultWillBe(bool expectedValidity)
    {
        ValidationContext actual = this.scenarioContext.Get<ValidationContext>(SchemaValidationResult);
        Assert.AreEqual(expectedValidity, actual.IsValid);
    }

    /// <summary>
    /// Uses the <see cref="ValidationResult"/> stored in the scenario property <see cref="SchemaValidationResult"/> and checks its <see cref="ValidationResult.Valid"/> property.
    /// </summary>
    /// <param name="count">The number of results expected in the result set.</param>
    [Then("there will be (.*) results")]
    public void ThenTheResultWillBe(int count)
    {
        ValidationContext actual = this.scenarioContext.Get<ValidationContext>(SchemaValidationResult);
        Assert.AreEqual(count, actual.Results.Count);
    }

    /// <summary>
    /// Gets the value as an string, using an implicit conversion.
    /// </summary>
    /// <param name="scenarioContext">The scenario context.</param>
    /// <returns>The value as a string, using implicit conversion.</returns>
    internal static string GetTheValueAsStringImplicit(ScenarioContext scenarioContext)
    {
        Type type = scenarioContext.Get<Type>(SchemaType);
        IJsonValue value = scenarioContext.Get<IJsonValue>(SchemaInstance);
        return
            type
                .GetMethods()
                .SingleOrDefault(m => m.Name == "op_Implicit" && m.ReturnType == typeof(string))
                ?.Invoke(null, [value])
            is string s
                ? s
                : throw new InvalidOperationException("No string returned from the implicit conversion.");
    }

    private static string ToPascalCaseWithReservedWords(string input)
    {
        Span<char> value = stackalloc char[Formatting.GetBufferLength(input.Length, "Entity".AsSpan(), ReadOnlySpan<char>.Empty)];
        input.AsSpan().CopyTo(value);
        int written = Formatting.ToPascalCase(value[..input.Length]);
        written = Formatting.FixReservedWords(value, written, "Entity".AsSpan(), ReadOnlySpan<char>.Empty);
        return value[..written].ToString();
    }

    private static ulong[] BuildUInt64Array(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        ulong[] itemArray = new ulong[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = ulong.Parse(item);
        }

        return itemArray;
    }

    private static uint[] BuildUInt32Array(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        uint[] itemArray = new uint[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = uint.Parse(item);
        }

        return itemArray;
    }

    private static ushort[] BuildUInt16Array(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        ushort[] itemArray = new ushort[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = ushort.Parse(item);
        }

        return itemArray;
    }

    private static byte[] BuildByteArray(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        byte[] itemArray = new byte[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = byte.Parse(item);
        }

        return itemArray;
    }

    private static long[] BuildInt64Array(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        long[] itemArray = new long[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = long.Parse(item);
        }

        return itemArray;
    }

    private static int[] BuildInt32Array(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        int[] itemArray = new int[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = int.Parse(item);
        }

        return itemArray;
    }

    private static short[] BuildInt16Array(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        short[] itemArray = new short[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = short.Parse(item);
        }

        return itemArray;
    }

    private static sbyte[] BuildSByteArray(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        sbyte[] itemArray = new sbyte[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = sbyte.Parse(item);
        }

        return itemArray;
    }

    private static decimal[] BuildDecimalArray(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        decimal[] itemArray = new decimal[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = decimal.Parse(item);
        }

        return itemArray;
    }

    private static double[] BuildDoubleArray(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        double[] itemArray = new double[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = double.Parse(item);
        }

        return itemArray;
    }

    private static float[] BuildSingleArray(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        float[] itemArray = new float[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = float.Parse(item);
        }

        return itemArray;
    }

#if NET8_0_OR_GREATER
    private static Half[] BuildHalfArray(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        var itemArray = new Half[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = Half.Parse(item);
        }

        return itemArray;
    }

    private static Int128[] BuildInt128Array(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        var itemArray = new Int128[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = Int128.Parse(item);
        }

        return itemArray;
    }

    private static UInt128[] BuildUInt128Array(string inputDataString)
    {
        string[] items = inputDataString.Split(',');
        var itemArray = new UInt128[items.Length];
        int index = 0;
        foreach (string item in items)
        {
            itemArray[index++] = UInt128.Parse(item);
        }

        return itemArray;
    }
#endif
}