// <copyright file="JsonSchema.cs" company="Endjin Limited">
// Copyright (c) Endjin Limited. All rights reserved.
// </copyright>

using System.Collections.Concurrent;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;

#if NET8_0_OR_GREATER
using System.Runtime.Loader;
#endif
using System.Text;
using System.Text.Json;
using Corvus.Json.CodeGeneration;
using Corvus.Json.CodeGeneration.CSharp;
using Corvus.Json.CodeGeneration.DocumentResolvers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.Extensions.DependencyModel;

namespace Corvus.Json.Validator;

/// <summary>
/// A JSON schema for validation.
/// </summary>
public readonly struct JsonSchema
{
    private const string GlobalUsingStatements =
        """
        // <auto-generated/>

        global using global::System;
        global using global::System.Collections.Generic;
        global using global::System.IO;
        global using global::System.Linq;
        """;

    private static readonly PrepopulatedDocumentResolver MetaschemaDocumentResolver = CreateMetaschemaDocumentResolver();
    private static readonly ConcurrentDictionary<string, ValidateCallback> CachedSchema = [];

#if NET8_0_OR_GREATER
    private static readonly DynamicAssemblyLoadContext PluginAssemblyLoadContext = new();
#endif

    private readonly ValidateCallback validateCallback;

    private JsonSchema(ValidateCallback validateCallback)
    {
        this.validateCallback = validateCallback;
    }

    private delegate ValidationContext ValidateCallback(JsonElement jsonElement, ValidationContext validationContext, ValidationLevel level);

    /// <summary>
    /// Create an instance of a JSON schema from a JSON document.
    /// </summary>
    /// <param name="text">The text for the document.</param>
    /// <param name="canonicalUri">The canonical URI for the document. If
    /// <see langword="null"/> then the <paramref name="canonicalUri"/> an attempt
    /// will be made to find the canonical URI in the schema.</param>
    /// <param name="options">Generation options.</param>
    /// <returns>The JSON schema instance.</returns>
    /// <exception cref="InvalidOperationException">No canonical URI could be found for the schema document.</exception>
    public static JsonSchema FromText(string text, string? canonicalUri = null, Options? options = null)
    {
        if (canonicalUri is not null && CachedSchema.TryGetValue(canonicalUri, out ValidateCallback? value))
        {
            return new(value);
        }

        options = options ?? Options.Default;

        var document = JsonDocument.Parse(text);

        if (canonicalUri is null && !TryGetCanonicalUri(document, out canonicalUri))
        {
            throw new InvalidOperationException("The document does not have a canonical URI and one was not provided.");
        }

        PrepopulatedDocumentResolver documentResolver = new();
        documentResolver.AddDocument(canonicalUri, document);
        return FromCore(canonicalUri, CompoundWithMetaschemaResolver(documentResolver, options), options.FallbackVocabulary, options.AlwaysAssertFormat);
    }

    /// <summary>
    /// Create an instance of a JSON schema from a JSON document.
    /// </summary>
    /// <param name="fileName">The canonical URI for the document.</param>
    /// <param name="options">Generation options.</param>
    /// <returns>The JSON schema instance.</returns>
    public static JsonSchema FromFile(string fileName, Options? options = null)
    {
        options = options ?? Options.Default;

        if (SchemaReferenceNormalization.TryNormalizeSchemaReference(fileName, out string? result))
        {
            fileName = result;
        }

        if (CachedSchema.TryGetValue($"{fileName}__{options.AlwaysAssertFormat}", out ValidateCallback? value))
        {
            return new(value);
        }

        CompoundDocumentResolver resolver = CompoundWithMetaschemaResolver(null, options);

        resolver.AddDocument(fileName, JsonDocument.Parse(File.ReadAllText(fileName)));

        return FromCore(fileName, resolver, options.FallbackVocabulary, options.AlwaysAssertFormat);
    }

    /// <summary>
    /// Create an instance of a JSON schema from a JSON document.
    /// </summary>
    /// <param name="jsonSchemaUri">The canonical URI for the document.</param>
    /// <param name="baseUriResolver">The base URI resolver.</param>
    /// <param name="options">Generation options.</param>
    /// <returns>The JSON schema instance.</returns>
    public static JsonSchema FromUri(string jsonSchemaUri, BaseUriResolver? baseUriResolver = null, Options? options = null)
    {
        options = options ?? Options.Default;

        if (CachedSchema.TryGetValue($"{jsonSchemaUri}__{options.AlwaysAssertFormat}", out ValidateCallback? value))
        {
            return new(value);
        }

        CompoundDocumentResolver resolver =
            CompoundWithMetaschemaResolver(
                baseUriResolver is not null
                    ? new CallbackDocumentResolver(baseUriResolver)
                    : null,
                options);

        return FromCore(jsonSchemaUri, resolver, options.FallbackVocabulary, options.AlwaysAssertFormat);
    }

    /// <summary>
    /// Create an instance of a JSON schema from a JSON document.
    /// </summary>
    /// <param name="jsonSchemaUri">The canonical URI for the document.</param>
    /// <param name="options">Generation options.</param>
    /// <returns>The JSON schema instance.</returns>
    public static JsonSchema From(string jsonSchemaUri, Options? options = null)
    {
        options = options ?? Options.Default;

        if (CachedSchema.TryGetValue($"{jsonSchemaUri}__{options.AlwaysAssertFormat}", out ValidateCallback? value))
        {
            return new(value);
        }

        return FromCore(jsonSchemaUri, CompoundWithMetaschemaResolver(null, options), options.FallbackVocabulary, options.AlwaysAssertFormat);
    }

    /// <summary>
    /// Validate a <see cref="JsonElement"/> against this schema.
    /// </summary>
    /// <param name="jsonElement">The <see cref="JsonElement"/> to validate.</param>
    /// <param name="level">The validation level to use (defaults to <see cref="ValidationLevel.Flag"/>.</param>
    /// <returns>The resulting validation context.</returns>
    public ValidationContext Validate(JsonElement jsonElement, ValidationLevel level = ValidationLevel.Flag)
    {
        return this.validateCallback(jsonElement, ValidationContext.ValidContext, level);
    }

    private static JsonSchema FromCore(string jsonSchemaUri, IDocumentResolver documentResolver, IVocabulary fallbackVocabulary, bool alwaysAssertFormat)
    {
        VocabularyRegistry vocabularyRegistry = RegisterVocabularies(documentResolver);

        JsonSchemaTypeBuilder typeBuilder = new(documentResolver, vocabularyRegistry);

        TypeDeclaration rootType =
            typeBuilder.AddTypeDeclarations(
                new JsonReference(jsonSchemaUri),
                fallbackVocabulary);

        IReadOnlyCollection<GeneratedCodeFile> generatedCode =
            typeBuilder.GenerateCodeUsing(
                CSharpLanguageProvider.DefaultWithOptions(new CSharpLanguageProvider.Options("GeneratedCode", alwaysAssertFormat: alwaysAssertFormat)),
                CancellationToken.None,
                rootType);

#if NET8_0_OR_GREATER
        Type generatedType = CompileGeneratedType(PluginAssemblyLoadContext, CSharpLanguageProvider.GetFullyQualifiedDotnetTypeName(rootType.ReducedTypeDeclaration().ReducedType), generatedCode);
#else
        Type generatedType = CompileGeneratedType(CSharpLanguageProvider.GetFullyQualifiedDotnetTypeName(rootType.ReducedTypeDeclaration().ReducedType), generatedCode);
#endif

        ValidateCallback validateCallback = BuildValidateCallback(generatedType);
        return new(CachedSchema.GetOrAdd(jsonSchemaUri, validateCallback));
    }

    private static bool TryGetCanonicalUri(JsonDocument document, [NotNullWhen(true)] out string? canonicalUri)
    {
        if (document.RootElement.ValueKind == JsonValueKind.Object &&
            document.RootElement.TryGetProperty("$id", out JsonElement value) &&
            value.ValueKind == JsonValueKind.String &&
            value.GetString() is string id)
        {
            canonicalUri = id;
            return true;
        }

        canonicalUri = null;
        return false;
    }

    private static PrepopulatedDocumentResolver CreateMetaschemaDocumentResolver()
    {
        var result = new PrepopulatedDocumentResolver();
        result.AddMetaschema();
        return result;
    }

    private static VocabularyRegistry RegisterVocabularies(IDocumentResolver documentResolver)
    {
        VocabularyRegistry vocabularyRegistry = new();

        // Add support for the vocabularies we are interested in.
        CodeGeneration.Draft202012.VocabularyAnalyser.RegisterAnalyser(documentResolver, vocabularyRegistry);
        CodeGeneration.Draft201909.VocabularyAnalyser.RegisterAnalyser(documentResolver, vocabularyRegistry);
        CodeGeneration.Draft7.VocabularyAnalyser.RegisterAnalyser(vocabularyRegistry);
        CodeGeneration.Draft6.VocabularyAnalyser.RegisterAnalyser(vocabularyRegistry);
        CodeGeneration.Draft4.VocabularyAnalyser.RegisterAnalyser(vocabularyRegistry);
        CodeGeneration.OpenApi30.VocabularyAnalyser.RegisterAnalyser(vocabularyRegistry);

        // And register the custom vocabulary for Corvus extensions.
        vocabularyRegistry.RegisterVocabularies(
            CodeGeneration.CorvusVocabulary.SchemaVocabulary.DefaultInstance);

        return vocabularyRegistry;
    }

    private static CompoundDocumentResolver CompoundWithMetaschemaResolver(IDocumentResolver? additionalResolver, Options options)
    {
        List<IDocumentResolver> resolvers = [];

        if (additionalResolver is not null)
        {
            resolvers.Add(additionalResolver);
        }

        if (options.AdditionalDocumentResolver is not null)
        {
            resolvers.Add(options.AdditionalDocumentResolver);
        }

        resolvers.Add(MetaschemaDocumentResolver);

        if (options.AllowFileSystemAndHttpResolution)
        {
            resolvers.Add(new FileSystemDocumentResolver());
            resolvers.Add(new HttpClientDocumentResolver(new HttpClient()));
        }

        return new([.. resolvers]);
    }

    private static ValidateCallback BuildValidateCallback(Type schemaType)
    {
        ConstructorInfo? constructor =
            schemaType
            .GetConstructors()
            .SingleOrDefault(c => c.GetParameters().Length == 1 && c.GetParameters()[0].ParameterType.Name.StartsWith("JsonElement"))
            ?? throw new InvalidOperationException($"Unable to find the public JsonElement constructor on type '{schemaType.FullName}'");

        Debug.Assert(constructor is not null, "The JsonElement constructor was not available on the target type.");

        ParameterExpression jsonElementParameter = Expression.Parameter(typeof(JsonElement), "jsonElement");
        ParameterExpression validationContextParameter = Expression.Parameter(typeof(ValidationContext), "validationContext");
        ParameterExpression levelParameter = Expression.Parameter(typeof(ValidationLevel), "level");

        var lambda = Expression.Lambda<Func<JsonElement, IJsonValue>>(
            Expression.Convert(Expression.New(constructor, jsonElementParameter), typeof(IJsonValue)),
            jsonElementParameter);

        Func<JsonElement, IJsonValue> constructValue = lambda.Compile();

        return (jsonElement, validationContext, level) =>
        {
            IJsonValue value = constructValue(jsonElement);
            return value.Validate(validationContext, level);
        };
    }

#if NET8_0_OR_GREATER
    private static Type CompileGeneratedType(AssemblyLoadContext assemblyLoadContext, string rootTypeName, IReadOnlyCollection<GeneratedCodeFile> generatedTypes)
    {
        bool isCorvusType = rootTypeName.StartsWith("Corvus.");

        (IEnumerable<MetadataReference> references, IEnumerable<string?> defines) = BuildMetadataReferencesAndDefines();

        IEnumerable<SyntaxTree> syntaxTrees = ParseSyntaxTrees(generatedTypes, defines);

        // We are happy with the defaults (debug etc.)
        CSharpCompilationOptions options = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithAssemblyIdentityComparer(DesktopAssemblyIdentityComparer.Default);
        var compilation = CSharpCompilation.Create($"Driver.GeneratedTypes_{Guid.NewGuid()}", syntaxTrees, references, options);
        using MemoryStream outputStream = new();
        EmitResult result = compilation.Emit(outputStream);

        if (!result.Success)
        {
            throw new Exception("Unable to compile generated code\r\n" + BuildCompilationErrors(result));
        }

        outputStream.Flush();
        outputStream.Position = 0;

        Assembly generatedAssembly = assemblyLoadContext.LoadFromStream(outputStream);

        if (isCorvusType)
        {
            return AssemblyLoadContext.Default.Assemblies.Single(a => a.GetName().Name == "Corvus.Json.ExtendedTypes").ExportedTypes.Single(t => t.FullName == rootTypeName);
        }

        return generatedAssembly.ExportedTypes.Single(t => t.FullName == rootTypeName);
    }
#else
    private static Type CompileGeneratedType(string rootTypeName, IReadOnlyCollection<GeneratedCodeFile> generatedTypes)
    {
        bool isCorvusType = rootTypeName.StartsWith("Corvus.");

        (IEnumerable<MetadataReference> references, IEnumerable<string?> defines) = BuildMetadataReferencesAndDefines();

        IEnumerable<SyntaxTree> syntaxTrees = ParseSyntaxTrees(generatedTypes, defines);

        // We are happy with the defaults (debug etc.)
        var options = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);
        var compilation = CSharpCompilation.Create($"CorvusJsonSchema.GeneratedTypes_{Guid.NewGuid()}", syntaxTrees, references, options);
        using MemoryStream outputStream = new();
        EmitResult result = compilation.Emit(outputStream);

        if (!result.Success)
        {
            throw new Exception("Unable to compile generated code\r\n" + BuildCompilationErrors(result));
        }

        outputStream.Flush();
        outputStream.Position = 0;

        var generatedAssembly = Assembly.Load(outputStream.ToArray());

        if (isCorvusType)
        {
            return typeof(JsonAny).Assembly.ExportedTypes.Single(t => t.FullName == rootTypeName);
        }

        return generatedAssembly.ExportedTypes.Single(t => t.FullName == rootTypeName);
    }
#endif

    private static string BuildCompilationErrors(EmitResult result)
    {
        var builder = new StringBuilder();
        foreach (Diagnostic diagnostic in result.Diagnostics)
        {
            builder.AppendLine(diagnostic.ToString());
        }

        return builder.ToString();
    }

    private static (IEnumerable<MetadataReference> MetadataReferences, IEnumerable<string?> Defines) BuildMetadataReferencesAndDefines()
    {
        DependencyContext? ctx = DependencyContext.Default ?? DependencyContext.Load(typeof(JsonSchema).Assembly);
        return ctx is null
            ? throw new InvalidOperationException("Unable to find compilation context.")
            : ((IEnumerable<MetadataReference> MetadataReferences, IEnumerable<string?> Defines))(from l in ctx.CompileLibraries
                                                                                                  from r in l.ResolveReferencePaths()
                                                                                                  select MetadataReference.CreateFromFile(r),
               ctx.CompilationOptions.Defines.AsEnumerable().Union(["DYNAMIC_BUILD"]));
    }

    private static IEnumerable<SyntaxTree> ParseSyntaxTrees(IReadOnlyCollection<GeneratedCodeFile> generatedTypes, IEnumerable<string?> defines)
    {
        CSharpParseOptions parseOptions = CSharpParseOptions.Default
            .WithLanguageVersion(LanguageVersion.Preview)
            .WithPreprocessorSymbols(defines.Where(s => s is not null).Cast<string>());
        yield return CSharpSyntaxTree.ParseText(GlobalUsingStatements, options: parseOptions, path: "GlobalUsingStatements.cs");

        foreach (GeneratedCodeFile type in generatedTypes)
        {
            yield return CSharpSyntaxTree.ParseText(type.FileContent, options: parseOptions, path: type.FileName);
        }
    }

    /// <summary>
    /// Options for validation.
    /// </summary>
    public sealed class Options
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Options"/> class.
        /// </summary>
        /// <param name="additionalDocumentResolver">Any additional document resolver.</param>
        /// <param name="allowFileSystemAndHttpResolution">If <see langword="true"/> then FileSystem and HttpClient document resolvers will be available.</param>
        /// <param name="fallbackVocabulary">The fallback vocabulary (defaults to <see cref="Corvus.Json.CodeGeneration.Draft202012.VocabularyAnalyser.DefaultVocabulary"/>).</param>
        /// <param name="alwaysAssertFormat">If true, <c>format</c> will always be asserted, even for vocabularies that usually annotate.</param>
        public Options(
            IDocumentResolver? additionalDocumentResolver = null,
            bool allowFileSystemAndHttpResolution = true,
            IVocabulary? fallbackVocabulary = null,
            bool alwaysAssertFormat = true)
        {
            this.AdditionalDocumentResolver = additionalDocumentResolver;
            this.AllowFileSystemAndHttpResolution = allowFileSystemAndHttpResolution;
            this.FallbackVocabulary = fallbackVocabulary ?? CodeGeneration.Draft202012.VocabularyAnalyser.DefaultVocabulary;
            this.AlwaysAssertFormat = alwaysAssertFormat;
        }

        /// <summary>
        /// Gets the default options.
        /// </summary>
        public static Options Default { get; } = new();

        /// <summary>
        /// Gets any additional document resolver.
        /// </summary>
        public IDocumentResolver? AdditionalDocumentResolver { get; }

        /// <summary>
        /// Gets a value indicating whether FileSystem and HttpClient document resolvers will be available.
        /// </summary>
        public bool AllowFileSystemAndHttpResolution { get; }

        /// <summary>
        /// Gets the fallback vocabulary.
        /// </summary>
        public IVocabulary FallbackVocabulary { get; }

        /// <summary>
        /// Gets a value indicating whether <c>format</c> will always be asserted, even for vocabularies that usually annotate.
        /// </summary>
        public bool AlwaysAssertFormat { get; }
    }

#if NET8_0_OR_GREATER
    private class DynamicAssemblyLoadContext : AssemblyLoadContext
    {
        public DynamicAssemblyLoadContext()
            : base($"DynamicAssemblyLoadContext_{Guid.NewGuid():N}", isCollectible: true)
        {
        }
    }
#endif
}