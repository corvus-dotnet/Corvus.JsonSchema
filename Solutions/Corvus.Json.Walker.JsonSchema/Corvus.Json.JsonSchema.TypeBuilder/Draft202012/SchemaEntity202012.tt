<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Corvus.Json" #>

    <#
    if (!IsNested)
    {
    #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace <#= Namespace #>
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Text;
    using System.Text.Json;
    using System.Text.RegularExpressions;
    using Corvus.Json;

    <#
    }
    #>
    /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct <#= TypeDeclaration.DotnetTypeName #> :
    <#
    if(IsImplicitObject)
    {
    #>
        IJsonObject<<#= TypeDeclaration.DotnetTypeName #>>,
    <#
    }
    #>
    <#
    if(IsImplicitArray)
    {
    #>
        IJsonArray<<#= TypeDeclaration.DotnetTypeName #>>,
    <#
    }
    #>
    <#
    if(!IsImplicitObject && !IsImplicitArray)
    {
    #>
        IJsonValue,
    <#
    }
    #>
        IEquatable<<#= TypeDeclaration.DotnetTypeName #>>
    {

        <#
    if(HasPatternProperties)
    {
    #>

        <#
        foreach(var patternProperty in PatternProperties)
        {
        #>
        /// <summary>
        /// A pattern property matching <#=                Formatting.FormatLiteralOrNull(patternProperty.Pattern, true).Trim('"')#> producing a <see cref="<#= patternProperty.DotnetTypeName #>" />.
        /// </summary>
        public static Regex PatternProperty<#= PatternPropertySuffix(patternProperty) #> = new Regex(<#=                Formatting.FormatLiteralOrNull(patternProperty.Pattern, true) #>, RegexOptions.Compiled);

        <#
        }
        #>
    <#
    }
    #>

    <#
    if(HasProperties)
    {
    #>

        <#
        foreach(var property in Properties)
        {
        #>

        /// <summary>
        /// JSON property name for <see cref="<#= property.DotnetPropertyName #>"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> <#= property.DotnetPropertyName #>Utf8JsonPropertyName = new byte[] { <#= GetEncodedBytes(property.JsonPropertyName) #> };

        /// <summary>
        /// JSON property name for <see cref="<#= property.DotnetPropertyName #>"/>.
        /// </summary>
        public static readonly string <#= property.DotnetPropertyName #>JsonPropertyName = <#= Formatting.FormatLiteralOrNull(property.JsonPropertyName, true)#>;

        <#
        }
        #>

    <#
    }
    #>

    <#
    if(HasConstString)
    {
    #>
        private static readonly <#= TypeDeclaration.DotnetTypeName #> __CorvusConstValue = JsonAny.Parse(<#= ConstString #>);
    <#
    }
    else if(HasConstBoolean)
    {
    #>
        private static readonly <#= TypeDeclaration.DotnetTypeName #> __CorvusConstValue = JsonAny.Parse(<#= ConstBoolean #>);
    <#
    }
    else if(HasConstNumber)
    {
    #>
        private static readonly <#= TypeDeclaration.DotnetTypeName #> __CorvusConstValue = JsonAny.Parse(<#= ConstNumber #>);
    <#
    }
    else if(HasConstObject)
    {
    #>
        private static readonly <#= TypeDeclaration.DotnetTypeName #> __CorvusConstValue = JsonAny.Parse(<#= ConstObject #>);
    <#
    }
    else if(HasConstArray)
    {
    #>
        private static readonly <#= TypeDeclaration.DotnetTypeName #> __CorvusConstValue = JsonAny.Parse(<#= ConstArray #>);
    <#
    }
    else if(HasConstNull)
    {
    #>
        private static readonly <#= TypeDeclaration.DotnetTypeName #> __CorvusConstValue = JsonAny.Parse("null");
    <#
    }
    #>

    <#

    if(HasPattern)
    {
    #>
        private static readonly Regex __CorvusPatternExpression = new Regex(<#= Formatting.FormatLiteralOrNull(Pattern, true) #>, RegexOptions.Compiled);
    <#
    }
    #>

    <#
    if(HasDependentRequired)
    {
    #>
        private static readonly ImmutableDictionary<string, ImmutableArray<ReadOnlyMemory<byte>>> __CorvusDependentRequired = BuildDependentRequired();
    <#
    }
    #>

    <#
    if(HasDependentSchemas)
    {
    #>
        private static readonly ImmutableDictionary<string, PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>> __CorvusDependentSchema = CreateDependentSchemaValidators();
    <#
    }
    #>

    <#
    if(HasLocalProperties)
    {
    #>
        private static readonly ImmutableDictionary<string, PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>> __CorvusLocalProperties = CreateLocalPropertyValidators();
    <#
    }
    #>

    <#
    if(HasDefaults)
    {
    #>
        private static readonly ImmutableDictionary<string, JsonAny> __CorvusDefaults = BuildDefaults();
    <#
    }
    #>


    <#
    if(HasPatternProperties)
    {
    #>
        private static readonly ImmutableDictionary<Regex, PatternPropertyValidator> __CorvusPatternProperties = CreatePatternPropertiesValidators();
    <#
    }
    #>

        private readonly JsonElement jsonElementBacking;

    <#
    if(IsImplicitObject)
    {
    #>
        private readonly ImmutableDictionary<string, JsonAny>? objectBacking;
    <#
    }
    #>

    <#
    if(IsImplicitArray)
    {
    #>
        private readonly ImmutableList<JsonAny>? arrayBacking;
    <#
    }
    #>

    <#
    if(IsImplicitNumber)
    {
    #>
        private readonly double? numberBacking;
    <#
    }
    #>

    <#
    if(IsImplicitString)
    {
    #>
        private readonly string? stringBacking;
    <#
    }
    #>

    <#
    if(IsImplicitBoolean)
    {
    #>
        private readonly bool? booleanBacking;
    <#
    }
    #>

    <#
    if (HasConst)
    {
    #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        public <#= TypeDeclaration.DotnetTypeName #>()
        {
            this.jsonElementBacking = __CorvusConstValue.jsonElementBacking;
    <#
    if(IsImplicitObject)
    {
    #>
            this.objectBacking = __CorvusConstValue.objectBacking;
    <#
    }
    #>
    <#
    if(IsImplicitArray)
    {
    #>
            this.arrayBacking = __CorvusConstValue.arrayBacking;
    <#
    }
    #>
    <#
    if(IsImplicitNumber)
    {
    #>
            this.numberBacking = __CorvusConstValue.numberBacking;
    <#
    }
    #>
    <#
    if(IsImplicitString)
    {
    #>
            this.stringBacking = __CorvusConstValue.stringBacking;
    <#
    }
    #>
    <#
    if(IsImplicitBoolean)
    {
    #>
            this.booleanBacking = __CorvusConstValue.booleanBacking;
    <#
    }
    #>
        }

    <#
    }
    #>

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(JsonElement value)
        {
            this.jsonElementBacking = value;
    <#
    if(IsImplicitObject)
    {
    #>
            this.objectBacking = default;
    <#
    }
    #>
    <#
    if(IsImplicitArray)
    {
    #>
            this.arrayBacking = default;
    <#
    }
    #>
    <#
    if(IsImplicitNumber)
    {
    #>
            this.numberBacking = default;
    <#
    }
    #>
    <#
    if(IsImplicitString)
    {
    #>
            this.stringBacking = default;
    <#
    }
    #>
    <#
    if(IsImplicitBoolean)
    {
    #>
            this.booleanBacking = default;
    <#
    }
    #>
        }

    <#
    if(IsImplicitObject)
    {
    #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(ImmutableDictionary<string, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
        }
    <#
    }
    #>

    <#
    if(IsImplicitArray)
    {
    #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">An array list.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
            this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="jsonArray">The <see cref="JsonArray"/> from which to construct the value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(JsonArray jsonArray)
        {
            if (jsonArray.HasJsonElement)
            {
                this.jsonElementBacking = jsonArray.AsJsonElement;
                this.arrayBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.arrayBacking = jsonArray.AsItemsList;
            }

        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
        }
    <#
    }
    #>

    <#
    if(IsImplicitNumber)
    {
    #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="jsonNumber">The <see cref="JsonNumber"/> from which to construct the value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(JsonNumber jsonNumber)
        {
            if (jsonNumber.HasJsonElement)
            {
                this.jsonElementBacking = jsonNumber.AsJsonElement;
                this.numberBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.numberBacking = jsonNumber.GetDouble();
            }
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(double value)
        {
            this.jsonElementBacking = default;
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(int value)
        {
            this.jsonElementBacking = default;
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(float value)
        {
            this.jsonElementBacking = default;
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(long value)
        {
            this.jsonElementBacking = default;
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
            this.numberBacking = value;
        }
    <#
    }
    #>

    <#
    if(IsImplicitString)
    {
    #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(string value)
        {
            this.jsonElementBacking = default;
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
            this.stringBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(ReadOnlySpan<char> value)
        {
            this.jsonElementBacking = default;
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
            this.stringBacking = value.ToString();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(ReadOnlySpan<byte> value)
        {
            this.jsonElementBacking = default;
        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
            this.stringBacking = System.Text.Encoding.UTF8.GetString(value);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="jsonString">The <see cref="JsonString"/> from which to construct the value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(JsonString jsonString)
        {
            if (jsonString.HasJsonElement)
            {
                this.jsonElementBacking = jsonString.AsJsonElement;
                this.stringBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.stringBacking = jsonString;
            }

        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
            this.booleanBacking = default;
        <#
        }
        #>
        }
    <#
    }
    #>

    <#
    if(IsImplicitBoolean)
    {
    #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="jsonBoolean">The <see cref="JsonBoolean"/> from which to construct the value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(JsonBoolean jsonBoolean)
        {
            if (jsonBoolean.HasJsonElement)
            {
                this.jsonElementBacking = jsonBoolean.AsJsonElement;
                this.booleanBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.booleanBacking = jsonBoolean.GetBoolean();
            }

        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        }

                /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="boolean">The <see cref="bool"/> from which to construct the value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(bool boolean)
        {
            this.jsonElementBacking = default;
            this.booleanBacking = boolean;

        <#
        if(IsImplicitObject)
        {
        #>
            this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitArray)
        {
        #>
            this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
            this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
            this.stringBacking = default;
        <#
        }
        #>
        }

    <#
    }
    #>

    <# /* Implicit Constructors */ #>

    <#
    foreach (Conversion conversion in ConversionsViaConstructor)
    {
        if (conversion.IsBuiltInType)
        {
            continue;
        }
    #>
        /// <summary>
        /// Initializes a new instance of the <see cref="<#= TypeDeclaration.DotnetTypeName #>"/> struct.
        /// </summary>
        /// <param name="conversion">The <see cref="<#= conversion.FullyQualifiedDotnetTypeName #>"/> from which to construct the value.</param>
        public <#= TypeDeclaration.DotnetTypeName #>(<#= conversion.FullyQualifiedDotnetTypeName #> conversion)
        {
            if (conversion.HasJsonElement)
            {
                this.jsonElementBacking = conversion.AsJsonElement;
        <#
        if(IsImplicitObject)
        {
        #>
                this.objectBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitBoolean)
        {
        #>
                this.booleanBacking = default;
        <#
        }
        #>

        <#
        if(IsImplicitArray)
        {
        #>
                this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitNumber)
        {
        #>
                this.numberBacking = default;
        <#
        }
        #>
        <#
        if(IsImplicitString)
        {
        #>
                this.stringBacking = default;
        <#
        }
        #>
            }
            else
            {
                this.jsonElementBacking = default;
        <#
        if(conversion.IsObject)
        {
        #>
                if (conversion.ValueKind == JsonValueKind.Object)
                {
                    this.objectBacking = conversion;
                }
                else
                {
                    this.objectBacking = default;
                }
        <#
        }
        else if (IsImplicitObject)
        {
        #>
                this.objectBacking = default;
        <#
        }
        #>
        <#
        if(conversion.IsBoolean)
        {
        #>
                if (conversion.ValueKind == JsonValueKind.True || conversion.ValueKind == JsonValueKind.False)
                {
                    this.booleanBacking = conversion;
                }
                else
                {
                    this.booleanBacking = default;
                }
        <#
        }
        else if (IsImplicitBoolean)
        {
        #>
                this.booleanBacking = default;
        <#
        }
        #>

        <#
        if(conversion.IsArray)
        {
        #>
                if (conversion.ValueKind == JsonValueKind.Array)
                {
                    this.arrayBacking = conversion;
                }
                else
                {
                    this.arrayBacking = default;
                }
        <#
        }
        else if (IsImplicitArray)
        {
        #>
                this.arrayBacking = default;
        <#
        }
        #>
        <#
        if(conversion.IsNumber)
        {
        #>
                if (conversion.ValueKind == JsonValueKind.Number)
                {
                    this.numberBacking = conversion;
                }
                else
                {
                    this.numberBacking = default;
                }
        <#
        }
        else if (IsImplicitNumber)
        {
        #>
                this.numberBacking = default;
        <#
        }
        #>
        <#
        if(conversion.IsString)
        {
        #>
                if (conversion.ValueKind == JsonValueKind.String)
                {
                    this.stringBacking = conversion;
                }
                else
                {
                    this.stringBacking = default;
                }
        <#
        }
        else if (IsImplicitString)
        {
        #>
                this.stringBacking = default;
        <#
        }
        #>
            }
        }
    <#
    }
    #>


    <#
    if (IsImplicitArray)
    {
    #>
        /// <inheritdoc/>
        public int Length
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> items)
                {
                    return items.Count;
                }

                return this.jsonElementBacking.GetArrayLength();
            }
        }
    <#
    }
    #>

    <#
    foreach (Conversion conversion in ConversionsViaConstructor)
    {
        if (conversion.IsBuiltInType)
        {
            continue;
        }
    #>
        /// <summary>
        /// Gets the value as a <see cref="<#= conversion.FullyQualifiedDotnetTypeName #>" />.
        /// </summary>
        public <#= conversion.FullyQualifiedDotnetTypeName #> As<#= conversion.DotnetTypeName #>
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is a valid <see cref="<#= conversion.FullyQualifiedDotnetTypeName #>" />.
        /// </summary>
        public bool Is<#= conversion.DotnetTypeName #>
        {
            get
            {
                return ((<#= conversion.FullyQualifiedDotnetTypeName #>)this).Validate().IsValid;
            }
        }

    <#
    }
    #>

    <#
    if (HasIfThenElse)
    {
    #>
        <#
        if (HasThen)
        {
        #>
        /// <summary>
        /// Gets a value indicating whether this matches the If/Then type.
        /// </summary>
        public bool IsIfMatch<#=                ThenDotnetTypeName#>
        {
            get
            {
                return this.As<<#=                IfFullyQualifiedDotnetTypeName#>>().IsValid(); 
            }
        }

        /// <summary>
        /// Gets this as the matching type for the If/Then clause.
        /// </summary>
        public <#=ThenFullyQualifiedDotnetTypeName#> AsIfMatch<#=ThenDotnetTypeName#>
        {
            get
            {
                return this.As<<#=ThenFullyQualifiedDotnetTypeName#>>(); 
            }
        }

        <#
        }
        #>

        <#
        if (HasElse)
        {
        #>
        /// <summary>
        /// Gets a value indicating whether this matches the If/Else type.
        /// </summary>
        public bool IsElseMatch<#=ElseDotnetTypeName#>
        {
            get
            {
                return !this.As<<#=IfFullyQualifiedDotnetTypeName#>>().IsValid(); 
            }
        }

        /// <summary>
        /// Gets this as the matching type for the If/Else clause.
        /// </summary>
        public <#=ElseFullyQualifiedDotnetTypeName#> AsElseMatch<#=ElseDotnetTypeName#>
        {
            get
            {
                return this.As<<#=ElseFullyQualifiedDotnetTypeName#>>(); 
            }
        }
        <#
        }
        #>
    <#
    }
    #>

    <#
    if(HasProperties)
    {
    #>
        <#
        foreach(var property in Properties)
        {
        #>

        /// <summary>
        /// Gets <#= property.DotnetPropertyName #>.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public <#= property.Type.FullyQualifiedDotnetTypeName #> <#= property.DotnetPropertyName #>
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(<#= property.DotnetPropertyName #>JsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(<#= property.DotnetPropertyName #>Utf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  <#= property.Type.FullyQualifiedDotnetTypeName #>(result);
                    }
                }

                return default;
            }
        }

        <#
        }
        #>
    <#
    }
    #>
        /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    <#
    bool isFirstProperty = true;
    #>

    <#
    if (IsImplicitObject)
    {
    #>
            this.objectBacking is null
            
    <#
        isFirstProperty = false;
    }
    #>

    <#
    if (IsImplicitArray)
    {
    #>
        <#
        if (isFirstProperty)
        {
            isFirstProperty = false;
        }
        else
        {
        #>
            &&
        <#
        }
        #>
            this.arrayBacking is null
    <#
    }
    #>
    <#
    if (IsImplicitNumber)
    {
    #>
        <#
        if (isFirstProperty)
        {
            isFirstProperty = false;
        }
        else
        {
        #>
            &&
        <#
        }
        #>
            this.numberBacking is null
    <#
    }
    #>
    <#
    if (IsImplicitString)
    {
    #>
        <#
        if (isFirstProperty)
        {
            isFirstProperty = false;
        }
        else
        {
        #>
            &&
        <#
        }
        #>
            this.stringBacking is null
    <#
    }
    #>
    <#
    if (IsImplicitBoolean)
    {
    #>
        <#
        if (isFirstProperty)
        {
            isFirstProperty = false;
        }
        else
        {
        #>
            &&
        <#
        }
        #>
            this.booleanBacking is null
    <#
    }
    #>

    <#
    if (!IsImplicitObject && !IsImplicitArray && !IsImplicitNumber && !IsImplicitBoolean && !IsImplicitString)
    {
    #>
    true
    <#
    }
    #>
            ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    <#
    if (IsImplicitObject)
    {
    #>          
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    <#
    }
    #>

    <#
    if (IsImplicitArray)
    {
    #>
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return JsonArray.ItemsToJsonElement(arrayBacking);
                }
    <#
    }
    #>

    <#
    if (IsImplicitNumber)
    {
    #>
                if (this.numberBacking is double numberBacking)
                {
                    return JsonNumber.NumberToJsonElement(numberBacking);
                }

    <#
    }
    #>

    <#
    if (IsImplicitString)
    {
    #>
                if (this.stringBacking is string stringBacking)
                {
                    return JsonString.StringToJsonElement(stringBacking);
                }

    <#
    }
    #>

    <#
    if (IsImplicitBoolean)
    {
    #>
                if (this.booleanBacking is bool booleanBacking)
                {
                    return JsonBoolean.BoolToJsonElement(booleanBacking);
                }

    <#
    }
    #>

                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    <#
    if (IsImplicitObject)
    {
    #>
                if (this.objectBacking is ImmutableDictionary<string, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    <#
    }
    #>

    <#
    if (IsImplicitArray)
    {
    #>
                if (this.arrayBacking is ImmutableList<JsonAny>)
                {
                    return JsonValueKind.Array;
                }

    <#
    }
    #>

    <#
    if (IsImplicitNumber)
    {
    #>
                if (this.numberBacking is double)
                {
                    return JsonValueKind.Number;
                }

    <#
    }
    #>

    <#
    if (IsImplicitString)
    {
    #>
                if (this.stringBacking is string)
                {
                    return JsonValueKind.String;
                }

    <#
    }
    #>

    <#
    if (IsImplicitBoolean)
    {
    #>
                if (this.booleanBacking is bool booleanBacking)
                {
                    return booleanBacking ? JsonValueKind.True : JsonValueKind.False;
                }

    <#
    }
    #>

                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    <#
    if (IsImplicitObject)
    {
    #>
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    <#
    }
    #>

    <#
    if (IsImplicitArray)
    {
    #>
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonAny(arrayBacking);
                }

    <#
    }
    #>

    <#
    if (IsImplicitNumber)
    {
    #>
                if (this.numberBacking is double numberBacking)
                {
                    return new JsonAny(numberBacking);
                }

    <#
    }
    #>

    <#
    if (IsImplicitString)
    {
    #>
                if (this.stringBacking is string stringBacking)
                {
                    return new JsonAny(stringBacking);
                }

    <#
    }
    #>

    <#
    if (IsImplicitBoolean)
    {
    #>
                if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonAny(booleanBacking);
                }

    <#
    }
    #>

                return new JsonAny(this.jsonElementBacking);
            }
        }

    <#
    foreach(Conversion conversion in ConversionsViaConstructor)
    {
        if (conversion.IsBuiltInType)
        {
            continue;
        }
    #>
        /// <summary>
        /// Conversion from <see cref="<#= conversion.FullyQualifiedDotnetTypeName #>" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(<#= conversion.FullyQualifiedDotnetTypeName #> value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to <see cref="<#= conversion.FullyQualifiedDotnetTypeName #>" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= conversion.FullyQualifiedDotnetTypeName #>(<#= TypeDeclaration.DotnetTypeName #> value)
        {
        <#
        if(conversion.IsObject)
        {
        #>
            if (value.ValueKind == JsonValueKind.Object)
            {
                return new <#= conversion.FullyQualifiedDotnetTypeName #>(value.AsObject);
            }
        <#
        }
        #>
        <#
        if(conversion.IsArray)
        {
        #>
            if (value.ValueKind == JsonValueKind.Array)
            {
                return new <#= conversion.FullyQualifiedDotnetTypeName #>(value.AsArray);
            }
        <#
        }
        #>
        <#
        if(conversion.IsString)
        {
        #>
            if (value.ValueKind == JsonValueKind.String)
            {
                return new <#= conversion.FullyQualifiedDotnetTypeName #>(value.AsString);
            }
        <#
        }
        #>
        <#
        if(conversion.IsBoolean)
        {
        #>
            if (value.ValueKind == JsonValueKind.True || value.ValueKind == JsonValueKind.False)
            {
                return new <#= conversion.FullyQualifiedDotnetTypeName #>(value.AsBoolean);
            }
        <#
        }
        #>
        <#
        if(conversion.IsNumber)
        {
        #>
            if (value.ValueKind == JsonValueKind.Number)
            {
                return new <#= conversion.FullyQualifiedDotnetTypeName #>(value.AsNumber);
            }
        <#
        }
        #>
            return default;
        }
    <#
    }
    #>

        <#
    foreach(Conversion conversion in ConversionsViaCast)
    {
    #>
        /// <summary>
        /// Conversion from <see cref="<#= conversion.FullyQualifiedDotnetTypeName #>" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(<#= conversion.FullyQualifiedDotnetTypeName #> value)
        {
            return (<#= conversion.ConvertViaDotnetTypeName #>)value;
        }

        /// <summary>
        /// Conversion to <see cref="<#= conversion.FullyQualifiedDotnetTypeName #>" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= conversion.FullyQualifiedDotnetTypeName #>(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return (<#= conversion.ConvertViaDotnetTypeName #>)value;
        }
    <#
    }
    #>

        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new <#= TypeDeclaration.DotnetTypeName #>(value.AsJsonElement);
            }

            return value.As<<#= TypeDeclaration.DotnetTypeName #>>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return value.AsAny;
        }

    <#
    if (IsImplicitArray)
    {
    #>

        /// <summary>
        /// Conversion from array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(JsonArray value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonArray(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return value.AsArray;
        }
       
        /// <summary>
        /// Implicit conversion to an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return value.AsArray.AsItemsList;
        }

        /// <summary>
        /// Implicit conversion from an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(ImmutableList<JsonAny> value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }
    <#
    }
    #>

    <#
    if (IsImplicitObject)
    {
    #>

        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(JsonObject value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<string, JsonAny>(<#= TypeDeclaration.DotnetTypeName #>  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #> (ImmutableDictionary<string, JsonAny> value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #> (value);
        }

    <#
    }
    #>

    <#
    if (IsImplicitString)
    {
    #>

        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(string value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator string(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(ReadOnlySpan<char> value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator ReadOnlySpan<char>(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from utf8 bytes.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(ReadOnlySpan<byte> value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to utf8 bytes.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator ReadOnlySpan<byte>(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(JsonString value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonString(<#= TypeDeclaration.DotnetTypeName #> value)
        {
            return value.AsString;
        }

    <#
    }
    #>

    <#
    if (IsImplicitNumber)
    {
    #>

        /// <summary>
        /// Conversion from double.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(double value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to double.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator double(<#= TypeDeclaration.DotnetTypeName #> number)
        {
            return number.AsNumber.GetDouble();
        }

        /// <summary>
        /// Conversion from float.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(float value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to float.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator float(<#= TypeDeclaration.DotnetTypeName #> number)
        {
            return number.AsNumber.GetSingle();
        }

        /// <summary>
        /// Conversion from long.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(long value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to long.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator long(<#= TypeDeclaration.DotnetTypeName #> number)
        {
            return number.AsNumber.GetInt64();
        }

        /// <summary>
        /// Conversion from int.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(int value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to int.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator int(<#= TypeDeclaration.DotnetTypeName #> number)
        {
            return number.AsNumber.GetInt32();
        }

        /// <summary>
        /// Conversion from number.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(JsonNumber value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to number.
        /// </summary>
        /// <param name="number">The value from which to convert.</param>
        public static implicit operator JsonNumber(<#= TypeDeclaration.DotnetTypeName #> number)
        {
            return number.AsNumber;
        }

    <#
    }
    #>

    <#
    if (IsImplicitBoolean)
    {
    #>

        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(bool value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator bool(<#= TypeDeclaration.DotnetTypeName #> boolean)
        {
            return boolean.AsBoolean.GetBoolean();
        }

        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator <#= TypeDeclaration.DotnetTypeName #>(JsonBoolean value)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator JsonBoolean(<#= TypeDeclaration.DotnetTypeName #> boolean)
        {
            return boolean.AsBoolean;
        }

    <#
    }
    #>

        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(<#= TypeDeclaration.DotnetTypeName #> lhs, <#= TypeDeclaration.DotnetTypeName #> rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(<#= TypeDeclaration.DotnetTypeName #> lhs, <#= TypeDeclaration.DotnetTypeName #> rhs)
        {
            return !lhs.Equals(rhs);
        }

    <#
    if (IsImplicitArray)
    {
    #>
        <#
        if (CanEnumerateAsSpecificType)
        {
        #>
        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="items">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(params <#= SingleItemsDotnetTypeName #>[] items)
        {
            var builder = ImmutableList.CreateBuilder<JsonAny>();
            foreach (var item in items)
            {
                builder.Add(item);
            }

            return new <#= TypeDeclaration.DotnetTypeName #>(builder.ToImmutable());
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(<#= SingleItemsDotnetTypeName #> item1)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(ImmutableList.Create((JsonAny)item1));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(<#= SingleItemsDotnetTypeName #> item1, <#= SingleItemsDotnetTypeName #> item2)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(ImmutableList.Create((JsonAny)item1, (JsonAny)item2));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(<#= SingleItemsDotnetTypeName #> item1, <#= SingleItemsDotnetTypeName #> item2, <#= SingleItemsDotnetTypeName #> item3)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(ImmutableList.Create((JsonAny)item1, (JsonAny)item2, (JsonAny)item3));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <param name="item4">The fourth item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(<#= SingleItemsDotnetTypeName #> item1, <#= SingleItemsDotnetTypeName #> item2, <#= SingleItemsDotnetTypeName #> item3, <#= SingleItemsDotnetTypeName #> item4)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(ImmutableList.Create((JsonAny)item1, (JsonAny)item2, (JsonAny)item3, (JsonAny)item4));
        }
        <#
        }
        else
        {
        #>
                /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="items">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(params JsonAny[] items)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(items.ToImmutableList());
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(JsonAny item1)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(ImmutableList.Create(item1));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(JsonAny item1, JsonAny item2)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(ImmutableList.Create(item1, item2));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(JsonAny item1, JsonAny item2, JsonAny item3)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(ImmutableList.Create(item1, item2, item3));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <param name="item4">The fourth item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static <#= TypeDeclaration.DotnetTypeName #> From(JsonAny item1, JsonAny item2, JsonAny item3, JsonAny item4)
        {
            return new <#= TypeDeclaration.DotnetTypeName #>(ImmutableList.Create(item1, item2, item3, item4));
        }
        <#
        }
        #>

    <#
    }
    #>

    <#
    if (HasProperties)
    {
    #>
        /// <summary>
        /// Creates an instance of a <see cref="<#= TypeDeclaration.DotnetTypeName #>"/>.
        /// </summary>
        public static <#= TypeDeclaration.DotnetTypeName #> Create(
        <#
        bool isFirstCreateParameter = true;
        foreach(var property in RequiredAllOfAndRefProperties)
        {
            if (!IsConst(property.Type))
            {           
                if (isFirstCreateParameter)
                {
                    isFirstCreateParameter = false;
                }
                else
                {
        #>, <#
                }
        #>
           <#= property.Type.FullyQualifiedDotnetTypeName #> <#= property.DotnetParameterName #>
        <#
            }
        }
        #>
        <#
        foreach(var property in OptionalAllOfAndRefProperties)
        {
            if (isFirstCreateParameter)
            {
                isFirstCreateParameter = false;
            }
            else
            {
        #>, <#
            }
        #>
            <#= property.Type.FullyQualifiedDotnetTypeName #>? <#= property.DotnetParameterName #> = null
        <#
        }
        #>

        )
        {
            var builder = ImmutableDictionary.CreateBuilder<string, JsonAny>();
        <#
        foreach(var property in RequiredAllOfAndRefProperties)
        {
            if (IsConst(property.Type))
            {
        #>
            builder.Add(<#= property.DotnetPropertyName#>JsonPropertyName, new <#= property.Type.FullyQualifiedDotnetTypeName #>());
        <#
            }
            else
            {
        #>
            builder.Add(<#= property.DotnetPropertyName#>JsonPropertyName, <#= property.DotnetParameterName #>);
        <#
            }
        }
        #>
        <#
        foreach(var property in OptionalAllOfAndRefProperties)
        {
        #>
            if (<#= property.DotnetParameterName #> is <#= property.Type.FullyQualifiedDotnetTypeName #> <#= property.DotnetParameterName #>__)
            {
                builder.Add(<#= property.DotnetPropertyName#>JsonPropertyName, <#= property.DotnetParameterName #>__);
            }            
        <#
        }
        #>
            return builder.ToImmutable();
        }

        <#
        foreach(var property in Properties)
        {
            if (IsConst(property.Type))
            {
                continue;
            }
        #>

        /// <summary>
        /// Sets <#= Formatting.FormatLiteralOrNull(property.JsonPropertyName, true).Trim('"') #>.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public <#= TypeDeclaration.DotnetTypeName #> With<#= property.DotnetPropertyName #>(<#= property.Type.FullyQualifiedDotnetTypeName #> value)
        {
            return this.SetProperty(<#= property.DotnetPropertyName #>JsonPropertyName, value);
        }

        <#
        }
        #>

    <#
    }
    #>

        /// <inheritdoc/>
        public override string ToString()
        {
            return this.Serialize();
        }

        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
    <#
    if (IsImplicitObject)
    {
    #>
                JsonValueKind.Object => this.AsObject.GetHashCode(),
    <#
    }
    else
    {
    #>
                JsonValueKind.Object => this.AsObject().GetHashCode(),
    <#
    }
    #>
    <#
    if (IsImplicitArray)
    {
    #>
                JsonValueKind.Array => this.AsArray.GetHashCode(),
    <#
    }
    else
    {
    #>
                JsonValueKind.Array => this.AsArray().GetHashCode(),
    <#
    }
    #>
    <#
    if (IsImplicitNumber)
    {
    #>
                JsonValueKind.Number => this.AsNumber.GetHashCode(),
    <#
    }
    else
    {
    #>
                JsonValueKind.Number => this.AsNumber().GetHashCode(),
    <#
    }
    #>
    <#
    if (IsImplicitString)
    {
    #>
                JsonValueKind.String => this.AsString.GetHashCode(),
    <#
    }
    else
    {
    #>
                JsonValueKind.String => this.AsString().GetHashCode(),
    <#
    }
    #>
    <#
    if (IsImplicitBoolean)
    {
    #>
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
    <#
    }
    else
    {
    #>
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
    <#
    }
    #>
                JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    <#
    if (IsImplicitObject)
    {
    #>
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    <#
    }
    #>

    <#
    if (IsImplicitArray)
    {
    #>
            if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
            {
                JsonArray.WriteItems(arrayBacking, writer);
                return;
            }

    <#
    }
    #>

    <#
    if (IsImplicitNumber)
    {
    #>
            if (this.numberBacking is double numberBacking)
            {
                writer.WriteNumberValue(numberBacking);
                return;
            }

    <#
    }
    #>

    <#
    if (IsImplicitString)
    {
    #>
            if (this.stringBacking is string stringBacking)
            {
                writer.WriteStringValue(stringBacking);
                return;
            }

    <#
    }
    #>

    <#
    if (IsImplicitBoolean)
    {
    #>
            if (this.booleanBacking is bool booleanBacking)
            {
                writer.WriteBooleanValue(booleanBacking);
                return;
            }
    <#
    }
    #>

            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    <#
    if (IsImplicitObject)
    {
    #>

        <#
        if (HasAdditionalPropertiesObject && !HasUnevaluatedPropertiesObject)
        {
        #>
        /// <summary>
        /// Enumerate the object as the given item type
        /// </summary>
        public JsonObjectEnumerator<<#= AdditionalPropertiesDotnetTypeName #>> EnumerateProperties()
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return new JsonObjectEnumerator<<#= AdditionalPropertiesDotnetTypeName #>>(properties);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return new JsonObjectEnumerator<<#= AdditionalPropertiesDotnetTypeName #>>(this.jsonElementBacking);
            }

            return default;

        }
        <#
        }
        #>

        <#
        if (!HasAdditionalPropertiesObject && HasUnevaluatedPropertiesObject)
        {
        #>
        /// <summary>
        /// Enumerate the object as the given item type
        /// </summary>
        public JsonObjectEnumerator<<#= UnevaluatedPropertiesDotnetTypeName #>> EnumerateProperties()
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return new JsonObjectEnumerator<<#= UnevaluatedPropertiesDotnetTypeName #>>(properties);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return new JsonObjectEnumerator<<#= UnevaluatedPropertiesDotnetTypeName #>>(this.jsonElementBacking);
            }

            return default;

        }
        <#
        }
        #>

        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    <#
    }
    #>

    <#
    if (IsImplicitArray)
    {
    #>

        <#
        if (CanEnumerateAsSpecificType)
        {
        #>
        /// <summary>
        /// Enumerate the items in the array as a <see cref="<#= SingleItemsDotnetTypeName #>" />.
        /// </summary>
        public JsonArrayEnumerator<<#= SingleItemsDotnetTypeName #>> EnumerateItems()
        {
            if (this.arrayBacking is ImmutableList<JsonAny> items)
            {
                return new JsonArrayEnumerator<<#= SingleItemsDotnetTypeName #>>(items);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return new JsonArrayEnumerator<<#= SingleItemsDotnetTypeName #>>(this.jsonElementBacking);
            }

            return default;
        }
        <#
        }
        #>
        /// <inheritdoc/>
        public JsonArrayEnumerator EnumerateArray()
        {
            return this.AsArray.EnumerateArray();
        }
    <#
    }
    #>

    <#
    if (IsImplicitObject)
    {
    #>

        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        <#
        if (HasDefaults)
        {
        #>
        /// <inheritdoc/>
        public bool TryGetDefault(string name, out JsonAny value)
        {
            return __CorvusDefaults.TryGetValue(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<char> name, out JsonAny value)
        {
            return __CorvusDefaults.TryGetValue(name.ToString(), out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return __CorvusDefaults.TryGetValue(System.Text.Encoding.UTF8.GetString(utf8name), out value);
        }

        /// <inheritdoc/>
        public bool HasDefault(string name)
        {
            return __CorvusDefaults.TryGetValue(name, out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<char> name)
        {
            return __CorvusDefaults.TryGetValue(name.ToString(), out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<byte> utf8name)
        {
            return __CorvusDefaults.TryGetValue(System.Text.Encoding.UTF8.GetString(utf8name), out _);
        }

        <#
        }
        #>

    <#
    }
    #>

        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
    <#
    if (IsImplicitObject)
    {
    #>
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
    <#
    }
    else
    {
    #>
                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
    <#
    }
    #>
    <#
    if (IsImplicitArray)
    {
    #>
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
    <#
    }
    else
    {
    #>
                JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
    <#
    }
    #>
    <#
    if (IsImplicitNumber)
    {
    #>
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
    <#
    }
    else
    {
    #>
                JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
    <#
    }
    #>
    <#
    if (IsImplicitString)
    {
    #>
                JsonValueKind.String => this.AsString.Equals(other.AsString()),
    <#
    }
    else
    {
    #>
                JsonValueKind.String => this.AsString().Equals(other.AsString()),
    <#
    }
    #>
    <#
    if (IsImplicitBoolean)
    {
    #>
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
    <#
    }
    else
    {
    #>
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
    <#
    }
    #>
                JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(<#= TypeDeclaration.DotnetTypeName #> other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                <#
    if (IsImplicitObject)
    {
    #>
                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
    <#
    }
    else
    {
    #>
                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
    <#
    }
    #>
    <#
    if (IsImplicitArray)
    {
    #>
                JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
    <#
    }
    else
    {
    #>
                JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
    <#
    }
    #>
    <#
    if (IsImplicitNumber)
    {
    #>
                JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
    <#
    }
    else
    {
    #>
                JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
    <#
    }
    #>
    <#
    if (IsImplicitString)
    {
    #>
                JsonValueKind.String => this.AsString.Equals(other.AsString),
    <#
    }
    else
    {
    #>
                JsonValueKind.String => this.AsString().Equals(other.AsString()),
    <#
    }
    #>
    <#
    if (IsImplicitBoolean)
    {
    #>
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
    <#
    }
    else
    {
    #>
                JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
    <#
    }
    #>
                JsonValueKind.Null => true,
                _ => false,
            };
        }

    <#
    if (IsImplicitObject)
    {
    #>

        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name.ToString(), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(System.Text.Encoding.UTF8.GetString(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> SetProperty<TValue>(string name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    <#
    }
    #>

    <#
    if (IsImplicitArray)
    {
    #>

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> Add<TItem>(TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> Add<TItem1, TItem2>(TItem1 item1, TItem2 item2)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> Add<TItem1, TItem2, TItem3>(TItem1 item1, TItem2 item2, TItem3 item3)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> Add<TItem1, TItem2, TItem3, TItem4>(TItem1 item1, TItem2 item2, TItem3 item3, TItem4 item4)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
            where TItem4 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3, item4);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> Add<TItem>(params TItem[] items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> AddRange<TItem>(IEnumerable<TItem> items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.AddRange(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> Insert<TItem>(int index, TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Insert(index, item);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> Replace<TItem>(TItem oldValue, TItem newValue)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.Replace(oldValue, newValue);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> RemoveAt(int index)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveAt(index);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> RemoveRange(int index, int count)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveRange(index, count);
            }

            return this;
        }

        /// <inheritdoc/>
        public <#= TypeDeclaration.DotnetTypeName #> SetItem<TItem>(int index, TItem value)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.SetItem(index, value);
            }

            return this;
        }

    <#
    }
    #>

        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<<#= TypeDeclaration.DotnetTypeName #>, T>();
        }


    <#
    if(HasPatternProperties)
    {
    #>

        <#
        foreach(var patternProperty in PatternProperties)
        {
        #>
        /// <summary>
        /// Determines if a property matches <#=                Formatting.FormatLiteralOrNull(patternProperty.Pattern, true).Trim('"')#> producing a <see cref="<#= patternProperty.DotnetTypeName #>" />.
        /// </summary>
        public bool MatchesPattern<#= PatternPropertySuffix(patternProperty) #>(in Property property)
        {
            return PatternProperty<#= PatternPropertySuffix(patternProperty) #>.IsMatch(property.Name);
        }

        /// <summary>
        /// Get a property as the matching property type <#=                Formatting.FormatLiteralOrNull(patternProperty.Pattern, true).Trim('"')#> as a <see cref="<#= patternProperty.DotnetTypeName #>" />.
        /// </summary>
        public <#= patternProperty.DotnetTypeName #> AsPattern<#= PatternPropertySuffix(patternProperty) #>(in Property property)
        {
            return property.ValueAs<<#= patternProperty.DotnetTypeName #>>();
        }

        <#
        }
        #>
    <#
    }
    #>

        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        <#
        if (HasAdditionalProperties || HasUnevaluatedProperties)
        {
        #>
            result = result.UsingEvaluatedProperties();
        <#
        }
        #>

        <#
        if (HasUnevaluatedItems)
        {
        #>
            result = result.UsingEvaluatedItems();
        <#
        }
        #>


    <#
    if (HasRef)
    {    
    #>
            result = this.ValidateRef(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    <#
    }
    #>

    <#
    if ((HasExplicitType || HasFormat || HasMediaTypeOrEncoding) || (HasItems || HasContains || HasUniqueItems || HasMaxItems || HasMinItems || HasUnevaluatedItems || HasPrefixItems) || (HasDependentRequired || HasLocalProperties || HasRequired || HasMaxProperties || HasMinProperties || HasDependentSchemas || HasPropertyNames || HasPatternProperties || ((AllowsAdditionalProperties && (HasAdditionalProperties || HasUnevaluatedProperties)))))
    {
    #>
            JsonValueKind valueKind = this.ValueKind;
    <#
    }
    #>

    <#
    if (HasExplicitType || HasFormat || HasMediaTypeOrEncoding)
    {
    #>

        <#
        if (HasExplicitType)
        {
        #>
            result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        <#
        }
        #>

        <#
        if (HasFormat)
        {
        #>
            result = this.ValidateFormat(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        <#
        }
        #>

        
        <#
        if (HasMediaTypeOrEncoding)
        {
        #>
            result = this.ValidateMediaTypeAndEncoding(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        <#
        }
        #>

    <#
    }
    #>

    <#
    if (HasConst)
    {
    #>
            result = Corvus.Json.Validate.ValidateConst(this, result, level, __CorvusConstValue);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    <#
    }
    #>

    <#
    if (HasEnum)
    {
    #>
            result = Corvus.Json.Validate.ValidateEnum(
                this,
                result,
                level
        <#
        for(int enumIndex = 0; enumIndex < EnumValues.Length; ++enumIndex)
        {
        #>
                , EnumValues.Item<#= enumIndex #>
        <#
        }
        #>
                );

            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    <#
    }
    #>

    <#
    if (HasMultipleOf || HasMaximum || HasExclusiveMaximum|| HasMinimum || HasExclusiveMinimum)
    {
    #>
            result = Corvus.Json.Validate.ValidateNumber(
                this,
                result,
                level,
        <#
        if (HasMultipleOf)
        {
        #>
                <#= MultipleOf #>,
        <#
        }
        else
        {
        #>
                null,
        <#
        }
        #>
        <#
        if (HasMaximum)
        {
        #>
                 <#= Maximum #>,
        <#
        }
        else
        {
        #>
                null,
        <#
        }
        #>
        <#
        if (HasExclusiveMaximum)
        {
        #>
                 <#= ExclusiveMaximum #>,
        <#
        }
        else
        {
        #>
                null,
        <#
        }
        #>
        <#
        if (HasMinimum)
        {
        #>
                 <#= Minimum #>,
        <#
        }
        else
        {
        #>
                null,
        <#
        }
        #>
        <#
        if (HasExclusiveMinimum)
        {
        #>
                 <#= ExclusiveMinimum #>
        <#
        }
        else
        {
        #>
                null
        <#
        }
        #>
                );

            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    <#
    }
    #>
    
    <#
    if (HasMaxLength || HasMinLength || HasPattern)
    {
    #>
            result = Corvus.Json.Validate.ValidateString(
                this,
                result,
                level,
        <#
        if (HasMaxLength)
        {
        #>
                 <#= MaxLength #>,
        <#
        }
        else
        {
        #>
                null,
        <#
        }
        #>
        <#
        if (HasMinLength)
        {
        #>
                 <#= MinLength #>,
        <#
        }
        else
        {
        #>
                null,
        <#
        }
        #>
        <#
        if (HasPattern)
        {
        #>
                __CorvusPatternExpression
        <#
        }
        else
        {
        #>
                null
        <#
        }
        #>
                );

            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    <#
    }
    #>

    <#
    if (HasIfThenElse)
    {
    #>
            result = this.ValidateIfThenElse(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    <#
    }
    #>

    <#
    if (HasNot)
    {
    #>
            result = this.ValidateNot(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    <#
    }
    #>

    <#
    if (HasAllOf)
    {
    #>
            result = this.ValidateAllOf(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    <#
    }
    #>

    <#
    if (HasAnyOf)
    {
    #>
            result = this.ValidateAnyOf(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    <#
    }
    #>

    <#
    if (HasOneOf)
    {
    #>
            result = this.ValidateOneOf(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    <#
    }
    #>

    <#
    if (HasDependentRequired || HasLocalProperties || HasRequired || HasMaxProperties || HasMinProperties || HasDependentSchemas || HasPropertyNames || HasPatternProperties || ((AllowsAdditionalProperties && (HasAdditionalProperties || HasUnevaluatedProperties)) || !AllowsAdditionalProperties))
    {
    #>
            result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    <#
    }
    #>


    <#
    if (HasItems || HasContains || HasUniqueItems || HasMaxItems || HasMinItems || HasUnevaluatedItems || HasPrefixItems)
    {
    #>
            result = this.ValidateArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    <#
    }
    #>
            return result;
        }

    <#
    if (IsImplicitObject)
    {
    #>
        /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        private JsonObject AsObject
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

                return new JsonObject(this.jsonElementBacking);
            }
        }
    <#
    }
    #>

    <#
    if (IsImplicitArray)
    {
    #>
        /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        private JsonArray AsArray
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonArray(arrayBacking);
                }

                return new JsonArray(this.jsonElementBacking);
            }
        }
    <#
    }
    #>

    <#
    if (IsImplicitNumber)
    {
    #>
        /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        private JsonNumber AsNumber
        {
            get
            {
                if (this.numberBacking is double numberBacking)
                {
                    return new JsonNumber(numberBacking);
                }

                return new JsonNumber(this.jsonElementBacking);
            }
        }
    <#
    }
    #>

    <#
    if (IsImplicitString)
    {
    #>
        /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        private JsonString AsString
        {
            get
            {
                if (this.stringBacking is string stringBacking)
                {
                    return new JsonString(stringBacking);
                }

                return new JsonString(this.jsonElementBacking);
            }
        }
    <#
    }
    #>

    <#
    if (IsImplicitBoolean)
    {
    #>
        /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        private JsonBoolean AsBoolean
        {
            get
            {
                if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonBoolean(booleanBacking);
                }

                return new JsonBoolean(this.jsonElementBacking);
            }
        }
    <#
    }
    #>

    <#
    if (HasPatternProperties)
    {
    #>
        private static ImmutableDictionary<Regex, PatternPropertyValidator> CreatePatternPropertiesValidators()
        {
            ImmutableDictionary<Regex, PatternPropertyValidator>.Builder builder =
                ImmutableDictionary.CreateBuilder<Regex, PatternPropertyValidator>();

        <#
        foreach (var patternProperty in PatternProperties)
        {
        #>
            builder.Add(
                PatternProperty<#= PatternPropertySuffix(patternProperty) #>,__CorvusValidatePatternProperty<#= PatternPropertySuffix(patternProperty) #>);
        <#
        }
        #>

            return builder.ToImmutable();
        }

        <#
        foreach (var patternProperty in PatternProperties)
        {
        #>
        private static ValidationContext __CorvusValidatePatternProperty<#= PatternPropertySuffix(patternProperty) #>(in Property that, in ValidationContext validationContext, ValidationLevel level)
        {
            return that.ValueAs<<#= patternProperty.DotnetTypeName #>>().Validate(validationContext, level);
        }
        <#
        }
        #>

    <#
    }
    #>

    <#
    if (HasDependentSchemas)
    {
    #>

        private static ImmutableDictionary<string, PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>> CreateDependentSchemaValidators()
        {
            ImmutableDictionary<string, PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>>.Builder builder =
                ImmutableDictionary.CreateBuilder<string, PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>>();

        <#
        int dsIndex = 0;
        foreach (var dependentSchema in DependentSchemas)
        {
            dsIndex++;
        #>
            builder.Add(
                "<#= dependentSchema.Name #>", __CorvusValidateDependentSchema<#= dsIndex #>);

        <#
        }
        #>
            return builder.ToImmutable();
        }

        <#
        int dsIndexV = 0;
        foreach (var dependentSchema in DependentSchemas)
        {
            dsIndexV++;
        #>
        private static ValidationContext __CorvusValidateDependentSchema<#= dsIndexV #>(in <#= TypeDeclaration.DotnetTypeName #> that, in ValidationContext validationContext, ValidationLevel level)
        {
            return that.As<<#= dependentSchema.DotnetTypeName #>>().Validate(validationContext, level);
        }
        <#
        }
        #>

    <#
    }
    #>

    <#
    if (HasDefaults)
    {
    #>
        private static ImmutableDictionary<string, JsonAny> BuildDefaults()
        {
            ImmutableDictionary<string, JsonAny>.Builder builder =
                ImmutableDictionary.CreateBuilder<string, JsonAny>();

        <#
        foreach (var property in Defaults)
        {
        #>
            builder.Add(<#= property.DotnetPropertyName #>JsonPropertyName, JsonAny.Parse(<#= Formatting.FormatLiteralOrNull(property.DefaultValue, true) #>));
        <#
        }
        #>
            return builder.ToImmutable();
        }
    <#
    }
    #>

    <#
    if (HasDependentRequired)
    {
    #>

        private static ImmutableDictionary<string, ImmutableArray<ReadOnlyMemory<byte>>> BuildDependentRequired()
        {
            ImmutableDictionary<string, ImmutableArray<ReadOnlyMemory<byte>>>.Builder builder =
                ImmutableDictionary.CreateBuilder<string, ImmutableArray<ReadOnlyMemory<byte>>>();

        <#
        foreach (var dependentRequired in DependentRequired)
        {
        #>
            builder.Add(
                    <#= Formatting.FormatLiteralOrNull(dependentRequired.Name, true) #>,
                    ImmutableArray.Create<ReadOnlyMemory<byte>>(
            <#
            bool isFirst1 = true;
            foreach (var dependentRequiredValue in dependentRequired.RequiredNames)
            {
            #>
                <#
                if (isFirst1)
                {
                    isFirst1 = false;
                #>
                        System.Text.Encoding.UTF8.GetBytes(<#=  Formatting.FormatLiteralOrNull(dependentRequiredValue, true) #>).AsMemory()
                <#
                }
                else
                {
                #>
                        , System.Text.Encoding.UTF8.GetBytes(<#=  Formatting.FormatLiteralOrNull(dependentRequiredValue, true) #>).AsMemory()
                <#
                }
                #>
            <#
            }
            #>
                        ));
        <#
        }
        #>
            return builder.ToImmutable();
        }

    <#
    }
    #>

    <#
    if (HasLocalProperties)
    {
    #>

        private static ImmutableDictionary<string, PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>> CreateLocalPropertyValidators()
        {
            ImmutableDictionary<string, PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>>.Builder builder =
                ImmutableDictionary.CreateBuilder<string, PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>>();

        <#
        foreach (var property in LocalProperties)
        {
        #>
            builder.Add(
                <#= property.DotnetPropertyName #>JsonPropertyName, __CorvusValidate<#= property.DotnetPropertyName #>);
        <#
        }
        #>

            return builder.ToImmutable();
        }

        <#
        foreach (var property in LocalProperties)
        {
        #>
        private static ValidationContext __CorvusValidate<#= property.DotnetPropertyName #>(in <#= TypeDeclaration.DotnetTypeName #> that, in ValidationContext validationContext, ValidationLevel level)
        {
            <#= property.Type.FullyQualifiedDotnetTypeName #> property = that.<#= property.DotnetPropertyName #>;
            return property.Validate(validationContext, level);
        }
        <#
        }
        #>
    <#
    }
    #>

    <#
    if (HasRef)
    {
    #>
        private ValidationContext ValidateRef(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            ValidationContext refResult = this.As<<#= RefDotnetTypeName #>>().Validate(validationContext.CreateChildContext(), level);

            if (!refResult.IsValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = validationContext.MergeResults(false, level, refResult);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = validationContext.MergeResults(false, level, refResult);
                }
                else
                {
                    result = validationContext.WithResult(isValid: false);
                }
            }
            else
            {
                if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, refResult);
                }

                result = result.MergeChildContext(refResult, false);
            }

            return result;
        }
    <#
    }
    #>

    <#
    if (HasItems || HasContains || HasUniqueItems || HasMaxItems || HasMinItems || HasUnevaluatedItems || HasPrefixItems)
    {
    #>
        private ValidationContext ValidateArray(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Array)
            {
                return result;
            }

         <#
        if (HasItems || HasContains || HasUniqueItems || HasUnevaluatedItems || HasPrefixItems)
        {
         #>

            int arrayLength = 0;
         <#
        }
        else
        {
        #>
            int arrayLength = this.Length;
        <#
        }
        #>

        <#
        if (HasContains)
        {
        #>
            int containsCount = 0;

        <#
        }

        #>

         <#
        if (HasItems || HasContains || HasUniqueItems || HasUnevaluatedItems || HasPrefixItems)
        {
         #>
            JsonArrayEnumerator arrayEnumerator = this.EnumerateArray();

            while (arrayEnumerator.MoveNext())
            {
        <#
            if (HasUniqueItems)
            {
        #>
                JsonArrayEnumerator innerEnumerator = this.EnumerateArray();
                int innerIndex = -1;
                while (innerIndex < arrayLength && innerEnumerator.MoveNext())
                {
                    innerIndex++;
                }

                while (innerEnumerator.MoveNext())
                {
                    if (innerEnumerator.Current.Equals(arrayEnumerator.Current))
                    {
                        if (level >= ValidationLevel.Detailed)
                        {
                            result = result.WithResult(isValid: false, $"6.4.3. uniqueItems - duplicate items were found at indices {arrayLength} and {innerIndex}.");
                        }
                        else if (level >= ValidationLevel.Basic)
                        {
                            result = result.WithResult(isValid: false, "6.4.3. uniqueItems - duplicate items were found.");
                        }
                        else
                        {
                            return result.WithResult(isValid: false);
                        }
                    }
                }

        <#
            }
        #>

        <#
            if (HasContains)
            {
        #>
                ValidationContext containsResult = arrayEnumerator.Current.As<<#=     ContainsDotnetTypeName #>>().Validate(result.CreateChildContext(), level);

                if (containsResult.IsValid)
                {
                    result = result.WithLocalItemIndex(arrayLength);
                    containsCount++;

            <#
                if (HasMaxContains && !HasUnevaluatedItems)
                {
            #>
                    if (level == ValidationLevel.Flag && containsCount > <#=  MaxContains #>)
                    {
                        return result.WithResult(isValid: false);
                    }
            <#
                }
            #>
                }

        <#
            }
        #>

        <#
            if (HasSingleItemsType && !HasPrefixItems)
            {
        #>
                result = arrayEnumerator.Current.As<<#=     SingleItemsDotnetTypeName #>>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                result = result.WithLocalItemIndex(arrayLength);

        <#
            }
            else if (HasMultipleItemsType || HasPrefixItems)
            {
                int itemsIndex = 0;
        #>
                switch (arrayLength)
                {
            <#
                if (HasPrefixItems)
                {

                    foreach (var prefixItem in PrefixItems)
                    {
            #>
                    case <#= itemsIndex #>:
                    
                        result = arrayEnumerator.Current.As<<#= prefixItem #>>().Validate(result, level);
                        if (level == ValidationLevel.Flag && !result.IsValid)
                        {
                            return result;
                        }
                        result = result.WithLocalItemIndex(arrayLength);
                        break;
            <#
                        itemsIndex++;
                    }
                }
            #>

                    default:
                <#
                if (HasSingleItemsType)
                {
                #>
                        result = arrayEnumerator.Current.As<<#=     SingleItemsDotnetTypeName #>>().Validate(result, level);
                        if (level == ValidationLevel.Flag && !result.IsValid)
                        {
                            return result;
                        }

                        result = result.WithLocalItemIndex(arrayLength);
                <#
                }
                else if (HasUnevaluatedItems)
                {
                #>
                        if (!result.HasEvaluatedLocalOrAppliedItemIndex(arrayLength))
                        {

                            result = arrayEnumerator.Current.As<<#=  UnevaluatedItemsDotnetTypeName #>>().Validate(result, level);

                            if (level == ValidationLevel.Flag && !result.IsValid)
                            {
                                return result;
                            }

                            result = result.WithLocalItemIndex(arrayLength);
                        }
                <#
                }
                #>

                        break;
                }

        <#
            }
            else if (HasUnevaluatedItems)
            {
        #>
                if (!result.HasEvaluatedLocalOrAppliedItemIndex(arrayLength))
                {
                    result = arrayEnumerator.Current.As<<#=  UnevaluatedItemsDotnetTypeName #>>().Validate(result, level);

                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }

                    result = result.WithLocalItemIndex(arrayLength);

                }
        <#
            }
        #>

                arrayLength++;
            }
        <#
        }
        #>

        <#
        if (HasMaxItems)
        {
        #>
            if (arrayLength > <#= MaxItems #>)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.4.1. maxItems - {arrayLength} exceeds maximum number of items <#= MaxItems #>.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.4.1. maxItems - item count exceeds maximum number of items <#= MaxItems #>.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }

            }
        <#
        }
        #>

        <#
        if (HasMinItems)
        {
        #>
            if (arrayLength < <#= MinItems #>)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.4.2. minItems - {arrayLength} is less than the minimum number of items <#= MinItems #>.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.4.2. minItems - item count is less than the minimum number of items <#= MinItems #>.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }

            }
        <#
        }
        #>

        <#
        if (HasContains)
        {
        #>
            <#
            if (HasMaxContains)
            {
            #>

            if (containsCount > <#=     MaxContains #>)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.4.4. maxContains - {containsCount} exceeds maximum number of matching items <#=     MaxContains #>.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.4.4. maxContains - item count exceeds maximum number of matching items <#=     MaxContains #>.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }
            }

            <#
            }
            #>

            <#
            if (HasMinContains)
            {
            #>
            if (containsCount < <#=     MinContains #>)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.4.5. minContains - {containsCount} is less than minimum number of matching items <#=     MinContains #>.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.4.5. minContains - item count is less than minimum number of matching items <#=     MinContains #>.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }
            }

            <#
            }
            else
            {
            #>
            if (containsCount == 0)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"10.3.1.3. contains - no items found matching the required schema.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "10.3.1.3. contains - no items found matching the required schema.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }
            }

            <#
            }
            #>


        <#
        }
        #>

            return result;
        }

    <#
    }
    #>

    <#
    if (HasDependentRequired || HasLocalProperties || HasRequired || HasMaxProperties || HasMinProperties|| HasDependentSchemas || HasPropertyNames || HasPatternProperties || ((AllowsAdditionalProperties && (HasAdditionalProperties || HasUnevaluatedProperties)) || !AllowsAdditionalProperties))
    {
    #>
        private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

        <#
        if (HasMaxProperties || HasMinProperties || HasLocalProperties || HasRequired || HasDependentSchemas || HasPatternProperties || HasAdditionalProperties || HasUnevaluatedProperties)
        {
        #>
            int propertyCount = 0;
        <#
        }
        #>

        <#
        if (HasRequired)
        {
        #>
            <# 
            foreach(var property in RequiredProperties)
            {
            #>
            bool found<#=     property.DotnetPropertyName #> = false;
            <#
            }
            #>
        <#
        }
        #>

            foreach (Property property in this.EnumerateObject())
            {
                string propertyName = property.Name;

        <#
        if (HasDependentRequired)
        {
        #>
                if (__CorvusDependentRequired.TryGetValue(propertyName, out ImmutableArray<ReadOnlyMemory<byte>> dependencies))
                {
                    foreach (ReadOnlyMemory<byte> dependency in dependencies)
                    {
                        if (!this.HasProperty(dependency.Span) 
            <#
            if (HasDefaults)
            {
            #>
                        && !this.HasDefault(dependency.Span)
            <#
            }
            #>
                        )
                        {
                            if (level >= ValidationLevel.Detailed)
                            {
                                result = result.WithResult(isValid: false, $"6.5.4. dependentRequired - dependent property \"{dependency}\" not found.");
                            }
                            else if (level >= ValidationLevel.Basic)
                            {
                                result = result.WithResult(isValid: false, "6.5.4. dependentRequired - dependent property not found.");
                            }
                            else
                            {
                                return result.WithResult(isValid: false);
                            }
                        }
                    }
                }

        <#
        }
        #>

        <#
        if (HasLocalProperties || HasRequired)
        {
        #>
                if (__CorvusLocalProperties.TryGetValue(propertyName, out PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>? propertyValidator))
                {
                    result = result.WithLocalProperty(propertyCount);
                    var propertyResult = propertyValidator(this, result.CreateChildContext(), level);
                    result = result.MergeResults(propertyResult.IsValid, level, propertyResult);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }

            <#
            if (HasRequired)
            {
                bool firstRequiredCheck = true;
                foreach (var property in RequiredProperties)
                {
                    if (!firstRequiredCheck)
                    {
                    #>
                else 
                    <#
                    }
                    else
                    {
                        firstRequiredCheck = false;
                    }
            #>

                if (<#=  property.DotnetPropertyName #>JsonPropertyName.Equals(propertyName))
                {
                    found<#=  property.DotnetPropertyName#> = true;
                }
            <#
                }
            }
            #>

                }
        <#
        }
        #>

        <#
        if (HasDependentSchemas)
        {
        #>
                if (__CorvusDependentSchema.TryGetValue(propertyName, out PropertyValidator<<#= TypeDeclaration.DotnetTypeName #>>? dependentSchemaValidator))
                {
                    result = result.WithLocalProperty(propertyCount);
                    result = dependentSchemaValidator(this, result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                }
        <#
        }
        #>

        <#
        if (HasPropertyNames || HasPatternProperties)
        {
        #>
            <#
            if (HasPropertyNames)
            {
            #>
                result = new JsonString(propertyName).As<<#=     PropertyNamesDotnetTypeName #>>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }
            <#
            }
            #>

            <#
            if (HasPatternProperties)
            {
            #>
                foreach (System.Collections.Generic.KeyValuePair<Regex, PatternPropertyValidator> patternProperty in __CorvusPatternProperties)
                {
                    if (patternProperty.Key.IsMatch(propertyName))
                    {
                        result = result.WithLocalProperty(propertyCount);
                        result = patternProperty.Value(property, result, level);
                        if (level == ValidationLevel.Flag && !result.IsValid)
                        {
                            return result;
                        }
                    }
                }

            <#
            }
            #>
        <#
        }
        #>

        <#
        if (AllowsAdditionalProperties && HasAdditionalProperties)
        {
        #>
                if (!result.HasEvaluatedLocalProperty(propertyCount))
                {
                    result = property.ValueAs<<#= AdditionalPropertiesDotnetTypeName #>>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                    result = result.WithLocalProperty(propertyCount);
                }
        <#
        }
        #>

        <#
        if (AllowsAdditionalProperties && HasUnevaluatedProperties)
        {
        #>        
                if (!result.HasEvaluatedLocalOrAppliedProperty(propertyCount))
                {

                    result = property.ValueAs<<#= UnevaluatedPropertiesDotnetTypeName #>>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }

                    result = result.WithLocalProperty(propertyCount);
                }
        <#
        }
        #>

        <#
        if (!AllowsAdditionalProperties)
        {
        #>        
                if (!result.HasEvaluatedLocalProperty(propertyCount))
                {
                    if (level >= ValidationLevel.Detailed)
                    {
                        result = result.WithResult(isValid: false, $"9.3.2.3. additionalProperties - additional property \"{propertyName}\" is not permitted.");
                    }
                    else if (level >= ValidationLevel.Basic)
                    {
                        result = result.WithResult(isValid: false, "9.3.2.3. additionalProperties - additional properties are not permitted.");
                    }
                    else
                    {
                        return result.WithResult(isValid: false);
                    }
                }

        <#
        }
        #>

        <#
        if (HasMaxProperties || HasMinProperties || HasLocalProperties || HasRequired || HasDependentSchemas || HasPatternProperties || HasAdditionalProperties || HasUnevaluatedProperties)
        {
        #>        
                propertyCount++;

        <#
        }
        #>
            }

        <#
        if (HasRequired)
        {
        #>

            <#
            foreach (var property in RequiredProperties)
            {
                if (!property.HasDefaultValue)
                {
            #>
            if (!found<#=                    property.DotnetPropertyName #>)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.5.3. required - required property \"<#=                    Formatting.FormatLiteralOrNull(property.JsonPropertyName, true).Trim('"') #>\" not present.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.5.3. required - required property not present.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }
            }
            <#
                }
            }
            #>
        <#
        }
        #>

        <#
        if (HasMaxProperties)
        {
        #>        
            if (propertyCount > <#= MaxProperties #>)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.5.1. maxProperties - property count of {propertyCount} is greater than <#= MaxProperties #>.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.5.1. maxProperties - property count greater than <#= MaxProperties #>.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }
            }
        <#
        }
        #>

        <#
        if (HasMinProperties)
        {
        #>        
            if (propertyCount < <#= MinProperties #>)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.5.2. minProperties - property count of {propertyCount} is lezs than <#= MinProperties #>.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.5.2. minProperties - property count less than <#= MinProperties #>.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }
            }

        <#
        }
        #>

            return result;
        }

    <#
    }
    #>

    <#
    if (HasOneOf)
    {
    #>        
        private ValidationContext ValidateOneOf(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            int oneOfCount = 0;

        <#
        int oneOfIndex = 0;
        foreach (var oneOf in OneOf)
        {
        #>        

            ValidationContext oneOfResult<#= oneOfIndex#> = this.As<<#= oneOf #>>().Validate(validationContext.CreateChildContext(), level);

            if (oneOfResult<#= oneOfIndex #>.IsValid)
            {
                result = result.MergeChildContext(oneOfResult<#= oneOfIndex #>, level >= ValidationLevel.Detailed);
                oneOfCount += 1;
                            <#
            if (!HasUnevaluatedItems && !HasUnevaluatedProperties)
            {
            #>
                if (oneOfCount > 1 && level == ValidationLevel.Flag)
                {
                    result = result.WithResult(isValid: false);
                    return result;
                }
            <#
            }
            #>
            }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.MergeResults(result.IsValid, level, oneOfResult<#= oneOfIndex #>);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, oneOfResult<#= oneOfIndex #>);
                }
                else
                {
                    result = result.MergeResults(result.IsValid, level, oneOfResult<#= oneOfIndex #>);
                }
            }

        <#
            oneOfIndex++;
        }
        #>

            if (oneOfCount == 1)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: true, "Validation 10.2.1.3. onef - validated against the oneOf schema.");
                }
            }
            else if (oneOfCount == 0)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.3. oneOf - failed to validate against any of the oneOf schema.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.3. oneOf - failed to validate against any of the oneOf schema.");
                }
                else
                {
                    result = result.WithResult(isValid: false);
                }
            }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.3. oneOf - validated against more than one of the oneOf schema.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.3. oneOf - failed to validate against more than one of the oneOf schema.");
                }
                else
                {
                    result = result.WithResult(isValid: false);
                }
            }

            return result;
        }

    <#
    }
    #>        

    <#
    if (HasAnyOf)
    {
    #>        
        private ValidationContext ValidateAnyOf(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            bool foundValid = false;

        <#
        int anyOfIndex = 0;
        foreach (var anyOf in AnyOf)
        {
        #>        

            ValidationContext anyOfResult<#= anyOfIndex #> = this.As<<#= anyOf #>>().Validate(validationContext.CreateChildContext(), level);

            if (anyOfResult<#= anyOfIndex #>.IsValid)
            {
                result = result.MergeChildContext(anyOfResult<#= anyOfIndex #>, level >= ValidationLevel.Detailed);
            <#
            if (!HasUnevaluatedItems && !HasUnevaluatedProperties)
            {
                #>
                if (level == ValidationLevel.Flag)
                {
                    return result;
                }
                else
                {
                    foundValid = true;
                }
            <#
            }
            else
            {
            #>
                    foundValid = true;
            <#
            }
            #>
            }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult<#= anyOfIndex #>);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult<#= anyOfIndex #>);
                }
            }

        <#
            anyOfIndex++;
        }
        #>

            if (foundValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: true, "Validation 10.2.1.2. anyOf - validated against the anyOf schema.");
                }
            }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.2. anyOf - failed to validate against the anyOf schema.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.2. anyOf - failed to validate against the anyOf schema.");
                }
                else
                {
                    result = result.WithResult(isValid: false);
                }
            }

            return result;
        }

    <#
    }
    #>        

    <#
    if (HasAllOf)
    {
    #>        
        private ValidationContext ValidateAllOf(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

        <#
        int allOfIndex = 0;
        foreach (var allOf in AllOf)
        {
        #>        

            ValidationContext allOfResult<#= allOfIndex #> = this.As<<#= allOf #>>().Validate(validationContext.CreateChildContext(), level);

            if (!allOfResult<#= allOfIndex #>.IsValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.MergeChildContext(allOfResult<#= allOfIndex #>, true).WithResult(isValid: false, "Validation 10.2.1.1. allOf - failed to validate against the allOf schema.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeChildContext(allOfResult<#= allOfIndex #>, true).WithResult(isValid: false, "Validation 10.2.1.1. allOf - failed to validate against the allOf schema.");
                }
                else
                {
                    result = result.MergeChildContext(allOfResult<#= allOfIndex #>, false).WithResult(isValid: false);
                    return result;
                }
            }
            else
            {
                result = result.MergeChildContext(allOfResult<#= allOfIndex #>, level >= ValidationLevel.Detailed);
            }

        <#
            allOfIndex++;
        }
        #>

            return result;
        }

    <#
    }
    #>        

    <#
    if (HasNot)
    {
    #>        
        private ValidationContext ValidateNot(ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            ValidationContext notResult = this.As<<#= NotDotnetTypeName #>>().Validate(validationContext.CreateChildContext(), level);
            if (notResult.IsValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = validationContext.MergeResults(false, level, notResult).WithResult(isValid: false, "Validation 9.2.1.4. not - incorrectly validated successfully against the not schema.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = validationContext.MergeResults(false, level, notResult).WithResult(isValid: false, "Validation 9.2.1.4. not - incorrectly validated succesfully against the not schema.");
                }
                else
                {
                    result = validationContext.WithResult(isValid: false);
                }
            }
            else if (level >= ValidationLevel.Basic)
            {
                result = result.MergeResults(result.IsValid, level, notResult);
            }

            return result;
        }

    <#
    }
    #>        

    <#
    if (HasIfThenElse)
    {
    #>        
        private ValidationContext ValidateIfThenElse(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            ValidationContext ifResult = this.As<<#= IfFullyQualifiedDotnetTypeName #>>().Validate(validationContext.CreateChildContext(), level);

            if (!ifResult.IsValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = validationContext.MergeResults(false, level, ifResult, ifResult);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = validationContext.MergeResults(false, level, ifResult, ifResult);
                }
            }
            else
            {
                if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeChildContext(ifResult, true);
                }

                result = result.MergeChildContext(ifResult, false);
            }


        <#
        if (HasThen)
        {
        #>        
            if (ifResult.IsValid)
            {
                ValidationContext thenResult = this.As<<#= ThenFullyQualifiedDotnetTypeName #>>().Validate(validationContext.CreateChildContext(), level);

                if (!thenResult.IsValid)
                {
                    if (level >= ValidationLevel.Detailed)
                    {
                        result = validationContext.MergeResults(false, level, ifResult, thenResult).WithResult(isValid: false, "Validation 9.2.2.2. then - failed to validate against the then schema.");
                    }
                    else if (level >= ValidationLevel.Basic)
                    {
                        result = validationContext.MergeResults(false, level, ifResult, thenResult).WithResult(isValid: false, "Validation 9.2.2.2. then - failed to validate against the then schema.");
                    }
                    else
                    {
                        result = validationContext.WithResult(isValid: false);
                    }
                }
                else
                {
                    if (level >= ValidationLevel.Basic)
                    {
                        result = result.MergeChildContext(thenResult, true);
                    }

                    result = result.MergeChildContext(thenResult, false);
                }
            }

        <#
        }
        #>

        <#
        if (HasElse)
        {
        #>        
            if (!ifResult.IsValid)
            {
                ValidationContext elseResult = this.As<<#= ElseFullyQualifiedDotnetTypeName #>>().Validate(validationContext.CreateChildContext(), level);

                if (!elseResult.IsValid)
                {
                    if (level >= ValidationLevel.Detailed)
                    {
                        result = validationContext.MergeResults(false, level, ifResult, elseResult).WithResult(isValid: false, "Validation 9.2.2.3. else - failed to validate against the else schema.");
                    }
                    else if (level >= ValidationLevel.Basic)
                    {
                        result = validationContext.MergeResults(false, level, ifResult, elseResult).WithResult(isValid: false, "Validation 9.2.2.2. else - failed to validate against the else schema.");
                    }
                    else
                    {
                        result = validationContext.WithResult(isValid: false);
                    }
                }
                else
                {
                    if (level >= ValidationLevel.Basic)
                    {
                        result = result.MergeChildContext(elseResult, true);
                    }

                    result = result.MergeChildContext(elseResult, false);
                }
            }

        <#
        }
        #>

            return result;
        }

    <#
    }
    #>

    <#
    if (HasMediaTypeOrEncoding)
    {
    #>
        private ValidationContext ValidateMediaTypeAndEncoding(JsonValueKind valueKind, ValidationContext result, ValidationLevel level)
        {
        <#
        if (IsJsonBase64Content)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return this.As<JsonBase64Content>().Validate(result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonBase64String)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return this.As<JsonBase64String>().Validate(result, level);
            }

        <#
        }
        #>

        <#
        if (IsJsonContent)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return this.As<JsonContent>().Validate(result, level);
            }
        <#
        }
        #>

            return result;
        }

    <#
    }
    #>

    <#
    if (HasFormat)
    {
    #>        
        private ValidationContext ValidateFormat(JsonValueKind valueKind, ValidationContext result, ValidationLevel level)
        {
        <#
        if (IsJsonRelativePointer)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeRelativeJsonPointer(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonDate)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeDate(this, result, level);
            }

        <#
        }
        #>

        <#
        if (IsJsonDateTime)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeDateTime(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonDuration)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeDuration(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonTime)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeTime(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonEmail)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeEmail(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonHostname)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeHostname(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonIdnEmail)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeIdnEmail(this, result, level);
            }

        <#
        }
        #>

        <#
        if (IsJsonIdnHostname)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeIdnHostname(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonInteger)
        {
        #>        
            if (valueKind == JsonValueKind.Number)
            {
                return Corvus.Json.Validate.TypeInteger(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonIpV4)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeIpV4(this, result, level);
            }

        <#
        }
        #>

        <#
        if (IsJsonIpV6)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeIpV6(this, result, level);
            }

        <#
        }
        #>

        <#
        if (IsJsonIri)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeIri(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonIriReference)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeIriReference(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonPointer)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeJsonPointer(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonRegex)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeRegex(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonRelativePointer)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeRelativeJsonPointer(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonTime)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeTime(this, result, level);
            }

        <#
        }
        #>

        <#
        if (IsJsonUri)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeUri(this, result, level);
            }

        <#
        }
        #>

        <#
        if (IsJsonUriReference)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeUriReference(this, result, level);
            }
        <#
        }
        #>

        <#
        if (IsJsonUriTemplate)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeUriTemplate(this, result, level);
            }

        <#
        }
        #>

        <#
        if (IsJsonUuid)
        {
        #>        
            if (valueKind == JsonValueKind.String)
            {
                return Corvus.Json.Validate.TypeUuid(this, result, level);
            }

        <#
        }
        #>

            return result;
        }

    <#
    }
    #>

    <#
    if (HasType)
    {
    #>        
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        <#
        if (HasStringType)
        {
        #>        
            ValidationContext localResultString = Corvus.Json.Validate.TypeString(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultString.IsValid)
            {
                return validationContext;
            }

            if (localResultString.IsValid)
            {
                isValid = true;
            }

        <#
        }
        #>

        <#
        if (HasObjectType)
        {
        #>        
            ValidationContext localResultObject = Corvus.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        <#
        }
        #>

        <#
        if (HasArrayType)
        {
        #>        
            ValidationContext localResultArray = Corvus.Json.Validate.TypeArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultArray.IsValid)
            {
                return validationContext;
            }

            if (localResultArray.IsValid)
            {
                isValid = true;
            }

        <#
        }
        #>

        <#
        if (HasNumberType)
        {
        #>        
            ValidationContext localResultNumber = Corvus.Json.Validate.TypeNumber(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultNumber.IsValid)
            {
                return validationContext;
            }

            if (localResultNumber.IsValid)
            {
                isValid = true;
            }

        <#
        }
        #>

        <#
        if (HasIntegerType)
        {
        #>        
            ValidationContext localResultInteger = Corvus.Json.Validate.TypeInteger(this, result, level);
            if (level == ValidationLevel.Flag && localResultInteger.IsValid)
            {
                return validationContext;
            }

            if (localResultInteger.IsValid)
            {
                isValid = true;
            }

        <#
        }
        #>

        <#
        if (HasBooleanType)
        {
        #>        
            ValidationContext localResultBoolean = Corvus.Json.Validate.TypeBoolean(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultBoolean.IsValid)
            {
                return validationContext;
            }

            if (localResultBoolean.IsValid)
            {
                isValid = true;
            }

        <#
        }
        #>

        <#
        if (HasNullType)
        {
        #>        
            ValidationContext localResultNull = Corvus.Json.Validate.TypeNull(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultNull.IsValid)
            {
                return validationContext;
            }

            if (localResultNull.IsValid)
            {
                isValid = true;
            }

        <#
        }
        #>

            result = result.MergeResults(
                isValid,
                level
        <#
        if (HasStringType)
        {
        #>        
                , localResultString
        <#
        }
        #>

        <#
        if (HasObjectType)
        {
        #>        
                , localResultObject
        <#
        }
        #>

        <#
        if (HasArrayType)
        {
        #>        
                , localResultArray
        <#
        }
        #>

        <#
        if (HasNumberType)
        {
        #>        
                , localResultNumber
        <#
        }
        #>

        <#
        if (HasIntegerType)
        {
        #>        
                , localResultInteger
        <#
        }
        #>

        <#
        if (HasBooleanType)
        {
        #>        
                , localResultBoolean
        <#
        }
        #>

        <#
        if (HasNullType)
        {
        #>        
                , localResultNull
        <#
        }
        #>
                );

            return result;
        }

    <#
    }
    #>

    <#
    if (HasEnum)
    {
    #>        
        /// <summary>
        /// Permitted values.
        /// </summary>
        public static class EnumValues
        {
        <#
        int enumItemIndex = 0;
        foreach (var enumValue in EnumValues)
        {
        #>
            <#
            if (enumValue.IsString)
            {
            #>
            /// <summary>
            /// enumValue.AsPropertyName.
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly <#=                    TypeDeclaration.DotnetTypeName #> <#=                    enumValue.AsPropertyName#> = JsonAny.Parse(<#=                    enumValue.SerializedValue #>);
            <#
            }
            else if (enumValue.IsBoolean)
            {
            #>
            /// <summary>
            /// [{Title} || Item <#=     enumItemIndex#>] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly <#=     TypeDeclaration.DotnetTypeName #> Item<#=     enumItemIndex#> = JsonAny.Parse(<#=     enumValue.SerializedValue #>);
            <#
            }
            else if (enumValue.IsNumber)
            {
            #>
            /// <summary>
            /// [{Title} || Item <#=     enumItemIndex#>] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly <#=     TypeDeclaration.DotnetTypeName #> Item<#=     enumItemIndex#> = JsonAny.Parse(<#=     enumValue.SerializedValue #>);
            <#
            }
            else if (enumValue.IsObject)
            {
            #>
            /// <summary>
            /// [{Title} || Item <#=     enumItemIndex#>] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly <#=     TypeDeclaration.DotnetTypeName #> Item<#=     enumItemIndex#> = JsonAny.Parse(<#=     enumValue.SerializedValue #>);
            <#
            }
            else if (enumValue.IsArray)
            {
            #>
            /// <summary>
            /// [{Title} || Item <#=     enumItemIndex#>] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly <#=     TypeDeclaration.DotnetTypeName #> Item<#=     enumItemIndex#> = JsonAny.Parse(<#=     enumValue.SerializedValue #>);
            <#
            }
            else if (enumValue.IsNull)
            {
            #>
            /// <summary>
            /// [{Title} || Item <#=     enumItemIndex#>] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly <#=     TypeDeclaration.DotnetTypeName #> Item<#=     enumItemIndex#> = JsonAny.Parse("null");
            <#
            }
            #>

        <#
            ++enumItemIndex;
        }
        #>


        <#
        enumItemIndex = 0;
        foreach (var enumValue in EnumValues)
        {
        #>
            <#
            if (enumValue.IsString)
            {
            #>
            /// <summary>
            /// [{Title} || Item <#=     enumItemIndex#>] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            internal static readonly <#=     TypeDeclaration.DotnetTypeName #> Item<#=     enumItemIndex#> = JsonAny.Parse(<#=     enumValue.SerializedValue #>);
            <#
            }
            enumItemIndex++;
        }
        #>
        }
    <#
    }
    #>

    <#
    foreach(var nestedType in NestedTypes)
    {
    #>

    <#= WriteNestedType(nestedType) #>

    <#
    }
    #>

    }
    <#
    if (!IsNested)
    {
    #>
}
    <#
    }
    #>