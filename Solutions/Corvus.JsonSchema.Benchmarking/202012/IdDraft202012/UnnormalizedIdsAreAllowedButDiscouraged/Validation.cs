
    //------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Text;
    using System.Text.Json;
    using System.Text.RegularExpressions;
    using Corvus.Json;

        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct Validation :
            IJsonObject<Validation>,
                    IEquatable<Validation>
    {

        
    
        
        /// <summary>
        /// JSON property name for <see cref="Type"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> TypeUtf8JsonPropertyName = new byte[] { 116, 121, 112, 101 };

        /// <summary>
        /// JSON property name for <see cref="Type"/>.
        /// </summary>
        public static readonly string TypeJsonPropertyName = "type";

        
        /// <summary>
        /// JSON property name for <see cref="Const"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ConstUtf8JsonPropertyName = new byte[] { 99, 111, 110, 115, 116 };

        /// <summary>
        /// JSON property name for <see cref="Const"/>.
        /// </summary>
        public static readonly string ConstJsonPropertyName = "const";

        
        /// <summary>
        /// JSON property name for <see cref="Enum"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> EnumUtf8JsonPropertyName = new byte[] { 101, 110, 117, 109 };

        /// <summary>
        /// JSON property name for <see cref="Enum"/>.
        /// </summary>
        public static readonly string EnumJsonPropertyName = "enum";

        
        /// <summary>
        /// JSON property name for <see cref="MultipleOf"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MultipleOfUtf8JsonPropertyName = new byte[] { 109, 117, 108, 116, 105, 112, 108, 101, 79, 102 };

        /// <summary>
        /// JSON property name for <see cref="MultipleOf"/>.
        /// </summary>
        public static readonly string MultipleOfJsonPropertyName = "multipleOf";

        
        /// <summary>
        /// JSON property name for <see cref="Maximum"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MaximumUtf8JsonPropertyName = new byte[] { 109, 97, 120, 105, 109, 117, 109 };

        /// <summary>
        /// JSON property name for <see cref="Maximum"/>.
        /// </summary>
        public static readonly string MaximumJsonPropertyName = "maximum";

        
        /// <summary>
        /// JSON property name for <see cref="ExclusiveMaximum"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ExclusiveMaximumUtf8JsonPropertyName = new byte[] { 101, 120, 99, 108, 117, 115, 105, 118, 101, 77, 97, 120, 105, 109, 117, 109 };

        /// <summary>
        /// JSON property name for <see cref="ExclusiveMaximum"/>.
        /// </summary>
        public static readonly string ExclusiveMaximumJsonPropertyName = "exclusiveMaximum";

        
        /// <summary>
        /// JSON property name for <see cref="Minimum"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MinimumUtf8JsonPropertyName = new byte[] { 109, 105, 110, 105, 109, 117, 109 };

        /// <summary>
        /// JSON property name for <see cref="Minimum"/>.
        /// </summary>
        public static readonly string MinimumJsonPropertyName = "minimum";

        
        /// <summary>
        /// JSON property name for <see cref="ExclusiveMinimum"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> ExclusiveMinimumUtf8JsonPropertyName = new byte[] { 101, 120, 99, 108, 117, 115, 105, 118, 101, 77, 105, 110, 105, 109, 117, 109 };

        /// <summary>
        /// JSON property name for <see cref="ExclusiveMinimum"/>.
        /// </summary>
        public static readonly string ExclusiveMinimumJsonPropertyName = "exclusiveMinimum";

        
        /// <summary>
        /// JSON property name for <see cref="MaxLength"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MaxLengthUtf8JsonPropertyName = new byte[] { 109, 97, 120, 76, 101, 110, 103, 116, 104 };

        /// <summary>
        /// JSON property name for <see cref="MaxLength"/>.
        /// </summary>
        public static readonly string MaxLengthJsonPropertyName = "maxLength";

        
        /// <summary>
        /// JSON property name for <see cref="MinLength"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MinLengthUtf8JsonPropertyName = new byte[] { 109, 105, 110, 76, 101, 110, 103, 116, 104 };

        /// <summary>
        /// JSON property name for <see cref="MinLength"/>.
        /// </summary>
        public static readonly string MinLengthJsonPropertyName = "minLength";

        
        /// <summary>
        /// JSON property name for <see cref="Pattern"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> PatternUtf8JsonPropertyName = new byte[] { 112, 97, 116, 116, 101, 114, 110 };

        /// <summary>
        /// JSON property name for <see cref="Pattern"/>.
        /// </summary>
        public static readonly string PatternJsonPropertyName = "pattern";

        
        /// <summary>
        /// JSON property name for <see cref="MaxItems"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MaxItemsUtf8JsonPropertyName = new byte[] { 109, 97, 120, 73, 116, 101, 109, 115 };

        /// <summary>
        /// JSON property name for <see cref="MaxItems"/>.
        /// </summary>
        public static readonly string MaxItemsJsonPropertyName = "maxItems";

        
        /// <summary>
        /// JSON property name for <see cref="MinItems"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MinItemsUtf8JsonPropertyName = new byte[] { 109, 105, 110, 73, 116, 101, 109, 115 };

        /// <summary>
        /// JSON property name for <see cref="MinItems"/>.
        /// </summary>
        public static readonly string MinItemsJsonPropertyName = "minItems";

        
        /// <summary>
        /// JSON property name for <see cref="UniqueItems"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> UniqueItemsUtf8JsonPropertyName = new byte[] { 117, 110, 105, 113, 117, 101, 73, 116, 101, 109, 115 };

        /// <summary>
        /// JSON property name for <see cref="UniqueItems"/>.
        /// </summary>
        public static readonly string UniqueItemsJsonPropertyName = "uniqueItems";

        
        /// <summary>
        /// JSON property name for <see cref="MaxContains"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MaxContainsUtf8JsonPropertyName = new byte[] { 109, 97, 120, 67, 111, 110, 116, 97, 105, 110, 115 };

        /// <summary>
        /// JSON property name for <see cref="MaxContains"/>.
        /// </summary>
        public static readonly string MaxContainsJsonPropertyName = "maxContains";

        
        /// <summary>
        /// JSON property name for <see cref="MinContains"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MinContainsUtf8JsonPropertyName = new byte[] { 109, 105, 110, 67, 111, 110, 116, 97, 105, 110, 115 };

        /// <summary>
        /// JSON property name for <see cref="MinContains"/>.
        /// </summary>
        public static readonly string MinContainsJsonPropertyName = "minContains";

        
        /// <summary>
        /// JSON property name for <see cref="MaxProperties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MaxPropertiesUtf8JsonPropertyName = new byte[] { 109, 97, 120, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="MaxProperties"/>.
        /// </summary>
        public static readonly string MaxPropertiesJsonPropertyName = "maxProperties";

        
        /// <summary>
        /// JSON property name for <see cref="MinProperties"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> MinPropertiesUtf8JsonPropertyName = new byte[] { 109, 105, 110, 80, 114, 111, 112, 101, 114, 116, 105, 101, 115 };

        /// <summary>
        /// JSON property name for <see cref="MinProperties"/>.
        /// </summary>
        public static readonly string MinPropertiesJsonPropertyName = "minProperties";

        
        /// <summary>
        /// JSON property name for <see cref="Required"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> RequiredUtf8JsonPropertyName = new byte[] { 114, 101, 113, 117, 105, 114, 101, 100 };

        /// <summary>
        /// JSON property name for <see cref="Required"/>.
        /// </summary>
        public static readonly string RequiredJsonPropertyName = "required";

        
        /// <summary>
        /// JSON property name for <see cref="DependentRequired"/>.
        /// </summary>
        public static readonly ReadOnlyMemory<byte> DependentRequiredUtf8JsonPropertyName = new byte[] { 100, 101, 112, 101, 110, 100, 101, 110, 116, 82, 101, 113, 117, 105, 114, 101, 100 };

        /// <summary>
        /// JSON property name for <see cref="DependentRequired"/>.
        /// </summary>
        public static readonly string DependentRequiredJsonPropertyName = "dependentRequired";

        
    
    
    
    
    
            private static readonly ImmutableDictionary<string, PropertyValidator<Validation>> __CorvusLocalProperties = CreateLocalPropertyValidators();
    
            private static readonly ImmutableDictionary<string, JsonAny> __CorvusDefaults = BuildDefaults();
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<string, JsonAny>? objectBacking;
    
    
    
    
            private readonly bool? booleanBacking;
    
        /// <summary>
        /// Initializes a new instance of the <see cref="Validation"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public Validation(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                                this.booleanBacking = default;
            }

            /// <summary>
        /// Initializes a new instance of the <see cref="Validation"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public Validation(ImmutableDictionary<string, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                            this.booleanBacking = default;
                }

        /// <summary>
        /// Initializes a new instance of the <see cref="Validation"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public Validation(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                            this.booleanBacking = default;
                }
    
    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="Validation"/> struct.
        /// </summary>
        /// <param name="jsonBoolean">The <see cref="JsonBoolean"/> from which to construct the value.</param>
        public Validation(JsonBoolean jsonBoolean)
        {
            if (jsonBoolean.HasJsonElement)
            {
                this.jsonElementBacking = jsonBoolean.AsJsonElement;
                this.booleanBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.booleanBacking = jsonBoolean.GetBoolean();
            }

                    this.objectBacking = default;
                                        }

                /// <summary>
        /// Initializes a new instance of the <see cref="Validation"/> struct.
        /// </summary>
        /// <param name="boolean">The <see cref="bool"/> from which to construct the value.</param>
        public Validation(bool boolean)
        {
            this.jsonElementBacking = default;
            this.booleanBacking = boolean;

                    this.objectBacking = default;
                                        }

    
    
    

    
    
    
            
        /// <summary>
        /// Gets Type.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity Type
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(TypeJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(TypeUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Const.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Corvus.Json.JsonAny Const
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(ConstJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ConstUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Corvus.Json.JsonAny(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Enum.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonAnyArray Enum
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(EnumJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(EnumUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonAnyArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MultipleOf.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MultipleOfValue MultipleOf
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MultipleOfJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MultipleOfUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MultipleOfValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Maximum.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Corvus.Json.JsonNumber Maximum
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MaximumJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MaximumUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Corvus.Json.JsonNumber(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets ExclusiveMaximum.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Corvus.Json.JsonNumber ExclusiveMaximum
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(ExclusiveMaximumJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ExclusiveMaximumUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Corvus.Json.JsonNumber(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Minimum.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Corvus.Json.JsonNumber Minimum
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MinimumJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MinimumUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Corvus.Json.JsonNumber(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets ExclusiveMinimum.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Corvus.Json.JsonNumber ExclusiveMinimum
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(ExclusiveMinimumJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(ExclusiveMinimumUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Corvus.Json.JsonNumber(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MaxLength.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue MaxLength
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MaxLengthJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MaxLengthUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MinLength.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity MinLength
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MinLengthJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MinLengthUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Pattern.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public Corvus.Json.JsonRegex Pattern
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(PatternJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(PatternUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  Corvus.Json.JsonRegex(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MaxItems.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue MaxItems
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MaxItemsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MaxItemsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MinItems.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity MinItems
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MinItemsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MinItemsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets UniqueItems.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.UniqueItemsValue UniqueItems
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(UniqueItemsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(UniqueItemsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.UniqueItemsValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MaxContains.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue MaxContains
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MaxContainsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MaxContainsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MinContains.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MinContainsEntity MinContains
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MinContainsJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MinContainsUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MinContainsEntity(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MaxProperties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue MaxProperties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MaxPropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MaxPropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets MinProperties.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity MinProperties
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(MinPropertiesJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(MinPropertiesUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets Required.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray Required
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(RequiredJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(RequiredUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray(result);
                    }
                }

                return default;
            }
        }

        
        /// <summary>
        /// Gets DependentRequired.
        /// </summary>
        /// <remarks>
        /// {Property title}.
        /// {Property description}.
        /// </remarks>
        /// <example>
        /// {Property examples}.
        /// </example>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.DependentRequiredValue DependentRequired
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
                {
                    if(properties.TryGetValue(DependentRequiredJsonPropertyName, out JsonAny result))
                    {
                        return result;
                    }
                }

                if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
                {
                    if (this.jsonElementBacking.TryGetProperty(DependentRequiredUtf8JsonPropertyName.Span, out JsonElement result))
                    {
                        return new  IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.DependentRequiredValue(result);
                    }
                }

                return default;
            }
        }

                    /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                                    &&
                    this.booleanBacking is null
    
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return JsonBoolean.BoolToJsonElement(booleanBacking);
                }

    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return booleanBacking ? JsonValueKind.True : JsonValueKind.False;
                }

    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonAny(booleanBacking);
                }

    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Validation(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new Validation(value.AsJsonElement);
            }

            return value.As<Validation>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(Validation value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Validation(JsonObject value)
        {
            return new Validation(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(Validation value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<string, JsonAny>(Validation  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Validation (ImmutableDictionary<string, JsonAny> value)
        {
            return new Validation (value);
        }

    
    
    
    
        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Validation(bool value)
        {
            return new Validation(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator bool(Validation boolean)
        {
            return boolean.AsBoolean.GetBoolean();
        }

        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator Validation(JsonBoolean value)
        {
            return new Validation(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator JsonBoolean(Validation boolean)
        {
            return boolean.AsBoolean;
        }

    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(Validation lhs, Validation rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(Validation lhs, Validation rhs)
        {
            return !lhs.Equals(rhs);
        }

    
            /// <summary>
        /// Creates an instance of a <see cref="Validation"/>.
        /// </summary>
        public static Validation Create(
                            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity? type = null
        ,             Corvus.Json.JsonAny? @const = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonAnyArray? @enum = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MultipleOfValue? multipleOf = null
        ,             Corvus.Json.JsonNumber? maximum = null
        ,             Corvus.Json.JsonNumber? exclusiveMaximum = null
        ,             Corvus.Json.JsonNumber? minimum = null
        ,             Corvus.Json.JsonNumber? exclusiveMinimum = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue? maxLength = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity? minLength = null
        ,             Corvus.Json.JsonRegex? pattern = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue? maxItems = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity? minItems = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.UniqueItemsValue? uniqueItems = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue? maxContains = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MinContainsEntity? minContains = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue? maxProperties = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity? minProperties = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray? required = null
        ,             IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.DependentRequiredValue? dependentRequired = null
        
        )
        {
            var builder = ImmutableDictionary.CreateBuilder<string, JsonAny>();
                            if (type is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity type__)
            {
                builder.Add(TypeJsonPropertyName, type__);
            }
                    if (@const is Corvus.Json.JsonAny @const__)
            {
                builder.Add(ConstJsonPropertyName, @const__);
            }
                    if (@enum is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonAnyArray @enum__)
            {
                builder.Add(EnumJsonPropertyName, @enum__);
            }
                    if (multipleOf is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MultipleOfValue multipleOf__)
            {
                builder.Add(MultipleOfJsonPropertyName, multipleOf__);
            }
                    if (maximum is Corvus.Json.JsonNumber maximum__)
            {
                builder.Add(MaximumJsonPropertyName, maximum__);
            }
                    if (exclusiveMaximum is Corvus.Json.JsonNumber exclusiveMaximum__)
            {
                builder.Add(ExclusiveMaximumJsonPropertyName, exclusiveMaximum__);
            }
                    if (minimum is Corvus.Json.JsonNumber minimum__)
            {
                builder.Add(MinimumJsonPropertyName, minimum__);
            }
                    if (exclusiveMinimum is Corvus.Json.JsonNumber exclusiveMinimum__)
            {
                builder.Add(ExclusiveMinimumJsonPropertyName, exclusiveMinimum__);
            }
                    if (maxLength is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue maxLength__)
            {
                builder.Add(MaxLengthJsonPropertyName, maxLength__);
            }
                    if (minLength is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity minLength__)
            {
                builder.Add(MinLengthJsonPropertyName, minLength__);
            }
                    if (pattern is Corvus.Json.JsonRegex pattern__)
            {
                builder.Add(PatternJsonPropertyName, pattern__);
            }
                    if (maxItems is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue maxItems__)
            {
                builder.Add(MaxItemsJsonPropertyName, maxItems__);
            }
                    if (minItems is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity minItems__)
            {
                builder.Add(MinItemsJsonPropertyName, minItems__);
            }
                    if (uniqueItems is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.UniqueItemsValue uniqueItems__)
            {
                builder.Add(UniqueItemsJsonPropertyName, uniqueItems__);
            }
                    if (maxContains is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue maxContains__)
            {
                builder.Add(MaxContainsJsonPropertyName, maxContains__);
            }
                    if (minContains is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MinContainsEntity minContains__)
            {
                builder.Add(MinContainsJsonPropertyName, minContains__);
            }
                    if (maxProperties is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue maxProperties__)
            {
                builder.Add(MaxPropertiesJsonPropertyName, maxProperties__);
            }
                    if (minProperties is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity minProperties__)
            {
                builder.Add(MinPropertiesJsonPropertyName, minProperties__);
            }
                    if (required is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray required__)
            {
                builder.Add(RequiredJsonPropertyName, required__);
            }
                    if (dependentRequired is IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.DependentRequiredValue dependentRequired__)
            {
                builder.Add(DependentRequiredJsonPropertyName, dependentRequired__);
            }
                    return builder.ToImmutable();
        }

        
        /// <summary>
        /// Sets type.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithType(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity value)
        {
            return this.SetProperty(TypeJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets const.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithConst(Corvus.Json.JsonAny value)
        {
            return this.SetProperty(ConstJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets enum.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithEnum(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonAnyArray value)
        {
            return this.SetProperty(EnumJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets multipleOf.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMultipleOf(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MultipleOfValue value)
        {
            return this.SetProperty(MultipleOfJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets maximum.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMaximum(Corvus.Json.JsonNumber value)
        {
            return this.SetProperty(MaximumJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets exclusiveMaximum.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithExclusiveMaximum(Corvus.Json.JsonNumber value)
        {
            return this.SetProperty(ExclusiveMaximumJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets minimum.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMinimum(Corvus.Json.JsonNumber value)
        {
            return this.SetProperty(MinimumJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets exclusiveMinimum.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithExclusiveMinimum(Corvus.Json.JsonNumber value)
        {
            return this.SetProperty(ExclusiveMinimumJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets maxLength.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMaxLength(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue value)
        {
            return this.SetProperty(MaxLengthJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets minLength.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMinLength(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity value)
        {
            return this.SetProperty(MinLengthJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets pattern.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithPattern(Corvus.Json.JsonRegex value)
        {
            return this.SetProperty(PatternJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets maxItems.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMaxItems(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue value)
        {
            return this.SetProperty(MaxItemsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets minItems.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMinItems(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity value)
        {
            return this.SetProperty(MinItemsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets uniqueItems.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithUniqueItems(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.UniqueItemsValue value)
        {
            return this.SetProperty(UniqueItemsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets maxContains.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMaxContains(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue value)
        {
            return this.SetProperty(MaxContainsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets minContains.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMinContains(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MinContainsEntity value)
        {
            return this.SetProperty(MinContainsJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets maxProperties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMaxProperties(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue value)
        {
            return this.SetProperty(MaxPropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets minProperties.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithMinProperties(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity value)
        {
            return this.SetProperty(MinPropertiesJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets required.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithRequired(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray value)
        {
            return this.SetProperty(RequiredJsonPropertyName, value);
        }

        
        /// <summary>
        /// Sets dependentRequired.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <returns>The entity with the updated property.</returns>
        public Validation WithDependentRequired(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.DependentRequiredValue value)
        {
            return this.SetProperty(DependentRequiredJsonPropertyName, value);
        }

        
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject.GetHashCode(),
                        JsonValueKind.Array => this.AsArray().GetHashCode(),
                        JsonValueKind.Number => this.AsNumber().GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
                if (this.booleanBacking is bool booleanBacking)
            {
                writer.WriteBooleanValue(booleanBacking);
                return;
            }
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
        
        
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

                /// <inheritdoc/>
        public bool TryGetDefault(string name, out JsonAny value)
        {
            return __CorvusDefaults.TryGetValue(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<char> name, out JsonAny value)
        {
            return __CorvusDefaults.TryGetValue(name.ToString(), out value);
        }

        /// <inheritdoc/>
        public bool TryGetDefault(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return __CorvusDefaults.TryGetValue(System.Text.Encoding.UTF8.GetString(utf8name), out value);
        }

        /// <inheritdoc/>
        public bool HasDefault(string name)
        {
            return __CorvusDefaults.TryGetValue(name, out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<char> name)
        {
            return __CorvusDefaults.TryGetValue(name.ToString(), out _);
        }

        /// <inheritdoc/>
        public bool HasDefault(ReadOnlySpan<byte> utf8name)
        {
            return __CorvusDefaults.TryGetValue(System.Text.Encoding.UTF8.GetString(utf8name), out _);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(Validation other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name.ToString(), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(System.Text.Encoding.UTF8.GetString(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public Validation SetProperty<TValue>(string name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Validation SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Validation SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public Validation RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Validation RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public Validation RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<Validation, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

            /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        private JsonObject AsObject
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

                return new JsonObject(this.jsonElementBacking);
            }
        }
    
    
    
    
            /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        private JsonBoolean AsBoolean
        {
            get
            {
                if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonBoolean(booleanBacking);
                }

                return new JsonBoolean(this.jsonElementBacking);
            }
        }
    
    
    
            private static ImmutableDictionary<string, JsonAny> BuildDefaults()
        {
            ImmutableDictionary<string, JsonAny>.Builder builder =
                ImmutableDictionary.CreateBuilder<string, JsonAny>();

                    builder.Add(MinLengthJsonPropertyName, JsonAny.Parse("0"));
                    builder.Add(MinItemsJsonPropertyName, JsonAny.Parse("0"));
                    builder.Add(UniqueItemsJsonPropertyName, JsonAny.Parse("false"));
                    builder.Add(MinContainsJsonPropertyName, JsonAny.Parse("1"));
                    builder.Add(MinPropertiesJsonPropertyName, JsonAny.Parse("0"));
                    builder.Add(RequiredJsonPropertyName, JsonAny.Parse("[]"));
                    return builder.ToImmutable();
        }
    
    
    
        private static ImmutableDictionary<string, PropertyValidator<Validation>> CreateLocalPropertyValidators()
        {
            ImmutableDictionary<string, PropertyValidator<Validation>>.Builder builder =
                ImmutableDictionary.CreateBuilder<string, PropertyValidator<Validation>>();

                    builder.Add(
                TypeJsonPropertyName, __CorvusValidateType);
                    builder.Add(
                ConstJsonPropertyName, __CorvusValidateConst);
                    builder.Add(
                EnumJsonPropertyName, __CorvusValidateEnum);
                    builder.Add(
                MultipleOfJsonPropertyName, __CorvusValidateMultipleOf);
                    builder.Add(
                MaximumJsonPropertyName, __CorvusValidateMaximum);
                    builder.Add(
                ExclusiveMaximumJsonPropertyName, __CorvusValidateExclusiveMaximum);
                    builder.Add(
                MinimumJsonPropertyName, __CorvusValidateMinimum);
                    builder.Add(
                ExclusiveMinimumJsonPropertyName, __CorvusValidateExclusiveMinimum);
                    builder.Add(
                MaxLengthJsonPropertyName, __CorvusValidateMaxLength);
                    builder.Add(
                MinLengthJsonPropertyName, __CorvusValidateMinLength);
                    builder.Add(
                PatternJsonPropertyName, __CorvusValidatePattern);
                    builder.Add(
                MaxItemsJsonPropertyName, __CorvusValidateMaxItems);
                    builder.Add(
                MinItemsJsonPropertyName, __CorvusValidateMinItems);
                    builder.Add(
                UniqueItemsJsonPropertyName, __CorvusValidateUniqueItems);
                    builder.Add(
                MaxContainsJsonPropertyName, __CorvusValidateMaxContains);
                    builder.Add(
                MinContainsJsonPropertyName, __CorvusValidateMinContains);
                    builder.Add(
                MaxPropertiesJsonPropertyName, __CorvusValidateMaxProperties);
                    builder.Add(
                MinPropertiesJsonPropertyName, __CorvusValidateMinProperties);
                    builder.Add(
                RequiredJsonPropertyName, __CorvusValidateRequired);
                    builder.Add(
                DependentRequiredJsonPropertyName, __CorvusValidateDependentRequired);
        
            return builder.ToImmutable();
        }

                private static ValidationContext __CorvusValidateType(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity property = that.Type;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateConst(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            Corvus.Json.JsonAny property = that.Const;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateEnum(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonAnyArray property = that.Enum;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMultipleOf(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MultipleOfValue property = that.MultipleOf;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMaximum(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            Corvus.Json.JsonNumber property = that.Maximum;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateExclusiveMaximum(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            Corvus.Json.JsonNumber property = that.ExclusiveMaximum;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMinimum(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            Corvus.Json.JsonNumber property = that.Minimum;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateExclusiveMinimum(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            Corvus.Json.JsonNumber property = that.ExclusiveMinimum;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMaxLength(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue property = that.MaxLength;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMinLength(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity property = that.MinLength;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidatePattern(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            Corvus.Json.JsonRegex property = that.Pattern;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMaxItems(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue property = that.MaxItems;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMinItems(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity property = that.MinItems;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateUniqueItems(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.UniqueItemsValue property = that.UniqueItems;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMaxContains(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue property = that.MaxContains;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMinContains(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.MinContainsEntity property = that.MinContains;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMaxProperties(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue property = that.MaxProperties;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateMinProperties(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerDefault0Entity property = that.MinProperties;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateRequired(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray property = that.Required;
            return property.Validate(validationContext, level);
        }
                private static ValidationContext __CorvusValidateDependentRequired(in Validation that, in ValidationContext validationContext, ValidationLevel level)
        {
            IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.DependentRequiredValue property = that.DependentRequired;
            return property.Validate(validationContext, level);
        }
            
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

                    int propertyCount = 0;
        
        
            foreach (Property property in this.EnumerateObject())
            {
                string propertyName = property.Name;

        
                        if (__CorvusLocalProperties.TryGetValue(propertyName, out PropertyValidator<Validation>? propertyValidator))
                {
                    result = result.WithLocalProperty(propertyCount);
                    var propertyResult = propertyValidator(this, result.CreateChildContext(), level);
                    result = result.MergeResults(propertyResult.IsValid, level, propertyResult);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }

            
                }
        
        
        
        
        
        
                
                propertyCount++;

                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Corvus.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
                
            ValidationContext localResultBoolean = Corvus.Json.Validate.TypeBoolean(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultBoolean.IsValid)
            {
                return validationContext;
            }

            if (localResultBoolean.IsValid)
            {
                isValid = true;
            }

        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
        
                
                , localResultBoolean
        
                        );

            return result;
        }

    
    
    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct TypeEntity :
                IJsonArray<TypeEntity>,
                IEquatable<TypeEntity>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
            private readonly ImmutableList<JsonAny>? arrayBacking;
    
    
            private readonly string? stringBacking;
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public TypeEntity(JsonElement value)
        {
            this.jsonElementBacking = value;
                    this.arrayBacking = default;
                        this.stringBacking = default;
                }

    
            /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="value">An array list.</param>
        public TypeEntity(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
                                    this.stringBacking = default;
                            this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="jsonArray">The <see cref="JsonArray"/> from which to construct the value.</param>
        public TypeEntity(JsonArray jsonArray)
        {
            if (jsonArray.HasJsonElement)
            {
                this.jsonElementBacking = jsonArray.AsJsonElement;
                this.arrayBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.arrayBacking = jsonArray.AsItemsList;
            }

                                    this.stringBacking = default;
                        }
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public TypeEntity(string value)
        {
            this.jsonElementBacking = default;
                            this.arrayBacking = default;
                                    this.stringBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public TypeEntity(ReadOnlySpan<char> value)
        {
            this.jsonElementBacking = default;
                            this.arrayBacking = default;
                                    this.stringBacking = value.ToString();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public TypeEntity(ReadOnlySpan<byte> value)
        {
            this.jsonElementBacking = default;
                            this.arrayBacking = default;
                                    this.stringBacking = System.Text.Encoding.UTF8.GetString(value);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="jsonString">The <see cref="JsonString"/> from which to construct the value.</param>
        public TypeEntity(JsonString jsonString)
        {
            if (jsonString.HasJsonElement)
            {
                this.jsonElementBacking = jsonString.AsJsonElement;
                this.stringBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.stringBacking = jsonString;
            }

                            this.arrayBacking = default;
                                }
    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="conversion">The <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity"/> from which to construct the value.</param>
        public TypeEntity(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity conversion)
        {
            if (conversion.HasJsonElement)
            {
                this.jsonElementBacking = conversion.AsJsonElement;
                
                        this.arrayBacking = default;
                                        this.stringBacking = default;
                    }
            else
            {
                this.jsonElementBacking = default;
                
                        this.arrayBacking = default;
                                        if (conversion.ValueKind == JsonValueKind.String)
                {
                    this.stringBacking = conversion;
                }
                else
                {
                    this.stringBacking = default;
                }
                    }
        }
            /// <summary>
        /// Initializes a new instance of the <see cref="TypeEntity"/> struct.
        /// </summary>
        /// <param name="conversion">The <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray"/> from which to construct the value.</param>
        public TypeEntity(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray conversion)
        {
            if (conversion.HasJsonElement)
            {
                this.jsonElementBacking = conversion.AsJsonElement;
                
                        this.arrayBacking = default;
                                        this.stringBacking = default;
                    }
            else
            {
                this.jsonElementBacking = default;
                
                        if (conversion.ValueKind == JsonValueKind.Array)
                {
                    this.arrayBacking = conversion;
                }
                else
                {
                    this.arrayBacking = default;
                }
                                        this.stringBacking = default;
                    }
        }
    

            /// <inheritdoc/>
        public int Length
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> items)
                {
                    return items.Count;
                }

                return this.jsonElementBacking.GetArrayLength();
            }
        }
    
            /// <summary>
        /// Gets the value as a <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity" />.
        /// </summary>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity AsSimpleTypesEntity
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is a valid <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity" />.
        /// </summary>
        public bool IsSimpleTypesEntity
        {
            get
            {
                return ((IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity)this).Validate().IsValid;
            }
        }

            /// <summary>
        /// Gets the value as a <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray" />.
        /// </summary>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray AsSimpleTypesEntityArray
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is a valid <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray" />.
        /// </summary>
        public bool IsSimpleTypesEntityArray
        {
            get
            {
                return ((IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray)this).Validate().IsValid;
            }
        }

    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                        this.arrayBacking is null
                                &&
                    this.stringBacking is null
        
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return JsonArray.ItemsToJsonElement(arrayBacking);
                }
    
    
                    if (this.stringBacking is string stringBacking)
                {
                    return JsonString.StringToJsonElement(stringBacking);
                }

    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny>)
                {
                    return JsonValueKind.Array;
                }

    
    
                    if (this.stringBacking is string)
                {
                    return JsonValueKind.String;
                }

    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonAny(arrayBacking);
                }

    
    
                    if (this.stringBacking is string stringBacking)
                {
                    return new JsonAny(stringBacking);
                }

    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

            /// <summary>
        /// Conversion from <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity value)
        {
            return new TypeEntity(value);
        }

        /// <summary>
        /// Conversion to <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity(TypeEntity value)
        {
                                    if (value.ValueKind == JsonValueKind.String)
            {
                return new IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity(value.AsString);
            }
                                    return default;
        }
            /// <summary>
        /// Conversion from <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray value)
        {
            return new TypeEntity(value);
        }

        /// <summary>
        /// Conversion to <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray(TypeEntity value)
        {
                            if (value.ValueKind == JsonValueKind.Array)
            {
                return new IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray(value.AsArray);
            }
                                            return default;
        }
    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new TypeEntity(value.AsJsonElement);
            }

            return value.As<TypeEntity>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(TypeEntity value)
        {
            return value.AsAny;
        }

    
        /// <summary>
        /// Conversion from array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(JsonArray value)
        {
            return new TypeEntity(value);
        }

        /// <summary>
        /// Conversion to array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonArray(TypeEntity value)
        {
            return value.AsArray;
        }
       
        /// <summary>
        /// Implicit conversion to an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(TypeEntity value)
        {
            return value.AsArray.AsItemsList;
        }

        /// <summary>
        /// Implicit conversion from an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(ImmutableList<JsonAny> value)
        {
            return new TypeEntity(value);
        }
    
    
    
        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(string value)
        {
            return new TypeEntity(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator string(TypeEntity value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(ReadOnlySpan<char> value)
        {
            return new TypeEntity(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator ReadOnlySpan<char>(TypeEntity value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from utf8 bytes.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(ReadOnlySpan<byte> value)
        {
            return new TypeEntity(value);
        }

        /// <summary>
        /// Conversion to utf8 bytes.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator ReadOnlySpan<byte>(TypeEntity value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator TypeEntity(JsonString value)
        {
            return new TypeEntity(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonString(TypeEntity value)
        {
            return value.AsString;
        }

    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(TypeEntity lhs, TypeEntity rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(TypeEntity lhs, TypeEntity rhs)
        {
            return !lhs.Equals(rhs);
        }

                            /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="items">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static TypeEntity From(params JsonAny[] items)
        {
            return new TypeEntity(items.ToImmutableList());
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static TypeEntity From(JsonAny item1)
        {
            return new TypeEntity(ImmutableList.Create(item1));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static TypeEntity From(JsonAny item1, JsonAny item2)
        {
            return new TypeEntity(ImmutableList.Create(item1, item2));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static TypeEntity From(JsonAny item1, JsonAny item2, JsonAny item3)
        {
            return new TypeEntity(ImmutableList.Create(item1, item2, item3));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <param name="item4">The fourth item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static TypeEntity From(JsonAny item1, JsonAny item2, JsonAny item3, JsonAny item4)
        {
            return new TypeEntity(ImmutableList.Create(item1, item2, item3, item4));
        }
        
    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray.GetHashCode(),
                        JsonValueKind.Number => this.AsNumber().GetHashCode(),
                        JsonValueKind.String => this.AsString.GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
            {
                JsonArray.WriteItems(arrayBacking, writer);
                return;
            }

    
    
                if (this.stringBacking is string stringBacking)
            {
                writer.WriteStringValue(stringBacking);
                return;
            }

    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
                /// <inheritdoc/>
        public JsonArrayEnumerator EnumerateArray()
        {
            return this.AsArray.EnumerateArray();
        }
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString.Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(TypeEntity other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString.Equals(other.AsString),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public TypeEntity Add<TItem>(TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity Add<TItem1, TItem2>(TItem1 item1, TItem2 item2)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity Add<TItem1, TItem2, TItem3>(TItem1 item1, TItem2 item2, TItem3 item3)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity Add<TItem1, TItem2, TItem3, TItem4>(TItem1 item1, TItem2 item2, TItem3 item3, TItem4 item4)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
            where TItem4 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3, item4);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity Add<TItem>(params TItem[] items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity AddRange<TItem>(IEnumerable<TItem> items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.AddRange(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity Insert<TItem>(int index, TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Insert(index, item);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity Replace<TItem>(TItem oldValue, TItem newValue)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.Replace(oldValue, newValue);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity RemoveAt(int index)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveAt(index);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity RemoveRange(int index, int count)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveRange(index, count);
            }

            return this;
        }

        /// <inheritdoc/>
        public TypeEntity SetItem<TItem>(int index, TItem value)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.SetItem(index, value);
            }

            return this;
        }

    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<TypeEntity, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
    
    
    
    
        
    
    
    
    
                result = this.ValidateAnyOf(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    
    
    

                return result;
        }

    
            /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        private JsonArray AsArray
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonArray(arrayBacking);
                }

                return new JsonArray(this.jsonElementBacking);
            }
        }
    
    
            /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        private JsonString AsString
        {
            get
            {
                if (this.stringBacking is string stringBacking)
                {
                    return new JsonString(stringBacking);
                }

                return new JsonString(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
    
            

            
        private ValidationContext ValidateAnyOf(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            bool foundValid = false;

                

            ValidationContext anyOfResult0 = this.As<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity>().Validate(validationContext.CreateChildContext(), level);

            if (anyOfResult0.IsValid)
            {
                result = result.MergeChildContext(anyOfResult0, level >= ValidationLevel.Detailed);
                            if (level == ValidationLevel.Flag)
                {
                    return result;
                }
                else
                {
                    foundValid = true;
                }
                        }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult0);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult0);
                }
            }

                

            ValidationContext anyOfResult1 = this.As<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.TypeEntity.SimpleTypesEntityArray>().Validate(validationContext.CreateChildContext(), level);

            if (anyOfResult1.IsValid)
            {
                result = result.MergeChildContext(anyOfResult1, level >= ValidationLevel.Detailed);
                            if (level == ValidationLevel.Flag)
                {
                    return result;
                }
                else
                {
                    foundValid = true;
                }
                        }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult1);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, anyOfResult1);
                }
            }

        
            if (foundValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: true, "Validation 10.2.1.2. anyOf - validated against the anyOf schema.");
                }
            }
            else
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.2. anyOf - failed to validate against the anyOf schema.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "Validation 10.2.1.2. anyOf - failed to validate against the anyOf schema.");
                }
                else
                {
                    result = result.WithResult(isValid: false);
                }
            }

            return result;
        }

            

            

            

    
    
    
    
    
    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct SimpleTypesEntityArray :
                IJsonArray<SimpleTypesEntityArray>,
                IEquatable<SimpleTypesEntityArray>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
            private readonly ImmutableList<JsonAny>? arrayBacking;
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="SimpleTypesEntityArray"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public SimpleTypesEntityArray(JsonElement value)
        {
            this.jsonElementBacking = value;
                    this.arrayBacking = default;
                        }

    
            /// <summary>
        /// Initializes a new instance of the <see cref="SimpleTypesEntityArray"/> struct.
        /// </summary>
        /// <param name="value">An array list.</param>
        public SimpleTypesEntityArray(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
                                            this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SimpleTypesEntityArray"/> struct.
        /// </summary>
        /// <param name="jsonArray">The <see cref="JsonArray"/> from which to construct the value.</param>
        public SimpleTypesEntityArray(JsonArray jsonArray)
        {
            if (jsonArray.HasJsonElement)
            {
                this.jsonElementBacking = jsonArray.AsJsonElement;
                this.arrayBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.arrayBacking = jsonArray.AsItemsList;
            }

                                        }
    
    
    
    
    
    

            /// <inheritdoc/>
        public int Length
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> items)
                {
                    return items.Count;
                }

                return this.jsonElementBacking.GetArrayLength();
            }
        }
    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                        this.arrayBacking is null
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return JsonArray.ItemsToJsonElement(arrayBacking);
                }
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny>)
                {
                    return JsonValueKind.Array;
                }

    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonAny(arrayBacking);
                }

    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SimpleTypesEntityArray(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new SimpleTypesEntityArray(value.AsJsonElement);
            }

            return value.As<SimpleTypesEntityArray>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(SimpleTypesEntityArray value)
        {
            return value.AsAny;
        }

    
        /// <summary>
        /// Conversion from array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SimpleTypesEntityArray(JsonArray value)
        {
            return new SimpleTypesEntityArray(value);
        }

        /// <summary>
        /// Conversion to array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonArray(SimpleTypesEntityArray value)
        {
            return value.AsArray;
        }
       
        /// <summary>
        /// Implicit conversion to an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(SimpleTypesEntityArray value)
        {
            return value.AsArray.AsItemsList;
        }

        /// <summary>
        /// Implicit conversion from an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SimpleTypesEntityArray(ImmutableList<JsonAny> value)
        {
            return new SimpleTypesEntityArray(value);
        }
    
    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(SimpleTypesEntityArray lhs, SimpleTypesEntityArray rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(SimpleTypesEntityArray lhs, SimpleTypesEntityArray rhs)
        {
            return !lhs.Equals(rhs);
        }

                    /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="items">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SimpleTypesEntityArray From(params IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity[] items)
        {
            var builder = ImmutableList.CreateBuilder<JsonAny>();
            foreach (var item in items)
            {
                builder.Add(item);
            }

            return new SimpleTypesEntityArray(builder.ToImmutable());
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SimpleTypesEntityArray From(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item1)
        {
            return new SimpleTypesEntityArray(ImmutableList.Create((JsonAny)item1));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SimpleTypesEntityArray From(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item1, IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item2)
        {
            return new SimpleTypesEntityArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SimpleTypesEntityArray From(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item1, IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item2, IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item3)
        {
            return new SimpleTypesEntityArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2, (JsonAny)item3));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <param name="item4">The fourth item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static SimpleTypesEntityArray From(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item1, IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item2, IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item3, IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity item4)
        {
            return new SimpleTypesEntityArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2, (JsonAny)item3, (JsonAny)item4));
        }
        
    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray.GetHashCode(),
                        JsonValueKind.Number => this.AsNumber().GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
            {
                JsonArray.WriteItems(arrayBacking, writer);
                return;
            }

    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
                /// <summary>
        /// Enumerate the items in the array as a <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity" />.
        /// </summary>
        public JsonArrayEnumerator<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity> EnumerateItems()
        {
            if (this.arrayBacking is ImmutableList<JsonAny> items)
            {
                return new JsonArrayEnumerator<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity>(items);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return new JsonArrayEnumerator<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity>(this.jsonElementBacking);
            }

            return default;
        }
                /// <inheritdoc/>
        public JsonArrayEnumerator EnumerateArray()
        {
            return this.AsArray.EnumerateArray();
        }
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(SimpleTypesEntityArray other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public SimpleTypesEntityArray Add<TItem>(TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray Add<TItem1, TItem2>(TItem1 item1, TItem2 item2)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray Add<TItem1, TItem2, TItem3>(TItem1 item1, TItem2 item2, TItem3 item3)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray Add<TItem1, TItem2, TItem3, TItem4>(TItem1 item1, TItem2 item2, TItem3 item3, TItem4 item4)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
            where TItem4 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3, item4);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray Add<TItem>(params TItem[] items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray AddRange<TItem>(IEnumerable<TItem> items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.AddRange(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray Insert<TItem>(int index, TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Insert(index, item);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray Replace<TItem>(TItem oldValue, TItem newValue)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.Replace(oldValue, newValue);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray RemoveAt(int index)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveAt(index);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray RemoveRange(int index, int count)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveRange(index, count);
            }

            return this;
        }

        /// <inheritdoc/>
        public SimpleTypesEntityArray SetItem<TItem>(int index, TItem value)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.SetItem(index, value);
            }

            return this;
        }

    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<SimpleTypesEntityArray, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
    

                result = this.ValidateArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
                return result;
        }

    
            /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        private JsonArray AsArray
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonArray(arrayBacking);
                }

                return new JsonArray(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
    
            private ValidationContext ValidateArray(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Array)
            {
                return result;
            }

         
            int arrayLength = 0;
         
        
                     JsonArrayEnumerator arrayEnumerator = this.EnumerateArray();

            while (arrayEnumerator.MoveNext())
            {
                        JsonArrayEnumerator innerEnumerator = this.EnumerateArray();
                int innerIndex = -1;
                while (innerIndex < arrayLength && innerEnumerator.MoveNext())
                {
                    innerIndex++;
                }

                while (innerEnumerator.MoveNext())
                {
                    if (innerEnumerator.Current.Equals(arrayEnumerator.Current))
                    {
                        if (level >= ValidationLevel.Detailed)
                        {
                            result = result.WithResult(isValid: false, $"6.4.3. uniqueItems - duplicate items were found at indices {arrayLength} and {innerIndex}.");
                        }
                        else if (level >= ValidationLevel.Basic)
                        {
                            result = result.WithResult(isValid: false, "6.4.3. uniqueItems - duplicate items were found.");
                        }
                        else
                        {
                            return result.WithResult(isValid: false);
                        }
                    }
                }

        
        
                        result = arrayEnumerator.Current.As<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.SimpleTypesEntity>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                result = result.WithLocalItemIndex(arrayLength);

        
                arrayLength++;
            }
        
        
                    if (arrayLength < 1)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = result.WithResult(isValid: false, $"6.4.2. minItems - {arrayLength} is less than the minimum number of items 1.");
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = result.WithResult(isValid: false, "6.4.2. minItems - item count is less than the minimum number of items 1.");
                }
                else
                {
                    return result.WithResult(isValid: false);
                }

            }
        
        
            return result;
        }

    
    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
        
                
            ValidationContext localResultArray = Corvus.Json.Validate.TypeArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultArray.IsValid)
            {
                return validationContext;
            }

            if (localResultArray.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
        
                
                , localResultArray
        
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct JsonAnyArray :
                IJsonArray<JsonAnyArray>,
                IEquatable<JsonAnyArray>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
            private readonly ImmutableList<JsonAny>? arrayBacking;
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="JsonAnyArray"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public JsonAnyArray(JsonElement value)
        {
            this.jsonElementBacking = value;
                    this.arrayBacking = default;
                        }

    
            /// <summary>
        /// Initializes a new instance of the <see cref="JsonAnyArray"/> struct.
        /// </summary>
        /// <param name="value">An array list.</param>
        public JsonAnyArray(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
                                            this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonAnyArray"/> struct.
        /// </summary>
        /// <param name="jsonArray">The <see cref="JsonArray"/> from which to construct the value.</param>
        public JsonAnyArray(JsonArray jsonArray)
        {
            if (jsonArray.HasJsonElement)
            {
                this.jsonElementBacking = jsonArray.AsJsonElement;
                this.arrayBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.arrayBacking = jsonArray.AsItemsList;
            }

                                        }
    
    
    
    
    
    

            /// <inheritdoc/>
        public int Length
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> items)
                {
                    return items.Count;
                }

                return this.jsonElementBacking.GetArrayLength();
            }
        }
    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                        this.arrayBacking is null
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return JsonArray.ItemsToJsonElement(arrayBacking);
                }
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny>)
                {
                    return JsonValueKind.Array;
                }

    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonAny(arrayBacking);
                }

    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAnyArray(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new JsonAnyArray(value.AsJsonElement);
            }

            return value.As<JsonAnyArray>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(JsonAnyArray value)
        {
            return value.AsAny;
        }

    
        /// <summary>
        /// Conversion from array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAnyArray(JsonArray value)
        {
            return new JsonAnyArray(value);
        }

        /// <summary>
        /// Conversion to array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonArray(JsonAnyArray value)
        {
            return value.AsArray;
        }
       
        /// <summary>
        /// Implicit conversion to an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(JsonAnyArray value)
        {
            return value.AsArray.AsItemsList;
        }

        /// <summary>
        /// Implicit conversion from an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAnyArray(ImmutableList<JsonAny> value)
        {
            return new JsonAnyArray(value);
        }
    
    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(JsonAnyArray lhs, JsonAnyArray rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(JsonAnyArray lhs, JsonAnyArray rhs)
        {
            return !lhs.Equals(rhs);
        }

                            /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="items">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonAnyArray From(params JsonAny[] items)
        {
            return new JsonAnyArray(items.ToImmutableList());
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonAnyArray From(JsonAny item1)
        {
            return new JsonAnyArray(ImmutableList.Create(item1));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonAnyArray From(JsonAny item1, JsonAny item2)
        {
            return new JsonAnyArray(ImmutableList.Create(item1, item2));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonAnyArray From(JsonAny item1, JsonAny item2, JsonAny item3)
        {
            return new JsonAnyArray(ImmutableList.Create(item1, item2, item3));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <param name="item4">The fourth item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonAnyArray From(JsonAny item1, JsonAny item2, JsonAny item3, JsonAny item4)
        {
            return new JsonAnyArray(ImmutableList.Create(item1, item2, item3, item4));
        }
        
    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray.GetHashCode(),
                        JsonValueKind.Number => this.AsNumber().GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
            {
                JsonArray.WriteItems(arrayBacking, writer);
                return;
            }

    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
                /// <inheritdoc/>
        public JsonArrayEnumerator EnumerateArray()
        {
            return this.AsArray.EnumerateArray();
        }
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(JsonAnyArray other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public JsonAnyArray Add<TItem>(TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray Add<TItem1, TItem2>(TItem1 item1, TItem2 item2)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray Add<TItem1, TItem2, TItem3>(TItem1 item1, TItem2 item2, TItem3 item3)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray Add<TItem1, TItem2, TItem3, TItem4>(TItem1 item1, TItem2 item2, TItem3 item3, TItem4 item4)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
            where TItem4 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3, item4);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray Add<TItem>(params TItem[] items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray AddRange<TItem>(IEnumerable<TItem> items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.AddRange(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray Insert<TItem>(int index, TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Insert(index, item);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray Replace<TItem>(TItem oldValue, TItem newValue)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.Replace(oldValue, newValue);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray RemoveAt(int index)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveAt(index);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray RemoveRange(int index, int count)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveRange(index, count);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonAnyArray SetItem<TItem>(int index, TItem value)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.SetItem(index, value);
            }

            return this;
        }

    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<JsonAnyArray, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
    

                result = this.ValidateArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
                return result;
        }

    
            /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        private JsonArray AsArray
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonArray(arrayBacking);
                }

                return new JsonArray(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
    
            private ValidationContext ValidateArray(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Array)
            {
                return result;
            }

         
            int arrayLength = 0;
         
        
                     JsonArrayEnumerator arrayEnumerator = this.EnumerateArray();

            while (arrayEnumerator.MoveNext())
            {
        
        
                        result = arrayEnumerator.Current.As<Corvus.Json.JsonAny>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                result = result.WithLocalItemIndex(arrayLength);

        
                arrayLength++;
            }
        
        
        
        
            return result;
        }

    
    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
        
                
            ValidationContext localResultArray = Corvus.Json.Validate.TypeArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultArray.IsValid)
            {
                return validationContext;
            }

            if (localResultArray.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
        
                
                , localResultArray
        
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct MultipleOfValue :
                    IJsonValue,
            IEquatable<MultipleOfValue>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
    
            private readonly double? numberBacking;
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleOfValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public MultipleOfValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                        this.numberBacking = default;
                    }

    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="MultipleOfValue"/> struct.
        /// </summary>
        /// <param name="jsonNumber">The <see cref="JsonNumber"/> from which to construct the value.</param>
        public MultipleOfValue(JsonNumber jsonNumber)
        {
            if (jsonNumber.HasJsonElement)
            {
                this.jsonElementBacking = jsonNumber.AsJsonElement;
                this.numberBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.numberBacking = jsonNumber.GetDouble();
            }
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleOfValue"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public MultipleOfValue(double value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleOfValue"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public MultipleOfValue(int value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleOfValue"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public MultipleOfValue(float value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MultipleOfValue"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public MultipleOfValue(long value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }
    
    
    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                            this.numberBacking is null
            
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
    
                    if (this.numberBacking is double numberBacking)
                {
                    return JsonNumber.NumberToJsonElement(numberBacking);
                }

    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
    
                    if (this.numberBacking is double)
                {
                    return JsonValueKind.Number;
                }

    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
    
                    if (this.numberBacking is double numberBacking)
                {
                    return new JsonAny(numberBacking);
                }

    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MultipleOfValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new MultipleOfValue(value.AsJsonElement);
            }

            return value.As<MultipleOfValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(MultipleOfValue value)
        {
            return value.AsAny;
        }

    
    
    
    
        /// <summary>
        /// Conversion from double.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MultipleOfValue(double value)
        {
            return new MultipleOfValue(value);
        }

        /// <summary>
        /// Conversion to double.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator double(MultipleOfValue number)
        {
            return number.AsNumber.GetDouble();
        }

        /// <summary>
        /// Conversion from float.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MultipleOfValue(float value)
        {
            return new MultipleOfValue(value);
        }

        /// <summary>
        /// Conversion to float.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator float(MultipleOfValue number)
        {
            return number.AsNumber.GetSingle();
        }

        /// <summary>
        /// Conversion from long.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MultipleOfValue(long value)
        {
            return new MultipleOfValue(value);
        }

        /// <summary>
        /// Conversion to long.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator long(MultipleOfValue number)
        {
            return number.AsNumber.GetInt64();
        }

        /// <summary>
        /// Conversion from int.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MultipleOfValue(int value)
        {
            return new MultipleOfValue(value);
        }

        /// <summary>
        /// Conversion to int.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator int(MultipleOfValue number)
        {
            return number.AsNumber.GetInt32();
        }

        /// <summary>
        /// Conversion from number.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MultipleOfValue(JsonNumber value)
        {
            return new MultipleOfValue(value);
        }

        /// <summary>
        /// Conversion to number.
        /// </summary>
        /// <param name="number">The value from which to convert.</param>
        public static implicit operator JsonNumber(MultipleOfValue number)
        {
            return number.AsNumber;
        }

    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(MultipleOfValue lhs, MultipleOfValue rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(MultipleOfValue lhs, MultipleOfValue rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray().GetHashCode(),
                        JsonValueKind.Number => this.AsNumber.GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
    
                if (this.numberBacking is double numberBacking)
            {
                writer.WriteNumberValue(numberBacking);
                return;
            }

    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(MultipleOfValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<MultipleOfValue, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
                result = Corvus.Json.Validate.ValidateNumber(
                this,
                result,
                level,
                        null,
                                null,
                                null,
                                null,
                                 0
                        );

            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

        
    
    
    
    
    
    
    

                return result;
        }

    
    
            /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        private JsonNumber AsNumber
        {
            get
            {
                if (this.numberBacking is double numberBacking)
                {
                    return new JsonNumber(numberBacking);
                }

                return new JsonNumber(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
    
    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
        
        
                
            ValidationContext localResultNumber = Corvus.Json.Validate.TypeNumber(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultNumber.IsValid)
            {
                return validationContext;
            }

            if (localResultNumber.IsValid)
            {
                isValid = true;
            }

        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
        
        
                
                , localResultNumber
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct NonNegativeIntegerValue :
                    IJsonValue,
            IEquatable<NonNegativeIntegerValue>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
    
            private readonly double? numberBacking;
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public NonNegativeIntegerValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                        this.numberBacking = default;
                    }

    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerValue"/> struct.
        /// </summary>
        /// <param name="jsonNumber">The <see cref="JsonNumber"/> from which to construct the value.</param>
        public NonNegativeIntegerValue(JsonNumber jsonNumber)
        {
            if (jsonNumber.HasJsonElement)
            {
                this.jsonElementBacking = jsonNumber.AsJsonElement;
                this.numberBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.numberBacking = jsonNumber.GetDouble();
            }
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerValue"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public NonNegativeIntegerValue(double value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerValue"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public NonNegativeIntegerValue(int value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerValue"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public NonNegativeIntegerValue(float value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerValue"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public NonNegativeIntegerValue(long value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }
    
    
    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                            this.numberBacking is null
            
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
    
                    if (this.numberBacking is double numberBacking)
                {
                    return JsonNumber.NumberToJsonElement(numberBacking);
                }

    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
    
                    if (this.numberBacking is double)
                {
                    return JsonValueKind.Number;
                }

    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
    
                    if (this.numberBacking is double numberBacking)
                {
                    return new JsonAny(numberBacking);
                }

    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new NonNegativeIntegerValue(value.AsJsonElement);
            }

            return value.As<NonNegativeIntegerValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(NonNegativeIntegerValue value)
        {
            return value.AsAny;
        }

    
    
    
    
        /// <summary>
        /// Conversion from double.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerValue(double value)
        {
            return new NonNegativeIntegerValue(value);
        }

        /// <summary>
        /// Conversion to double.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator double(NonNegativeIntegerValue number)
        {
            return number.AsNumber.GetDouble();
        }

        /// <summary>
        /// Conversion from float.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerValue(float value)
        {
            return new NonNegativeIntegerValue(value);
        }

        /// <summary>
        /// Conversion to float.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator float(NonNegativeIntegerValue number)
        {
            return number.AsNumber.GetSingle();
        }

        /// <summary>
        /// Conversion from long.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerValue(long value)
        {
            return new NonNegativeIntegerValue(value);
        }

        /// <summary>
        /// Conversion to long.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator long(NonNegativeIntegerValue number)
        {
            return number.AsNumber.GetInt64();
        }

        /// <summary>
        /// Conversion from int.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerValue(int value)
        {
            return new NonNegativeIntegerValue(value);
        }

        /// <summary>
        /// Conversion to int.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator int(NonNegativeIntegerValue number)
        {
            return number.AsNumber.GetInt32();
        }

        /// <summary>
        /// Conversion from number.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerValue(JsonNumber value)
        {
            return new NonNegativeIntegerValue(value);
        }

        /// <summary>
        /// Conversion to number.
        /// </summary>
        /// <param name="number">The value from which to convert.</param>
        public static implicit operator JsonNumber(NonNegativeIntegerValue number)
        {
            return number.AsNumber;
        }

    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(NonNegativeIntegerValue lhs, NonNegativeIntegerValue rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(NonNegativeIntegerValue lhs, NonNegativeIntegerValue rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray().GetHashCode(),
                        JsonValueKind.Number => this.AsNumber.GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
    
                if (this.numberBacking is double numberBacking)
            {
                writer.WriteNumberValue(numberBacking);
                return;
            }

    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(NonNegativeIntegerValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<NonNegativeIntegerValue, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
                result = Corvus.Json.Validate.ValidateNumber(
                this,
                result,
                level,
                        null,
                                null,
                                null,
                                 0,
                                null
                        );

            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

        
    
    
    
    
    
    
    

                return result;
        }

    
    
            /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        private JsonNumber AsNumber
        {
            get
            {
                if (this.numberBacking is double numberBacking)
                {
                    return new JsonNumber(numberBacking);
                }

                return new JsonNumber(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
    
    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
        
        
        
                
            ValidationContext localResultInteger = Corvus.Json.Validate.TypeInteger(this, result, level);
            if (level == ValidationLevel.Flag && localResultInteger.IsValid)
            {
                return validationContext;
            }

            if (localResultInteger.IsValid)
            {
                isValid = true;
            }

        
        
        
            result = result.MergeResults(
                isValid,
                level
        
        
        
        
                
                , localResultInteger
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct NonNegativeIntegerDefault0Entity :
                    IJsonValue,
            IEquatable<NonNegativeIntegerDefault0Entity>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
    
            private readonly double? numberBacking;
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerDefault0Entity"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public NonNegativeIntegerDefault0Entity(JsonElement value)
        {
            this.jsonElementBacking = value;
                        this.numberBacking = default;
                    }

    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerDefault0Entity"/> struct.
        /// </summary>
        /// <param name="jsonNumber">The <see cref="JsonNumber"/> from which to construct the value.</param>
        public NonNegativeIntegerDefault0Entity(JsonNumber jsonNumber)
        {
            if (jsonNumber.HasJsonElement)
            {
                this.jsonElementBacking = jsonNumber.AsJsonElement;
                this.numberBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.numberBacking = jsonNumber.GetDouble();
            }
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerDefault0Entity"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public NonNegativeIntegerDefault0Entity(double value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerDefault0Entity"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public NonNegativeIntegerDefault0Entity(int value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerDefault0Entity"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public NonNegativeIntegerDefault0Entity(float value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerDefault0Entity"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public NonNegativeIntegerDefault0Entity(long value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }
    
    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="NonNegativeIntegerDefault0Entity"/> struct.
        /// </summary>
        /// <param name="conversion">The <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue"/> from which to construct the value.</param>
        public NonNegativeIntegerDefault0Entity(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue conversion)
        {
            if (conversion.HasJsonElement)
            {
                this.jsonElementBacking = conversion.AsJsonElement;
                
                                this.numberBacking = default;
                            }
            else
            {
                this.jsonElementBacking = default;
                
                                if (conversion.ValueKind == JsonValueKind.Number)
                {
                    this.numberBacking = conversion;
                }
                else
                {
                    this.numberBacking = default;
                }
                            }
        }
    

    
            /// <summary>
        /// Gets the value as a <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue" />.
        /// </summary>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue AsNonNegativeIntegerValue
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is a valid <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue" />.
        /// </summary>
        public bool IsNonNegativeIntegerValue
        {
            get
            {
                return ((IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue)this).Validate().IsValid;
            }
        }

    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                            this.numberBacking is null
            
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
    
                    if (this.numberBacking is double numberBacking)
                {
                    return JsonNumber.NumberToJsonElement(numberBacking);
                }

    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
    
                    if (this.numberBacking is double)
                {
                    return JsonValueKind.Number;
                }

    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
    
                    if (this.numberBacking is double numberBacking)
                {
                    return new JsonAny(numberBacking);
                }

    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

            /// <summary>
        /// Conversion from <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerDefault0Entity(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue value)
        {
            return new NonNegativeIntegerDefault0Entity(value);
        }

        /// <summary>
        /// Conversion to <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue(NonNegativeIntegerDefault0Entity value)
        {
                                                    if (value.ValueKind == JsonValueKind.Number)
            {
                return new IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue(value.AsNumber);
            }
                    return default;
        }
    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerDefault0Entity(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new NonNegativeIntegerDefault0Entity(value.AsJsonElement);
            }

            return value.As<NonNegativeIntegerDefault0Entity>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(NonNegativeIntegerDefault0Entity value)
        {
            return value.AsAny;
        }

    
    
    
    
        /// <summary>
        /// Conversion from double.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerDefault0Entity(double value)
        {
            return new NonNegativeIntegerDefault0Entity(value);
        }

        /// <summary>
        /// Conversion to double.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator double(NonNegativeIntegerDefault0Entity number)
        {
            return number.AsNumber.GetDouble();
        }

        /// <summary>
        /// Conversion from float.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerDefault0Entity(float value)
        {
            return new NonNegativeIntegerDefault0Entity(value);
        }

        /// <summary>
        /// Conversion to float.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator float(NonNegativeIntegerDefault0Entity number)
        {
            return number.AsNumber.GetSingle();
        }

        /// <summary>
        /// Conversion from long.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerDefault0Entity(long value)
        {
            return new NonNegativeIntegerDefault0Entity(value);
        }

        /// <summary>
        /// Conversion to long.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator long(NonNegativeIntegerDefault0Entity number)
        {
            return number.AsNumber.GetInt64();
        }

        /// <summary>
        /// Conversion from int.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerDefault0Entity(int value)
        {
            return new NonNegativeIntegerDefault0Entity(value);
        }

        /// <summary>
        /// Conversion to int.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator int(NonNegativeIntegerDefault0Entity number)
        {
            return number.AsNumber.GetInt32();
        }

        /// <summary>
        /// Conversion from number.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator NonNegativeIntegerDefault0Entity(JsonNumber value)
        {
            return new NonNegativeIntegerDefault0Entity(value);
        }

        /// <summary>
        /// Conversion to number.
        /// </summary>
        /// <param name="number">The value from which to convert.</param>
        public static implicit operator JsonNumber(NonNegativeIntegerDefault0Entity number)
        {
            return number.AsNumber;
        }

    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(NonNegativeIntegerDefault0Entity lhs, NonNegativeIntegerDefault0Entity rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(NonNegativeIntegerDefault0Entity lhs, NonNegativeIntegerDefault0Entity rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray().GetHashCode(),
                        JsonValueKind.Number => this.AsNumber.GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
    
                if (this.numberBacking is double numberBacking)
            {
                writer.WriteNumberValue(numberBacking);
                return;
            }

    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(NonNegativeIntegerDefault0Entity other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<NonNegativeIntegerDefault0Entity, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

                result = this.ValidateRef(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    
    
    
    
    
        
    
    
    
    
    
    
    

                return result;
        }

    
    
            /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        private JsonNumber AsNumber
        {
            get
            {
                if (this.numberBacking is double numberBacking)
                {
                    return new JsonNumber(numberBacking);
                }

                return new JsonNumber(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
            private ValidationContext ValidateRef(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            ValidationContext refResult = this.As<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue>().Validate(validationContext.CreateChildContext(), level);

            if (!refResult.IsValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = validationContext.MergeResults(false, level, refResult);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = validationContext.MergeResults(false, level, refResult);
                }
                else
                {
                    result = validationContext.WithResult(isValid: false);
                }
            }
            else
            {
                if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, refResult);
                }

                result = result.MergeChildContext(refResult, false);
            }

            return result;
        }
    
    
    
            

            

            

            

    
    
    
    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct UniqueItemsValue :
                    IJsonValue,
            IEquatable<UniqueItemsValue>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
    
    
    
            private readonly bool? booleanBacking;
    
        /// <summary>
        /// Initializes a new instance of the <see cref="UniqueItemsValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public UniqueItemsValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                                this.booleanBacking = default;
            }

    
    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="UniqueItemsValue"/> struct.
        /// </summary>
        /// <param name="jsonBoolean">The <see cref="JsonBoolean"/> from which to construct the value.</param>
        public UniqueItemsValue(JsonBoolean jsonBoolean)
        {
            if (jsonBoolean.HasJsonElement)
            {
                this.jsonElementBacking = jsonBoolean.AsJsonElement;
                this.booleanBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.booleanBacking = jsonBoolean.GetBoolean();
            }

                                        }

                /// <summary>
        /// Initializes a new instance of the <see cref="UniqueItemsValue"/> struct.
        /// </summary>
        /// <param name="boolean">The <see cref="bool"/> from which to construct the value.</param>
        public UniqueItemsValue(bool boolean)
        {
            this.jsonElementBacking = default;
            this.booleanBacking = boolean;

                                        }

    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                                    this.booleanBacking is null
    
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return JsonBoolean.BoolToJsonElement(booleanBacking);
                }

    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return booleanBacking ? JsonValueKind.True : JsonValueKind.False;
                }

    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
    
    
    
                    if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonAny(booleanBacking);
                }

    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator UniqueItemsValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new UniqueItemsValue(value.AsJsonElement);
            }

            return value.As<UniqueItemsValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(UniqueItemsValue value)
        {
            return value.AsAny;
        }

    
    
    
    
    
        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator UniqueItemsValue(bool value)
        {
            return new UniqueItemsValue(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator bool(UniqueItemsValue boolean)
        {
            return boolean.AsBoolean.GetBoolean();
        }

        /// <summary>
        /// Conversion from bool.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator UniqueItemsValue(JsonBoolean value)
        {
            return new UniqueItemsValue(value);
        }

        /// <summary>
        /// Conversion to bool.
        /// </summary>
        /// <param name="boolean">The value from which to convert.</param>
        public static implicit operator JsonBoolean(UniqueItemsValue boolean)
        {
            return boolean.AsBoolean;
        }

    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(UniqueItemsValue lhs, UniqueItemsValue rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(UniqueItemsValue lhs, UniqueItemsValue rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray().GetHashCode(),
                        JsonValueKind.Number => this.AsNumber().GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean.GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
    
    
    
                if (this.booleanBacking is bool booleanBacking)
            {
                writer.WriteBooleanValue(booleanBacking);
                return;
            }
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(UniqueItemsValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean.Equals(other.AsBoolean),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<UniqueItemsValue, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
    

                return result;
        }

    
    
    
    
            /// <summary>
        /// Gets the value as a <see cref="JsonBoolean"/>.
        /// </summary>
        private JsonBoolean AsBoolean
        {
            get
            {
                if (this.booleanBacking is bool booleanBacking)
                {
                    return new JsonBoolean(booleanBacking);
                }

                return new JsonBoolean(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
        
        
        
        
                
            ValidationContext localResultBoolean = Corvus.Json.Validate.TypeBoolean(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultBoolean.IsValid)
            {
                return validationContext;
            }

            if (localResultBoolean.IsValid)
            {
                isValid = true;
            }

        
        
            result = result.MergeResults(
                isValid,
                level
        
        
        
        
        
                
                , localResultBoolean
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct MinContainsEntity :
                    IJsonValue,
            IEquatable<MinContainsEntity>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
    
            private readonly double? numberBacking;
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="MinContainsEntity"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public MinContainsEntity(JsonElement value)
        {
            this.jsonElementBacking = value;
                        this.numberBacking = default;
                    }

    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="MinContainsEntity"/> struct.
        /// </summary>
        /// <param name="jsonNumber">The <see cref="JsonNumber"/> from which to construct the value.</param>
        public MinContainsEntity(JsonNumber jsonNumber)
        {
            if (jsonNumber.HasJsonElement)
            {
                this.jsonElementBacking = jsonNumber.AsJsonElement;
                this.numberBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.numberBacking = jsonNumber.GetDouble();
            }
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MinContainsEntity"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public MinContainsEntity(double value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MinContainsEntity"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public MinContainsEntity(int value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MinContainsEntity"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public MinContainsEntity(float value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MinContainsEntity"/> struct.
        /// </summary>
        /// <param name="value">A number value.</param>
        public MinContainsEntity(long value)
        {
            this.jsonElementBacking = default;
                                            this.numberBacking = value;
        }
    
    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="MinContainsEntity"/> struct.
        /// </summary>
        /// <param name="conversion">The <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue"/> from which to construct the value.</param>
        public MinContainsEntity(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue conversion)
        {
            if (conversion.HasJsonElement)
            {
                this.jsonElementBacking = conversion.AsJsonElement;
                
                                this.numberBacking = default;
                            }
            else
            {
                this.jsonElementBacking = default;
                
                                if (conversion.ValueKind == JsonValueKind.Number)
                {
                    this.numberBacking = conversion;
                }
                else
                {
                    this.numberBacking = default;
                }
                            }
        }
    

    
            /// <summary>
        /// Gets the value as a <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue" />.
        /// </summary>
        public IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue AsNonNegativeIntegerValue
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this is a valid <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue" />.
        /// </summary>
        public bool IsNonNegativeIntegerValue
        {
            get
            {
                return ((IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue)this).Validate().IsValid;
            }
        }

    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                            this.numberBacking is null
            
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
    
                    if (this.numberBacking is double numberBacking)
                {
                    return JsonNumber.NumberToJsonElement(numberBacking);
                }

    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
    
                    if (this.numberBacking is double)
                {
                    return JsonValueKind.Number;
                }

    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
    
                    if (this.numberBacking is double numberBacking)
                {
                    return new JsonAny(numberBacking);
                }

    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

            /// <summary>
        /// Conversion from <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MinContainsEntity(IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue value)
        {
            return new MinContainsEntity(value);
        }

        /// <summary>
        /// Conversion to <see cref="IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue" />.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue(MinContainsEntity value)
        {
                                                    if (value.ValueKind == JsonValueKind.Number)
            {
                return new IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue(value.AsNumber);
            }
                    return default;
        }
    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MinContainsEntity(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new MinContainsEntity(value.AsJsonElement);
            }

            return value.As<MinContainsEntity>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(MinContainsEntity value)
        {
            return value.AsAny;
        }

    
    
    
    
        /// <summary>
        /// Conversion from double.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MinContainsEntity(double value)
        {
            return new MinContainsEntity(value);
        }

        /// <summary>
        /// Conversion to double.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator double(MinContainsEntity number)
        {
            return number.AsNumber.GetDouble();
        }

        /// <summary>
        /// Conversion from float.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MinContainsEntity(float value)
        {
            return new MinContainsEntity(value);
        }

        /// <summary>
        /// Conversion to float.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator float(MinContainsEntity number)
        {
            return number.AsNumber.GetSingle();
        }

        /// <summary>
        /// Conversion from long.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MinContainsEntity(long value)
        {
            return new MinContainsEntity(value);
        }

        /// <summary>
        /// Conversion to long.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator long(MinContainsEntity number)
        {
            return number.AsNumber.GetInt64();
        }

        /// <summary>
        /// Conversion from int.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MinContainsEntity(int value)
        {
            return new MinContainsEntity(value);
        }

        /// <summary>
        /// Conversion to int.
        /// </summary>
        /// <param name="number">The number from which to convert.</param>
        public static implicit operator int(MinContainsEntity number)
        {
            return number.AsNumber.GetInt32();
        }

        /// <summary>
        /// Conversion from number.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator MinContainsEntity(JsonNumber value)
        {
            return new MinContainsEntity(value);
        }

        /// <summary>
        /// Conversion to number.
        /// </summary>
        /// <param name="number">The value from which to convert.</param>
        public static implicit operator JsonNumber(MinContainsEntity number)
        {
            return number.AsNumber;
        }

    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(MinContainsEntity lhs, MinContainsEntity rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(MinContainsEntity lhs, MinContainsEntity rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray().GetHashCode(),
                        JsonValueKind.Number => this.AsNumber.GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
    
                if (this.numberBacking is double numberBacking)
            {
                writer.WriteNumberValue(numberBacking);
                return;
            }

    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(MinContainsEntity other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber.Equals(other.AsNumber),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<MinContainsEntity, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

                result = this.ValidateRef(result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    
    
    
    
    
        
    
    
    
    
    
    
    

                return result;
        }

    
    
            /// <summary>
        /// Gets the value as a <see cref="JsonNumber"/>.
        /// </summary>
        private JsonNumber AsNumber
        {
            get
            {
                if (this.numberBacking is double numberBacking)
                {
                    return new JsonNumber(numberBacking);
                }

                return new JsonNumber(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
            private ValidationContext ValidateRef(in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            ValidationContext refResult = this.As<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.NonNegativeIntegerValue>().Validate(validationContext.CreateChildContext(), level);

            if (!refResult.IsValid)
            {
                if (level >= ValidationLevel.Detailed)
                {
                    result = validationContext.MergeResults(false, level, refResult);
                }
                else if (level >= ValidationLevel.Basic)
                {
                    result = validationContext.MergeResults(false, level, refResult);
                }
                else
                {
                    result = validationContext.WithResult(isValid: false);
                }
            }
            else
            {
                if (level >= ValidationLevel.Basic)
                {
                    result = result.MergeResults(result.IsValid, level, refResult);
                }

                result = result.MergeChildContext(refResult, false);
            }

            return result;
        }
    
    
    
            

            

            

            

    
    
    
    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct JsonStringArray :
                IJsonArray<JsonStringArray>,
                IEquatable<JsonStringArray>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
            private readonly ImmutableList<JsonAny>? arrayBacking;
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="JsonStringArray"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public JsonStringArray(JsonElement value)
        {
            this.jsonElementBacking = value;
                    this.arrayBacking = default;
                        }

    
            /// <summary>
        /// Initializes a new instance of the <see cref="JsonStringArray"/> struct.
        /// </summary>
        /// <param name="value">An array list.</param>
        public JsonStringArray(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
                                            this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="JsonStringArray"/> struct.
        /// </summary>
        /// <param name="jsonArray">The <see cref="JsonArray"/> from which to construct the value.</param>
        public JsonStringArray(JsonArray jsonArray)
        {
            if (jsonArray.HasJsonElement)
            {
                this.jsonElementBacking = jsonArray.AsJsonElement;
                this.arrayBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.arrayBacking = jsonArray.AsItemsList;
            }

                                        }
    
    
    
    
    
    

            /// <inheritdoc/>
        public int Length
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> items)
                {
                    return items.Count;
                }

                return this.jsonElementBacking.GetArrayLength();
            }
        }
    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                        this.arrayBacking is null
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return JsonArray.ItemsToJsonElement(arrayBacking);
                }
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny>)
                {
                    return JsonValueKind.Array;
                }

    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
                    if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonAny(arrayBacking);
                }

    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonStringArray(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new JsonStringArray(value.AsJsonElement);
            }

            return value.As<JsonStringArray>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(JsonStringArray value)
        {
            return value.AsAny;
        }

    
        /// <summary>
        /// Conversion from array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonStringArray(JsonArray value)
        {
            return new JsonStringArray(value);
        }

        /// <summary>
        /// Conversion to array.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonArray(JsonStringArray value)
        {
            return value.AsArray;
        }
       
        /// <summary>
        /// Implicit conversion to an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(JsonStringArray value)
        {
            return value.AsArray.AsItemsList;
        }

        /// <summary>
        /// Implicit conversion from an <see cref="ImmutableList{T}"/> of <see cref="JsonAny"/>.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonStringArray(ImmutableList<JsonAny> value)
        {
            return new JsonStringArray(value);
        }
    
    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(JsonStringArray lhs, JsonStringArray rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(JsonStringArray lhs, JsonStringArray rhs)
        {
            return !lhs.Equals(rhs);
        }

                    /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="items">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonStringArray From(params Corvus.Json.JsonString[] items)
        {
            var builder = ImmutableList.CreateBuilder<JsonAny>();
            foreach (var item in items)
            {
                builder.Add(item);
            }

            return new JsonStringArray(builder.ToImmutable());
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The items from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonStringArray From(Corvus.Json.JsonString item1)
        {
            return new JsonStringArray(ImmutableList.Create((JsonAny)item1));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonStringArray From(Corvus.Json.JsonString item1, Corvus.Json.JsonString item2)
        {
            return new JsonStringArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonStringArray From(Corvus.Json.JsonString item1, Corvus.Json.JsonString item2, Corvus.Json.JsonString item3)
        {
            return new JsonStringArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2, (JsonAny)item3));
        }

        /// <summary>
        /// Create an array from the given items.
        /// </summary>
        /// <param name="item1">The first item from which to create the array.</param>
        /// <param name="item2">The second item from which to create the array.</param>
        /// <param name="item3">The third item from which to create the array.</param>
        /// <param name="item4">The fourth item from which to create the array.</param>
        /// <returns>The new array created from the items.</returns>
        public static JsonStringArray From(Corvus.Json.JsonString item1, Corvus.Json.JsonString item2, Corvus.Json.JsonString item3, Corvus.Json.JsonString item4)
        {
            return new JsonStringArray(ImmutableList.Create((JsonAny)item1, (JsonAny)item2, (JsonAny)item3, (JsonAny)item4));
        }
        
    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray.GetHashCode(),
                        JsonValueKind.Number => this.AsNumber().GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
            {
                JsonArray.WriteItems(arrayBacking, writer);
                return;
            }

    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
                /// <summary>
        /// Enumerate the items in the array as a <see cref="Corvus.Json.JsonString" />.
        /// </summary>
        public JsonArrayEnumerator<Corvus.Json.JsonString> EnumerateItems()
        {
            if (this.arrayBacking is ImmutableList<JsonAny> items)
            {
                return new JsonArrayEnumerator<Corvus.Json.JsonString>(items);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return new JsonArrayEnumerator<Corvus.Json.JsonString>(this.jsonElementBacking);
            }

            return default;
        }
                /// <inheritdoc/>
        public JsonArrayEnumerator EnumerateArray()
        {
            return this.AsArray.EnumerateArray();
        }
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray.Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(JsonStringArray other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray.Equals(other.AsArray),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public JsonStringArray Add<TItem>(TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray Add<TItem1, TItem2>(TItem1 item1, TItem2 item2)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray Add<TItem1, TItem2, TItem3>(TItem1 item1, TItem2 item2, TItem3 item3)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray Add<TItem1, TItem2, TItem3, TItem4>(TItem1 item1, TItem2 item2, TItem3 item3, TItem4 item4)
            where TItem1 : struct, IJsonValue
            where TItem2 : struct, IJsonValue
            where TItem3 : struct, IJsonValue
            where TItem4 : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(item1, item2, item3, item4);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray Add<TItem>(params TItem[] items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Add(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray AddRange<TItem>(IEnumerable<TItem> items)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.AddRange(items);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray Insert<TItem>(int index, TItem item)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsArray.Insert(index, item);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray Replace<TItem>(TItem oldValue, TItem newValue)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.Replace(oldValue, newValue);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray RemoveAt(int index)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveAt(index);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray RemoveRange(int index, int count)
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.RemoveRange(index, count);
            }

            return this;
        }

        /// <inheritdoc/>
        public JsonStringArray SetItem<TItem>(int index, TItem value)
            where TItem : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Array)
            {
                return this.AsArray.SetItem(index, value);
            }

            return this;
        }

    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<JsonStringArray, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
    

                result = this.ValidateArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
                return result;
        }

    
            /// <summary>
        /// Gets the value as a <see cref="JsonArray"/>.
        /// </summary>
        private JsonArray AsArray
        {
            get
            {
                if (this.arrayBacking is ImmutableList<JsonAny> arrayBacking)
                {
                    return new JsonArray(arrayBacking);
                }

                return new JsonArray(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
    
            private ValidationContext ValidateArray(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Array)
            {
                return result;
            }

         
            int arrayLength = 0;
         
        
                     JsonArrayEnumerator arrayEnumerator = this.EnumerateArray();

            while (arrayEnumerator.MoveNext())
            {
                        JsonArrayEnumerator innerEnumerator = this.EnumerateArray();
                int innerIndex = -1;
                while (innerIndex < arrayLength && innerEnumerator.MoveNext())
                {
                    innerIndex++;
                }

                while (innerEnumerator.MoveNext())
                {
                    if (innerEnumerator.Current.Equals(arrayEnumerator.Current))
                    {
                        if (level >= ValidationLevel.Detailed)
                        {
                            result = result.WithResult(isValid: false, $"6.4.3. uniqueItems - duplicate items were found at indices {arrayLength} and {innerIndex}.");
                        }
                        else if (level >= ValidationLevel.Basic)
                        {
                            result = result.WithResult(isValid: false, "6.4.3. uniqueItems - duplicate items were found.");
                        }
                        else
                        {
                            return result.WithResult(isValid: false);
                        }
                    }
                }

        
        
                        result = arrayEnumerator.Current.As<Corvus.Json.JsonString>().Validate(result, level);
                if (level == ValidationLevel.Flag && !result.IsValid)
                {
                    return result;
                }

                result = result.WithLocalItemIndex(arrayLength);

        
                arrayLength++;
            }
        
        
        
        
            return result;
        }

    
    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
        
                
            ValidationContext localResultArray = Corvus.Json.Validate.TypeArray(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultArray.IsValid)
            {
                return validationContext;
            }

            if (localResultArray.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
        
                
                , localResultArray
        
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct DependentRequiredValue :
            IJsonObject<DependentRequiredValue>,
                    IEquatable<DependentRequiredValue>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

            private readonly ImmutableDictionary<string, JsonAny>? objectBacking;
    
    
    
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="DependentRequiredValue"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public DependentRequiredValue(JsonElement value)
        {
            this.jsonElementBacking = value;
                this.objectBacking = default;
                            }

            /// <summary>
        /// Initializes a new instance of the <see cref="DependentRequiredValue"/> struct.
        /// </summary>
        /// <param name="value">A property dictionary.</param>
        public DependentRequiredValue(ImmutableDictionary<string, JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.objectBacking = value;
                                        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DependentRequiredValue"/> struct.
        /// </summary>
        /// <param name="jsonObject">The <see cref="JsonObject"/> from which to construct the value.</param>
        public DependentRequiredValue(JsonObject jsonObject)
        {
            if (jsonObject.HasJsonElement)
            {
                this.jsonElementBacking = jsonObject.AsJsonElement;
                this.objectBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.objectBacking = jsonObject.AsPropertyDictionary;
            }

                                        }
    
    
    
    
    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
                this.objectBacking is null
            
    
                
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
              
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return JsonObject.PropertiesToJsonElement(objectBacking);
                }

    
    
    
    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny>)
                {
                    return JsonValueKind.Object;
                }

    
    
    
    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
                    if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonAny(objectBacking);
                }

    
    
    
    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentRequiredValue(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new DependentRequiredValue(value.AsJsonElement);
            }

            return value.As<DependentRequiredValue>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(DependentRequiredValue value)
        {
            return value.AsAny;
        }

    
    
        /// <summary>
        /// Conversion from object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentRequiredValue(JsonObject value)
        {
            return new DependentRequiredValue(value);
        }

        /// <summary>
        /// Conversion to object.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonObject(DependentRequiredValue value)
        {
            return value.AsObject;
        }

                /// <summary>
        /// Implicit conversion to a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator ImmutableDictionary<string, JsonAny>(DependentRequiredValue  value)
        {
            return value.AsObject.AsPropertyDictionary;
        }

        /// <summary>
        /// Implicit conversion from a property dictionary.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator DependentRequiredValue (ImmutableDictionary<string, JsonAny> value)
        {
            return new DependentRequiredValue (value);
        }

    
    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(DependentRequiredValue lhs, DependentRequiredValue rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(DependentRequiredValue lhs, DependentRequiredValue rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject.GetHashCode(),
                        JsonValueKind.Array => this.AsArray().GetHashCode(),
                        JsonValueKind.Number => this.AsNumber().GetHashCode(),
                        JsonValueKind.String => this.AsString().GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
            {
                JsonObject.WriteProperties(objectBacking, writer);
                return;
            }

    
    
    
    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
                /// <summary>
        /// Enumerate the object as the given item type
        /// </summary>
        public JsonObjectEnumerator<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray> EnumerateProperties()
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return new JsonObjectEnumerator<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray>(properties);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return new JsonObjectEnumerator<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray>(this.jsonElementBacking);
            }

            return default;

        }
        
        
        /// <inheritdoc/>
        public JsonObjectEnumerator EnumerateObject()
        {
            return this.AsObject.EnumerateObject();
        }

    
    
    
        /// <inheritdoc/>
        public bool TryGetProperty(string name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(name, out value);
        }

        /// <inheritdoc/>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8name, out JsonAny value)
        {
            return this.AsObject.TryGetProperty(utf8name, out value);
        }

        
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject.Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(DependentRequiredValue other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject.Equals(other.AsObject),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString().Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
        /// <inheritdoc/>
        public bool HasProperty(string name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name, out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name.ToString(), out JsonElement _);
            }

            return false;
        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<char> name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(name.ToString(), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public bool HasProperty(ReadOnlySpan<byte> utf8name)
        {
            if (this.objectBacking is ImmutableDictionary<string, JsonAny> properties)
            {
                return properties.TryGetValue(System.Text.Encoding.UTF8.GetString(utf8name), out _);
            }

            if (this.jsonElementBacking.ValueKind == JsonValueKind.Object)
            {
                return this.jsonElementBacking.TryGetProperty(utf8name, out JsonElement _);
            }

            return false;        }

        /// <inheritdoc/>
        public DependentRequiredValue SetProperty<TValue>(string name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentRequiredValue SetProperty<TValue>(ReadOnlySpan<char> name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentRequiredValue SetProperty<TValue>(ReadOnlySpan<byte> utf8name, TValue value)
            where TValue : struct, IJsonValue
        {
            if (this.ValueKind == JsonValueKind.Object || this.ValueKind == JsonValueKind.Undefined)
            {
                return this.AsObject.SetProperty(utf8name, value);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentRequiredValue RemoveProperty(string name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentRequiredValue RemoveProperty(ReadOnlySpan<char> name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(name);
            }

            return this;
        }

        /// <inheritdoc/>
        public DependentRequiredValue RemoveProperty(ReadOnlySpan<byte> utf8Name)
        {
            if (this.ValueKind == JsonValueKind.Object)
            {
                return this.AsObject.RemoveProperty(utf8Name);
            }

            return this;
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<DependentRequiredValue, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
                    result = result.UsingEvaluatedProperties();
        
        

    
                JsonValueKind valueKind = this.ValueKind;
    
    
                    result = this.ValidateType(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
        
        
        
        
    
    
    
        
    
    
    
    
    
    
                result = this.ValidateObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }

    

                return result;
        }

            /// <summary>
        /// Gets the value as a <see cref="JsonObject"/>.
        /// </summary>
        private JsonObject AsObject
        {
            get
            {
                if (this.objectBacking is ImmutableDictionary<string, JsonAny> objectBacking)
                {
                    return new JsonObject(objectBacking);
                }

                return new JsonObject(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
    
    
    
            private ValidationContext ValidateObject(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;

            if (valueKind != JsonValueKind.Object)
            {
                return result;
            }

                    int propertyCount = 0;
        
        
            foreach (Property property in this.EnumerateObject())
            {
                string propertyName = property.Name;

        
        
        
        
                        if (!result.HasEvaluatedLocalProperty(propertyCount))
                {
                    result = property.ValueAs<IdDraft202012Feature.UnnormalizedIdsAreAllowedButDiscouraged.Validation.JsonStringArray>().Validate(result, level);
                    if (level == ValidationLevel.Flag && !result.IsValid)
                    {
                        return result;
                    }
                    result = result.WithLocalProperty(propertyCount);
                }
        
        
        
                
                propertyCount++;

                    }

        
        
        
            return result;
        }

    
            

            

            

            

    
    
    
            
        private ValidationContext ValidateType(JsonValueKind valueKind, in ValidationContext validationContext, ValidationLevel level)
        {
            ValidationContext result = validationContext;
            bool isValid = false;

        
                
            ValidationContext localResultObject = Corvus.Json.Validate.TypeObject(valueKind, result, level);
            if (level == ValidationLevel.Flag && localResultObject.IsValid)
            {
                return validationContext;
            }

            if (localResultObject.IsValid)
            {
                isValid = true;
            }

        
        
        
        
        
        
            result = result.MergeResults(
                isValid,
                level
        
                
                , localResultObject
        
        
        
        
        
                        );

            return result;
        }

    
    
    
    }
    

    
    
        /// <summary>
    /// A type generated from a JsonSchema specification.
    /// </summary>
    public readonly struct SimpleTypesEntity :
                    IJsonValue,
            IEquatable<SimpleTypesEntity>
    {

        
    
    
    
    
    
    
    

    
        private readonly JsonElement jsonElementBacking;

    
    
    
            private readonly string? stringBacking;
    
    
        /// <summary>
        /// Initializes a new instance of the <see cref="SimpleTypesEntity"/> struct.
        /// </summary>
        /// <param name="value">The backing <see cref="JsonElement"/>.</param>
        public SimpleTypesEntity(JsonElement value)
        {
            this.jsonElementBacking = value;
                            this.stringBacking = default;
                }

    
    
    
            /// <summary>
        /// Initializes a new instance of the <see cref="SimpleTypesEntity"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public SimpleTypesEntity(string value)
        {
            this.jsonElementBacking = default;
                                            this.stringBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SimpleTypesEntity"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public SimpleTypesEntity(ReadOnlySpan<char> value)
        {
            this.jsonElementBacking = default;
                                            this.stringBacking = value.ToString();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SimpleTypesEntity"/> struct.
        /// </summary>
        /// <param name="value">A string value.</param>
        public SimpleTypesEntity(ReadOnlySpan<byte> value)
        {
            this.jsonElementBacking = default;
                                            this.stringBacking = System.Text.Encoding.UTF8.GetString(value);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SimpleTypesEntity"/> struct.
        /// </summary>
        /// <param name="jsonString">The <see cref="JsonString"/> from which to construct the value.</param>
        public SimpleTypesEntity(JsonString jsonString)
        {
            if (jsonString.HasJsonElement)
            {
                this.jsonElementBacking = jsonString.AsJsonElement;
                this.stringBacking = default;
            }
            else
            {
                this.jsonElementBacking = default;
                this.stringBacking = jsonString;
            }

                                        }
    
    
    
    

    
    
    
            /// <summary>
        /// Gets a value indicating whether this is backed by a JSON element.
        /// </summary>
        public bool HasJsonElement =>
    
    
                                this.stringBacking is null
        
                ;

        /// <summary>
        /// Gets the value as a JsonElement.
        /// </summary>
        public JsonElement AsJsonElement
        {
            get
            {
    
    
    
                    if (this.stringBacking is string stringBacking)
                {
                    return JsonString.StringToJsonElement(stringBacking);
                }

    
    
                return this.jsonElementBacking;
            }
        }

        /// <inheritdoc/>
        public JsonValueKind ValueKind
        {
            get
            {
    
    
    
                    if (this.stringBacking is string)
                {
                    return JsonValueKind.String;
                }

    
    
                return this.jsonElementBacking.ValueKind;
            }
        }

        /// <inheritdoc/>
        public JsonAny AsAny
        {
            get
            {
    
    
    
                    if (this.stringBacking is string stringBacking)
                {
                    return new JsonAny(stringBacking);
                }

    
    
                return new JsonAny(this.jsonElementBacking);
            }
        }

    
        
        /// <summary>
        /// Conversion from any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SimpleTypesEntity(JsonAny value)
        {
            if (value.HasJsonElement)
            {
                return new SimpleTypesEntity(value.AsJsonElement);
            }

            return value.As<SimpleTypesEntity>();
        }

        /// <summary>
        /// Conversion to any.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonAny(SimpleTypesEntity value)
        {
            return value.AsAny;
        }

    
    
    
        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SimpleTypesEntity(string value)
        {
            return new SimpleTypesEntity(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator string(SimpleTypesEntity value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SimpleTypesEntity(ReadOnlySpan<char> value)
        {
            return new SimpleTypesEntity(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator ReadOnlySpan<char>(SimpleTypesEntity value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from utf8 bytes.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SimpleTypesEntity(ReadOnlySpan<byte> value)
        {
            return new SimpleTypesEntity(value);
        }

        /// <summary>
        /// Conversion to utf8 bytes.
        /// </summary>
        /// <param name="value">The number from which to convert.</param>
        public static implicit operator ReadOnlySpan<byte>(SimpleTypesEntity value)
        {
            return value.AsString;
        }

        /// <summary>
        /// Conversion from string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator SimpleTypesEntity(JsonString value)
        {
            return new SimpleTypesEntity(value);
        }

        /// <summary>
        /// Conversion to string.
        /// </summary>
        /// <param name="value">The value from which to convert.</param>
        public static implicit operator JsonString(SimpleTypesEntity value)
        {
            return value.AsString;
        }

    
    
    
        /// <summary>
        /// Standard equality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are equal.</returns>
        public static bool operator ==(SimpleTypesEntity lhs, SimpleTypesEntity rhs)
        {
            return lhs.Equals(rhs);
        }

        /// <summary>
        /// Standard inequality operator.
        /// </summary>
        /// <param name="lhs">The left hand side of the comparison.</param>
        /// <param name="rhs">The right hand side of the comparison.</param>
        /// <returns>True if they are not equal.</returns>
        public static bool operator !=(SimpleTypesEntity lhs, SimpleTypesEntity rhs)
        {
            return !lhs.Equals(rhs);
        }

    
    
        /// <inheritdoc/>
        public override bool Equals(object? obj)
        {
            if (obj is IJsonValue jv)
            {
                return this.Equals(jv.AsAny);
            }

            return obj is null && this.IsNull();
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            JsonValueKind valueKind = this.ValueKind;

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().GetHashCode(),
                        JsonValueKind.Array => this.AsArray().GetHashCode(),
                        JsonValueKind.Number => this.AsNumber().GetHashCode(),
                        JsonValueKind.String => this.AsString.GetHashCode(),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().GetHashCode(),
                    JsonValueKind.Null => JsonNull.NullHashCode,
                _ => JsonAny.UndefinedHashCode,
            };
        }

        /// <summary>
        /// Writes the object to the <see cref="Utf8JsonWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to which to write the object.</param>
        public void WriteTo(Utf8JsonWriter writer)
        {
    
    
    
                if (this.stringBacking is string stringBacking)
            {
                writer.WriteStringValue(stringBacking);
                return;
            }

    
    
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Undefined)
            {
                this.jsonElementBacking.WriteTo(writer);
                return;
            }

            writer.WriteNullValue();
        }

    
    
    
        /// <inheritdoc/>
        public bool Equals<T>(T other)
            where T : struct, IJsonValue
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                    JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString.Equals(other.AsString()),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

        /// <inheritdoc/>
        public bool Equals(SimpleTypesEntity other)
        {
            JsonValueKind valueKind = this.ValueKind;

            if (other.ValueKind != valueKind)
            {
                return false;
            }

            return valueKind switch
            {
                                JsonValueKind.Object => this.AsObject().Equals(other.AsObject()),
                        JsonValueKind.Array => this.AsArray().Equals(other.AsArray()),
                        JsonValueKind.Number => this.AsNumber().Equals(other.AsNumber()),
                        JsonValueKind.String => this.AsString.Equals(other.AsString),
                        JsonValueKind.True or JsonValueKind.False => this.AsBoolean().Equals(other.AsBoolean()),
                    JsonValueKind.Null => true,
                _ => false,
            };
        }

    
    
        /// <inheritdoc/>
        public T As<T>()
            where T : struct, IJsonValue
        {
            return this.As<SimpleTypesEntity, T>();
        }


    
        /// <inheritdoc/>
        public ValidationContext Validate(in ValidationContext? validationContext = null, ValidationLevel level = ValidationLevel.Flag)
        {
            ValidationContext result = validationContext ?? ValidationContext.ValidContext;
            if (level != ValidationLevel.Flag)
            {
                result = result.UsingStack();
            }
        
        

    
    
    
    
                result = Corvus.Json.Validate.ValidateEnum(
                this,
                result,
                level
                        , EnumValues.Item0
                        , EnumValues.Item1
                        , EnumValues.Item2
                        , EnumValues.Item3
                        , EnumValues.Item4
                        , EnumValues.Item5
                        , EnumValues.Item6
                        );

            if (level == ValidationLevel.Flag && !result.IsValid)
            {
                return result;
            }
    
        
    
    
    
    
    
    
    

                return result;
        }

    
    
    
            /// <summary>
        /// Gets the value as a <see cref="JsonString"/>.
        /// </summary>
        private JsonString AsString
        {
            get
            {
                if (this.stringBacking is string stringBacking)
                {
                    return new JsonString(stringBacking);
                }

                return new JsonString(this.jsonElementBacking);
            }
        }
    
    
    
    
    
    
    
    
    
    
            

            

            

            

    
    
    
    
            
        /// <summary>
        /// Permitted values.
        /// </summary>
        public static class EnumValues
        {
                                /// <summary>
            /// enumValue.AsPropertyName.
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly SimpleTypesEntity Array = JsonAny.Parse("\"array\"");
            
                                /// <summary>
            /// enumValue.AsPropertyName.
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly SimpleTypesEntity Boolean = JsonAny.Parse("\"boolean\"");
            
                                /// <summary>
            /// enumValue.AsPropertyName.
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly SimpleTypesEntity Integer = JsonAny.Parse("\"integer\"");
            
                                /// <summary>
            /// enumValue.AsPropertyName.
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly SimpleTypesEntity Null = JsonAny.Parse("\"null\"");
            
                                /// <summary>
            /// enumValue.AsPropertyName.
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly SimpleTypesEntity Number = JsonAny.Parse("\"number\"");
            
                                /// <summary>
            /// enumValue.AsPropertyName.
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly SimpleTypesEntity Object = JsonAny.Parse("\"object\"");
            
                                /// <summary>
            /// enumValue.AsPropertyName.
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            public static readonly SimpleTypesEntity String = JsonAny.Parse("\"string\"");
            
        

                                /// <summary>
            /// [{Title} || Item 0] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            internal static readonly SimpleTypesEntity Item0 = JsonAny.Parse("\"array\"");
                                    /// <summary>
            /// [{Title} || Item 1] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            internal static readonly SimpleTypesEntity Item1 = JsonAny.Parse("\"boolean\"");
                                    /// <summary>
            /// [{Title} || Item 2] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            internal static readonly SimpleTypesEntity Item2 = JsonAny.Parse("\"integer\"");
                                    /// <summary>
            /// [{Title} || Item 3] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            internal static readonly SimpleTypesEntity Item3 = JsonAny.Parse("\"null\"");
                                    /// <summary>
            /// [{Title} || Item 4] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            internal static readonly SimpleTypesEntity Item4 = JsonAny.Parse("\"number\"");
                                    /// <summary>
            /// [{Title} || Item 5] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            internal static readonly SimpleTypesEntity Item5 = JsonAny.Parse("\"object\"");
                                    /// <summary>
            /// [{Title} || Item 6] (with predictable naming).
            /// </summary>
            /// <remarks>
            /// {Description}.
            /// </remarks>
            internal static readonly SimpleTypesEntity Item6 = JsonAny.Parse("\"string\"");
                    }
    
    
    }
    

    
    }
    }
    