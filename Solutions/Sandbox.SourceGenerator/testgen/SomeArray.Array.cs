//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

#if NET8_0_OR_GREATER
using global::System.Buffers;
#endif
using global::System.Collections;
using global::System.Collections.Immutable;
using global::System.Runtime.CompilerServices;
using global::System.Text.Json;
using Corvus.Json;
using Corvus.Json.Internal;

namespace TestNs;
/// <summary>
/// Generated from JSON Schema.
/// </summary>
#if NET8_0_OR_GREATER
[CollectionBuilder(typeof(SomeArray), "Create")]
#endif
public readonly partial struct SomeArray
    : IJsonArray<TestNs.SomeArray>
{
    /// <summary>
    /// Gets an empty array.
    /// </summary>
    public static SomeArray EmptyArray { get; } = From(ImmutableList<JsonAny>.Empty);

    /// <inheritdoc/>
    Corvus.Json.JsonAny IJsonArray<SomeArray>.this[int index]
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (index < 0)
                {
                    throw new IndexOutOfRangeException();
                }

                JsonElement.ArrayEnumerator enumerator = this.jsonElementBacking.EnumerateArray();
                while (index >= 0)
                {
                    index--;
                    if (!enumerator.MoveNext())
                    {
                        throw new IndexOutOfRangeException();
                    }
                }

                return new(enumerator.Current);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking[index];
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }
    }

    /// <summary>
    /// Gets the tuple item as a <see cref="TestNs.SomeArray.PositiveInt32"/>.
    /// </summary>
    public TestNs.SomeArray.PositiveInt32 Item1
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new(this.jsonElementBacking[0]);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking[0].As<TestNs.SomeArray.PositiveInt32>();
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the tuple item as a <see cref="TestNs.SomeArray.PrefixItems1Entity"/>.
    /// </summary>
    public TestNs.SomeArray.PrefixItems1Entity Item2
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new(this.jsonElementBacking[1]);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking[1].As<TestNs.SomeArray.PrefixItems1Entity>();
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the tuple item as a <see cref="TestNs.SomeArray.PrefixItems2Entity"/>.
    /// </summary>
    public TestNs.SomeArray.PrefixItems2Entity Item3
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new(this.jsonElementBacking[2]);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking[2].As<TestNs.SomeArray.PrefixItems2Entity>();
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Conversion to tuple.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator (TestNs.SomeArray.PositiveInt32, TestNs.SomeArray.PrefixItems1Entity, TestNs.SomeArray.PrefixItems2Entity)(SomeArray value)
    {
        return (value.Item1, value.Item2, value.Item3);
    }

    /// <summary>
    /// Conversion from tuple.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator SomeArray((TestNs.SomeArray.PositiveInt32, TestNs.SomeArray.PrefixItems1Entity, TestNs.SomeArray.PrefixItems2Entity) value)
    {
        return SomeArray.Create(value.Item1, value.Item2, value.Item3);
    }

    /// <summary>
    /// Conversion from <see cref="ImmutableList{JsonAny}"/>.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator SomeArray(ImmutableList<JsonAny> value)
    {
        return new(value);
    }

    /// <summary>
    /// Conversion to <see cref="ImmutableList{JsonAny}"/>.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator ImmutableList<JsonAny>(SomeArray value)
    {
        return
            __CorvusArrayHelpers.GetImmutableList(value);
    }

    /// <summary>
    /// Conversion from JsonArray.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator SomeArray(JsonArray value)
    {
        if (value.HasDotnetBacking && value.ValueKind == JsonValueKind.Array)
        {
            return new(
                value.AsImmutableList());
        }

        return new(value.AsJsonElement);
    }

    /// <summary>
    /// Conversion to JsonArray.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator JsonArray(SomeArray value)
    {
        return
            value.AsArray;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SomeArray"/> struct.
    /// </summary>
    /// <param name="items">The list of items from which to construct the array.</param>
    /// <returns>An instance of the array constructed from the list.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SomeArray From(ImmutableList<JsonAny> items)
    {
        return new(items);
    }

#if NET8_0_OR_GREATER
    /// <summary>
    /// Initializes a new instance of the <see cref="SomeArray"/> struct.
    /// </summary>
    /// <param name="items">The items from which to construct the instance.</param>
    /// <returns>An instance of the array constructed from the items .</returns>
    static SomeArray IJsonArray<SomeArray>.FromRange(IEnumerable<JsonAny> items)
    {
        return new([..items]);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SomeArray"/> struct.
    /// </summary>
    /// <typeparam name="T">The type of the items to add.</typeparam>
    /// <param name="items">The items from which to construct the instance.</param>
    /// <returns>An instance of the array constructed from the items.</returns>
    static SomeArray IJsonArray<SomeArray>.FromRange<T>(IEnumerable<T> items)
    {
        return new([..items.Select(item => item.AsAny)]);
    }
#endif

    /// <summary>
    /// Create a tuple from the given items.
    /// </summary>
    /// <param name="item1">The value for the 1st item.</param>
    /// <param name="item2">The value for the 2nd item.</param>
    /// <param name="item3">The value for the 3rd item.</param>
    /// <returns>The new tuple created from the items.</returns>
    public static SomeArray Create(in TestNs.SomeArray.PositiveInt32 item1, in TestNs.SomeArray.PrefixItems1Entity item2, in TestNs.SomeArray.PrefixItems2Entity item3)
    {
        return new([item1, item2, item3]);
    }

    /// <inheritdoc/>
    public ImmutableList<JsonAny> AsImmutableList()
    {
        return __CorvusArrayHelpers.GetImmutableList(this);
    }

    /// <inheritdoc/>
    public ImmutableList<JsonAny>.Builder AsImmutableListBuilder()
    {
        return __CorvusArrayHelpers.GetImmutableListBuilder(this);
    }

    /// <inheritdoc/>
    public int GetArrayLength()
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return this.jsonElementBacking.GetArrayLength();
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return this.arrayBacking.Count;
        }

        return 0;
    }

    /// <inheritdoc/>
    public JsonArrayEnumerator EnumerateArray()
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return new(this.jsonElementBacking);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return new(this.arrayBacking);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
    public JsonArrayEnumerator<TItem> EnumerateArray<TItem>()
        where TItem : struct, IJsonValue<TItem>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return new(this.jsonElementBacking);
        }

        if ((this.backing & Backing.Array) != 0)
        {
            return new(this.arrayBacking);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.Add(in JsonAny item1)
    {
        ImmutableList<JsonAny>.Builder builder = __CorvusArrayHelpers.GetImmutableListBuilder(this);
        builder.Add(item1);
        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.Add(params JsonAny[] items)
    {
        ImmutableList<JsonAny>.Builder builder = __CorvusArrayHelpers.GetImmutableListBuilder(this);
        foreach (JsonAny item in items)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.AddRange<TArray>(in TArray items)
    {
        ImmutableList<JsonAny>.Builder builder = __CorvusArrayHelpers.GetImmutableListBuilder(this);
        foreach (JsonAny item in items.EnumerateArray())
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.AddRange<TItem>(IEnumerable<TItem> items)
    {
        ImmutableList<JsonAny>.Builder builder = __CorvusArrayHelpers.GetImmutableListBuilder(this);
        foreach (TItem item in items)
        {
            builder.Add(item.AsAny);
        }

        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.AddRange(IEnumerable<JsonAny> items)
    {
        ImmutableList<JsonAny>.Builder builder = __CorvusArrayHelpers.GetImmutableListBuilder(this);
        builder.AddRange(items);
        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.Insert(int index, in JsonAny item1)
    {
        return new(__CorvusArrayHelpers.GetImmutableListWith(this, index, item1));
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.InsertRange<TArray>(int index, in TArray items)
    {
        return new(__CorvusArrayHelpers.GetImmutableListWith(this, index, items.EnumerateArray()));
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.InsertRange<TItem>(int index, IEnumerable<TItem> items)
    {
        return new(__CorvusArrayHelpers.GetImmutableListWith(this, index, items.Select(item => item.AsAny)));
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.InsertRange(int index, IEnumerable<JsonAny> items)
    {
        return new(__CorvusArrayHelpers.GetImmutableListWith(this, index, items));
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.Replace(in JsonAny oldValue, in JsonAny newValue)
    {
        return new(__CorvusArrayHelpers.GetImmutableListReplacing(this, oldValue, newValue));
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.SetItem(int index, in JsonAny value)
    {
        return new(__CorvusArrayHelpers.GetImmutableListSetting(this, index, value));
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.Remove(in JsonAny oldValue)
    {
        return new(__CorvusArrayHelpers.GetImmutableListWithout(this, oldValue));
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.RemoveAt(int index)
    {
        return new(__CorvusArrayHelpers.GetImmutableListWithoutRange(this, index, 1));
    }

    /// <inheritdoc/>
    SomeArray IJsonArray<SomeArray>.RemoveRange(int index, int count)
    {
        return new(__CorvusArrayHelpers.GetImmutableListWithoutRange(this, index, count));
    }

    private static class __CorvusArrayHelpers
    {
        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array.
        /// </summary>
        /// <param name="arrayInstance">The array instance.</param>
        /// <returns>An immutable list of <see cref = "JsonAny"/> built from the array.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        public static ImmutableList<JsonAny> GetImmutableList(in SomeArray arrayInstance)
        {
            if ((arrayInstance.backing & Backing.Array) != 0)
            {
                return arrayInstance.arrayBacking;
            }

            return GetImmutableListBuilder(arrayInstance).ToImmutable();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}.Builder"/> from the array.
        /// </summary>
        /// <param name="arrayInstance">The array instance.</param>
        /// <returns>An immutable list builder of <see cref = "JsonAny"/>, built from the existing array.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        public static ImmutableList<JsonAny>.Builder GetImmutableListBuilder(in SomeArray arrayInstance)
        {
            if ((arrayInstance.backing & Backing.JsonElement) != 0)
            {
                if (arrayInstance.jsonElementBacking.ValueKind == JsonValueKind.Array)
                {
                    ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
                    foreach (JsonElement item in arrayInstance.jsonElementBacking.EnumerateArray())
                    {
                        builder.Add(new(item));
                    }

                    return builder;
                }
            }

            if ((arrayInstance.backing & Backing.Array) != 0)
            {
                return arrayInstance.arrayBacking.ToBuilder();
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, replacing the item at the specified index with the given item.
        /// </summary>
        /// <param name="arrayInstance">The array instance.</param>
        /// <param name="index">The index at which to add the element.</param>
        /// <param name="value">The value to add.</param>
        /// <returns>An immutable list containing the contents of the list, with the specified item at the index.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        /// <exception cref = "IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
        public static ImmutableList<JsonAny> GetImmutableListSetting(in SomeArray arrayInstance, int index, in JsonAny value)
        {
            if ((arrayInstance.backing & Backing.JsonElement) != 0)
            {
                if (arrayInstance.jsonElementBacking.ValueKind == JsonValueKind.Array)
                {
                    return JsonValueHelpers.GetImmutableListFromJsonElementSetting(arrayInstance.jsonElementBacking, index, value);
                }
            }

            if ((arrayInstance.backing & Backing.Array) != 0)
            {
                try
                {
                    return arrayInstance.arrayBacking.SetItem(index, value);
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, removing the first item that equals the given value, and replacing it with the specified item.
        /// </summary>
        /// <param name="arrayInstance">The array instance.</param>
        /// <param name="oldItem">The item to remove.</param>
        /// <param name="newItem">The item to insert.</param>
        /// <returns>An immutable list containing the contents of the list, without the first instance that matches the old item, replacing it with the new item.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        public static ImmutableList<JsonAny> GetImmutableListReplacing(in SomeArray arrayInstance, in JsonAny oldItem, in JsonAny newItem)
        {
            if ((arrayInstance.backing & Backing.JsonElement) != 0)
            {
                if (arrayInstance.jsonElementBacking.ValueKind == JsonValueKind.Array)
                {
                    return JsonValueHelpers.GetImmutableListFromJsonElementReplacing(arrayInstance.jsonElementBacking, oldItem, newItem);
                }
            }

            if ((arrayInstance.backing & Backing.Array) != 0)
            {
                return  arrayInstance.arrayBacking.Replace(oldItem, newItem);
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, removing the first item arrayInstance equals the given value.
        /// </summary>
        /// <param name="arrayInstance">The array instance.</param>
        /// <param name="item">The item to remove.</param>
        /// <returns>An immutable list containing the contents of the list, without the first instance arrayInstance matches the given item.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        public static ImmutableList<JsonAny> GetImmutableListWithout(in SomeArray arrayInstance, in JsonAny item)
        {
            if ((arrayInstance.backing & Backing.JsonElement) != 0)
            {
                if (arrayInstance.jsonElementBacking.ValueKind == JsonValueKind.Array)
                {
                    return JsonValueHelpers.GetImmutableListFromJsonElementWithout(arrayInstance.jsonElementBacking, item);
                }
            }

            if ((arrayInstance.backing & Backing.Array) != 0)
            {
                return  arrayInstance.arrayBacking.Remove(item);
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, removing the given range.
        /// </summary>
        /// <param name="arrayInstance">The array instance.</param>
        /// <param name="index">The start index of the range to remove.</param>
        /// <param name="count">The length of the range to remove.</param>
        /// <returns>An immutable list containing the contents of the list, without the given range of items.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        /// <exception cref = "IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
        public static ImmutableList<JsonAny> GetImmutableListWithoutRange(in SomeArray arrayInstance, int index, int count)
        {
            if ((arrayInstance.backing & Backing.JsonElement) != 0)
            {
                if (arrayInstance.jsonElementBacking.ValueKind == JsonValueKind.Array)
                {
                    return JsonValueHelpers.GetImmutableListFromJsonElementWithoutRange(arrayInstance.jsonElementBacking, index, count);
                }
            }

            if ((arrayInstance.backing & Backing.Array) != 0)
            {
                try
                {
                    return arrayInstance.arrayBacking.RemoveRange(index, count);
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }

        // <summary>
        // Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, inserting the given item at the index.
        // </summary>
        // <param name="arrayInstance">The array instance.</param>
        // <param name="index">The index at which to add the element.</param>
        // <param name="value">The value to add.</param>
        // <returns>An immutable list containing the contents of the list, without the array.</returns>
        // <exception cref = "InvalidOperationException">The value is not an array.</exception>
        // <exception cref = "IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
        public static ImmutableList<JsonAny> GetImmutableListWith(in SomeArray arrayInstance, int index, in JsonAny value)
        {
            if ((arrayInstance.backing & Backing.JsonElement) != 0)
            {
                if (arrayInstance.jsonElementBacking.ValueKind == JsonValueKind.Array)
                {
                    return JsonValueHelpers.GetImmutableListFromJsonElementWith(arrayInstance.jsonElementBacking, index, value);
                }
            }

            if ((arrayInstance.backing & Backing.Array) != 0)
            {
                try
                {
                    return arrayInstance.arrayBacking.Insert(index, value);
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, inserting the items at the
        /// given index.
        /// </summary>
        /// <param name="arrayInstance">The array instance.</param>
        /// <param name="index">The index at which to add the element.</param>
        /// <param name="values">The values to add.</param>
        /// <returns>An immutable list containing the contents of the list, without the array.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        /// <exception cref = "IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
        public static ImmutableList<JsonAny> GetImmutableListWith<TEnumerable>(in SomeArray arrayInstance, int index, TEnumerable values)
            where TEnumerable : IEnumerable<JsonAny>
        {
            if ((arrayInstance.backing & Backing.JsonElement) != 0)
            {
                if (arrayInstance.jsonElementBacking.ValueKind == JsonValueKind.Array)
                {
                    return JsonValueHelpers.GetImmutableListFromJsonElementWith(arrayInstance.jsonElementBacking, index, values);
                }
            }

            if ((arrayInstance.backing & Backing.Array) != 0)
            {
                try
                {
                    return arrayInstance.arrayBacking.InsertRange(index, values);
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }
    }
}
