//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System.Buffers;
using System.Collections;
using System.Collections.Immutable;
using System.Runtime.CompilerServices;
using System.Text.Json;
using Corvus.Json;
using Corvus.Json.Internal;

namespace JsonSchemaSample.Api;
public readonly partial struct TensorRank3
{
    /// <summary>
    /// Generated from JSON Schema.
    /// </summary>
    
#if NET8_0_OR_GREATER
[CollectionBuilder(typeof(SecondRank), "Create")]
public readonly partial struct SecondRank : IJsonArray<SecondRank>, IReadOnlyCollection<JsonSchemaSample.Api.TensorRank3.ThirdRank>
#else
    public readonly partial struct SecondRank : IJsonArray<SecondRank>, IReadOnlyCollection<JsonSchemaSample.Api.TensorRank3.ThirdRank>
#endif
    {
        /// <summary>
        /// Gets an empty array.
        /// </summary>
        public static readonly SecondRank EmptyArray = From(ImmutableList<JsonAny>.Empty);
        /// <summary>
        /// Initializes a new instance of the <see cref = "SecondRank"/> struct.
        /// </summary>
        /// <param name = "value">The value from which to construct the instance.</param>
        public SecondRank(ImmutableList<JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.backing = Backing.Array;
            this.arrayBacking = value;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref = "SecondRank"/> struct.
        /// </summary>
        /// <param name = "value">The value from which to construct the instance.</param>
        public SecondRank(IEnumerable<JsonAny> value)
        {
            this.jsonElementBacking = default;
            this.backing = Backing.Array;
            this.arrayBacking = value.ToImmutableList();
        }

        /// <summary>
        /// Gets the rank of the array.
        /// </summary>
        public static int Rank => 2;
        /// <summary>
        /// Gets the dimension of the array in this rank.
        /// </summary>
        public static int Dimension => 4;
        /// <summary>
        /// Gets the total size of a buffer required to represent the array.
        /// </summary>
        /// <remarks>
        /// This calculates the array based on the dimension of each rank. It is generally
        /// used to determine the size of the buffer required by
        /// <see cref = "TryGetNumericValues(Span{double}, out int)"/>.
        /// </remarks>
        public static int ValueBufferSize => 16;

        /// <inheritdoc/>
        JsonAny IJsonArray<SecondRank>.this[int index]
        {
            get
            {
                if ((this.backing & Backing.JsonElement) != 0)
                {
                    return new JsonAny(this.jsonElementBacking[index]);
                }

                if ((this.backing & Backing.Array) != 0)
                {
                    try
                    {
                        return this.arrayBacking[index];
                    }
                    catch (ArgumentOutOfRangeException ex)
                    {
                        throw new IndexOutOfRangeException(ex.Message, ex);
                    }
                }

                throw new InvalidOperationException();
            }
        }

        /// <summary>
        /// Gets the item at the given index.
        /// </summary>
        /// <param name = "index">The index at which to retrieve the item.</param>
        /// <returns>The item at the given index.</returns>
        /// <exception cref = "IndexOutOfRangeException">The index was outside the bounds of the array.</exception>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        public JsonSchemaSample.Api.TensorRank3.ThirdRank this[int index]
        {
            get
            {
                if ((this.backing & Backing.JsonElement) != 0)
                {
                    return new JsonSchemaSample.Api.TensorRank3.ThirdRank(this.jsonElementBacking[index]);
                }

                if ((this.backing & Backing.Array) != 0)
                {
                    try
                    {
                        return this.arrayBacking[index].As<JsonSchemaSample.Api.TensorRank3.ThirdRank>();
                    }
                    catch (ArgumentOutOfRangeException ex)
                    {
                        throw new IndexOutOfRangeException(ex.Message, ex);
                    }
                }

                throw new InvalidOperationException();
            }
        }

        /// <summary>
        /// Conversion from immutable list.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator ImmutableList<JsonAny>(SecondRank value)
        {
            return value.GetImmutableList();
        }

        /// <summary>s
        /// Conversion to immutable list.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator SecondRank(ImmutableList<JsonAny> value)
        {
            return new(value);
        }

        /// <summary>
        /// Conversion from JsonArray.
        /// </summary>
        /// <param name = "value">The value from which to convert.</param>
        public static implicit operator SecondRank(JsonArray value)
        {
            if (value.HasDotnetBacking && value.ValueKind == JsonValueKind.Array)
            {
                return new(value.AsImmutableList());
            }

            return new(value.AsJsonElement);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref = "SecondRank"/> struct.
        /// </summary>
        /// <param name = "items">The list of items from which to construct the array.</param>
        /// <returns>An instance of the array constructed from the list.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SecondRank From(ImmutableList<JsonAny> items)
        {
            return new(items);
        }

        /// <summary>
        /// Create an array from the span of items.
        /// </summary>
        /// <param name = "items">The items from which to create the array.</param>
        /// <returns>The array containing the items.</returns>
        public static SecondRank Create(ReadOnlySpan<JsonSchemaSample.Api.TensorRank3.ThirdRank> items)
        {
            return new([..items]);
        }

#if NET8_0_OR_GREATER
    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name = "items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    /// <remarks>
    /// This will serialize the items to create the underlying JsonArray. Note the
    /// other overloads which avoid this serialization step.
    /// </remarks>
    static SecondRank IJsonArray<SecondRank>.FromRange(IEnumerable<JsonAny> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (JsonAny item in items)
        {
            builder.Add(item);
        }

        return new SecondRank(builder.ToImmutable());
    }

    /// <summary>
    /// Create an array from the given items.
    /// </summary>
    /// <param name = "items">The items from which to create the array.</param>
    /// <returns>The new array created from the items.</returns>
    /// <remarks>
    /// This will serialize the items to create the underlying JsonArray. Note the
    /// other overloads which avoid this serialization step.
    /// </remarks>
    static SecondRank IJsonArray<SecondRank>.FromRange<T>(IEnumerable<T> items)
    {
        ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
        foreach (T item in items)
        {
            builder.Add(item.AsAny);
        }

        return new SecondRank(builder.ToImmutable());
    }
#endif
        /// <summary>
        /// Creates an instance of the array of rank 2, dimension 4, from the given values.
        /// </summary>
        /// <param name = "values">The numeric values from which to create the array.</param>
        /// <returns>An instance of the array populated from the given values.</returns>
        /// <remarks>
        /// The values should be of length 16.
        /// </remarks>
        public static SecondRank FromValues(ReadOnlySpan<double> values)
        {
            if (values.Length != 16)
            {
                throw new ArgumentException(nameof(values));
            }

            ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
            int index = 0;
            while (index < values.Length)
            {
                JsonSchemaSample.Api.TensorRank3.ThirdRank child = JsonSchemaSample.Api.TensorRank3.ThirdRank.FromValues(values.Slice(index, 4));
                builder.Add(child);
                index += 4;
            }

            return new(builder.ToImmutable());
        }

        /// <inheritdoc/>
        IEnumerator<JsonSchemaSample.Api.TensorRank3.ThirdRank> IEnumerable<JsonSchemaSample.Api.TensorRank3.ThirdRank>.GetEnumerator()
        {
            return EnumerateArray();
        }

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
        {
            return EnumerateArray();
        }

        /// <inheritdoc/>
        int IReadOnlyCollection<JsonSchemaSample.Api.TensorRank3.ThirdRank>.Count => this.GetArrayLength();

        /// <inheritdoc/>
        public ImmutableList<JsonAny> AsImmutableList()
        {
            return this.GetImmutableList();
        }

        /// <inheritdoc/>
        public ImmutableList<JsonAny>.Builder AsImmutableListBuilder()
        {
            return this.GetImmutableListBuilder();
        }

        /// <inheritdoc/>
        public int GetArrayLength()
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return this.jsonElementBacking.GetArrayLength();
            }

            if ((this.backing & Backing.Array) != 0)
            {
                return this.arrayBacking.Count;
            }

            return 0;
        }

        /// <inheritdoc/>
        public JsonArrayEnumerator<JsonSchemaSample.Api.TensorRank3.ThirdRank> EnumerateArray()
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new JsonArrayEnumerator<JsonSchemaSample.Api.TensorRank3.ThirdRank>(this.jsonElementBacking);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                return new JsonArrayEnumerator<JsonSchemaSample.Api.TensorRank3.ThirdRank>(this.arrayBacking);
            }

            throw new InvalidOperationException();
        }

        /// <inheritdoc/>
        JsonArrayEnumerator IJsonArray<SecondRank>.EnumerateArray()
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new JsonArrayEnumerator(this.jsonElementBacking);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                return new JsonArrayEnumerator(this.arrayBacking);
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Fills the span with the numeric values in the array.
        /// </summary>
        /// <param name = "items">The <see cref = "Span{double}"/> to fill with the values in the array.</param>
        /// <param name = "written">The number of values written.</param>
        /// <returns><see langword="true"/> if the array was written successfully, otherwise <see langword="false"/>.</returns>
        /// <remarks>
        /// You can determine the size of the array to fill by interrogating
        /// <see cref = "TotalSize"/>
        /// </remarks>
        public bool TryGetNumericValues(Span<double> items, out int written)
        {
            int index = 0;
            if ((this.backing & Backing.Array) != 0)
            {
                if (items.Length < SecondRank.ValueBufferSize)
                {
                    written = 0;
                    return false;
                }

                foreach (var item in this.arrayBacking)
                {
                    JsonSchemaSample.Api.TensorRank3.ThirdRank child = item.As<JsonSchemaSample.Api.TensorRank3.ThirdRank>();
                    if (!child.TryGetNumericValues(items[index..], out int writtenChildren))
                    {
                        written = 0;
                        return false;
                    }

                    index += writtenChildren;
                }

                written = index;
                return true;
            }

            if (this.jsonElementBacking.ValueKind != JsonValueKind.Array)
            {
                written = 0;
                return false;
            }

            if (items.Length < SecondRank.ValueBufferSize)
            {
                written = 0;
                return false;
            }

            foreach (JsonElement jsonElement in this.jsonElementBacking.EnumerateArray())
            {
                JsonSchemaSample.Api.TensorRank3.ThirdRank child = JsonSchemaSample.Api.TensorRank3.ThirdRank.FromJson(jsonElement);
                if (!child.TryGetNumericValues(items[index..], out int writtenChildren))
                {
                    written = 0;
                    return false;
                }

                index += writtenChildren;
            }

            written = index;
            return true;
        }

        /// <inheritdoc/>
        JsonArrayEnumerator<TItem> IJsonArray<SecondRank>.EnumerateArray<TItem>()
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return new JsonArrayEnumerator<TItem>(this.jsonElementBacking);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                return new JsonArrayEnumerator<TItem>(this.arrayBacking);
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array.
        /// </summary>
        /// <returns>An immutable list of <see cref = "JsonAny"/> built from the array.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        private ImmutableList<JsonAny> GetImmutableList()
        {
            if ((this.backing & Backing.Array) != 0)
            {
                return this.arrayBacking;
            }

            return this.GetImmutableListBuilder().ToImmutable();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}.Builder"/> from the array.
        /// </summary>
        /// <returns>An immutable list builder of <see cref = "JsonAny"/>, built from the existing array.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        private ImmutableList<JsonAny>.Builder GetImmutableListBuilder()
        {
            if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                ImmutableList<JsonAny>.Builder builder = ImmutableList.CreateBuilder<JsonAny>();
                foreach (JsonElement item in this.jsonElementBacking.EnumerateArray())
                {
                    builder.Add(new(item));
                }

                return builder;
            }

            if ((this.backing & Backing.Array) != 0)
            {
                return this.arrayBacking.ToBuilder();
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, replacing the item at the specified index with the given item.
        /// </summary>
        /// <param name = "index">The index at which to add the element.</param>
        /// <param name = "value">The value to add.</param>
        /// <returns>An immutable list containing the contents of the list, with the specified item at the index.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        /// <exception cref = "IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
        private ImmutableList<JsonAny> GetImmutableListSetting(int index, in JsonAny value)
        {
            if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return JsonValueHelpers.GetImmutableListFromJsonElementSetting(this.jsonElementBacking, index, value);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking.SetItem(index, value);
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, removing the first item that equals the given value, and replacing it with the specified item.
        /// </summary>
        /// <param name = "oldItem">The item to remove.</param>
        /// <param name = "newItem">The item to insert.</param>
        /// <returns>An immutable list containing the contents of the list, without the first instance that matches the old item, replacing it with the new item.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        private ImmutableList<JsonAny> GetImmutableListReplacing(in JsonAny oldItem, in JsonAny newItem)
        {
            if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return JsonValueHelpers.GetImmutableListFromJsonElementReplacing(this.jsonElementBacking, oldItem, newItem);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                return this.arrayBacking.Replace(oldItem, newItem);
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, removing the first item that equals the given value.
        /// </summary>
        /// <param name = "item">The item to remove.</param>
        /// <returns>An immutable list containing the contents of the list, without the first instance that matches the given item.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        private ImmutableList<JsonAny> GetImmutableListWithout(in JsonAny item)
        {
            if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return JsonValueHelpers.GetImmutableListFromJsonElementWithout(this.jsonElementBacking, item);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                return this.arrayBacking.Remove(item);
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, removing the given range.
        /// </summary>
        /// <param name = "index">The start index of the range to remove.</param>
        /// <param name = "count">The length of the range to remove.</param>
        /// <returns>An immutable list containing the contents of the list, without the given range of items.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        /// <exception cref = "IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
        private ImmutableList<JsonAny> GetImmutableListWithoutRange(int index, int count)
        {
            if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return JsonValueHelpers.GetImmutableListFromJsonElementWithoutRange(this.jsonElementBacking, index, count);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking.RemoveRange(index, count);
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, adding the given item.
        /// </summary>
        /// <param name = "index">The index at which to add the element.</param>
        /// <param name = "value">The value to add.</param>
        /// <returns>An immutable list containing the contents of the list, without the array.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        /// <exception cref = "IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
        private ImmutableList<JsonAny> GetImmutableListWith(int index, in JsonAny value)
        {
            if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return JsonValueHelpers.GetImmutableListFromJsonElementWith(this.jsonElementBacking, index, value);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking.Insert(index, value);
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref = "ImmutableList{JsonAny}"/> from the array, adding the given item.
        /// </summary>
        /// <param name = "index">The index at which to add the element.</param>
        /// <param name = "values">The values to add.</param>
        /// <returns>An immutable list containing the contents of the list, without the array.</returns>
        /// <exception cref = "InvalidOperationException">The value is not an array.</exception>
        /// <exception cref = "IndexOutOfRangeException">Thrown if the range is beyond the bounds of the array.</exception>
        private ImmutableList<JsonAny> GetImmutableListWith<TEnumerable>(int index, TEnumerable values)
            where TEnumerable : IEnumerable<JsonAny>
        {
            if ((this.backing & Backing.JsonElement) != 0 && this.jsonElementBacking.ValueKind == JsonValueKind.Array)
            {
                return JsonValueHelpers.GetImmutableListFromJsonElementWith(this.jsonElementBacking, index, values);
            }

            if ((this.backing & Backing.Array) != 0)
            {
                try
                {
                    return this.arrayBacking.InsertRange(index, values);
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException(ex.Message, ex);
                }
            }

            throw new InvalidOperationException();
        }
    }
}